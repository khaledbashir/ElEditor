{"version":3,"file":"markdown.js","sourceRoot":"","sources":["../../../src/_common/transformers/markdown.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Doc, DocCollection } from '@blocksuite/store';\n\nimport { BlockSuiteError, ErrorCode } from '@blocksuite/global/exceptions';\nimport { assertExists, sha } from '@blocksuite/global/utils';\nimport { extMimeMap, Job } from '@blocksuite/store';\n\nimport { MarkdownAdapter } from '../adapters/markdown/index.js';\nimport {\n  defaultImageProxyMiddleware,\n  docLinkBaseURLMiddleware,\n  fileNameMiddleware,\n  titleMiddleware,\n} from './middlewares.js';\nimport { createAssetsArchive, download, Unzip } from './utils.js';\n\ntype ImportMarkdownToBlockOptions = {\n  doc: Doc;\n  markdown: string;\n  blockId: string;\n};\n\ntype ImportMarkdownToDocOptions = {\n  collection: DocCollection;\n  markdown: string;\n  fileName?: string;\n};\n\ntype ImportMarkdownZipOptions = {\n  collection: DocCollection;\n  imported: Blob;\n};\n\n/**\n * Exports a doc to a Markdown file or a zip archive containing Markdown and assets.\n * @param doc The doc to export\n * @returns A Promise that resolves when the export is complete\n */\nasync function exportDoc(doc: Doc) {\n  const job = new Job({\n    collection: doc.collection,\n    middlewares: [docLinkBaseURLMiddleware, titleMiddleware],\n  });\n  const snapshot = job.docToSnapshot(doc);\n\n  const adapter = new MarkdownAdapter(job);\n  if (!snapshot) {\n    return;\n  }\n\n  const markdownResult = await adapter.fromDocSnapshot({\n    snapshot,\n    assets: job.assetsManager,\n  });\n\n  let downloadBlob: Blob;\n  const docTitle = doc.meta?.title || 'Untitled';\n  let name: string;\n  const contentBlob = new Blob([markdownResult.file], { type: 'plain/text' });\n  if (markdownResult.assetsIds.length > 0) {\n    if (!job.assets) {\n      throw new BlockSuiteError(ErrorCode.ValueNotExists, 'No assets found');\n    }\n    const zip = await createAssetsArchive(job.assets, markdownResult.assetsIds);\n\n    await zip.file('index.md', contentBlob);\n\n    downloadBlob = await zip.generate();\n    name = `${docTitle}.zip`;\n  } else {\n    downloadBlob = contentBlob;\n    name = `${docTitle}.md`;\n  }\n  download(downloadBlob, name);\n}\n\n/**\n * Imports Markdown content into a specific block within a doc.\n * @param options Object containing import options\n * @param options.doc The target doc\n * @param options.markdown The Markdown content to import\n * @param options.blockId The ID of the block where the content will be imported\n * @returns A Promise that resolves when the import is complete\n */\nasync function importMarkdownToBlock({\n  doc,\n  markdown,\n  blockId,\n}: ImportMarkdownToBlockOptions) {\n  const job = new Job({\n    collection: doc.collection,\n    middlewares: [defaultImageProxyMiddleware, docLinkBaseURLMiddleware],\n  });\n  const adapter = new MarkdownAdapter(job);\n  const snapshot = await adapter.toSliceSnapshot({\n    file: markdown,\n    assets: job.assetsManager,\n    workspaceId: doc.collection.id,\n    pageId: doc.id,\n  });\n\n  assertExists(snapshot, 'import markdown failed, expected to get a snapshot');\n\n  const blocks = snapshot.content.flatMap(x => x.children);\n\n  for (const block of blocks) {\n    await job.snapshotToBlock(block, doc, blockId);\n  }\n\n  return;\n}\n\n/**\n * Imports Markdown content into a new doc within a collection.\n * @param options Object containing import options\n * @param options.collection The target doc collection\n * @param options.markdown The Markdown content to import\n * @param options.fileName Optional filename for the imported doc\n * @returns A Promise that resolves to the ID of the newly created doc, or undefined if import fails\n */\nasync function importMarkdownToDoc({\n  collection,\n  markdown,\n  fileName,\n}: ImportMarkdownToDocOptions) {\n  const job = new Job({\n    collection,\n    middlewares: [\n      defaultImageProxyMiddleware,\n      fileNameMiddleware(fileName),\n      docLinkBaseURLMiddleware,\n    ],\n  });\n  const mdAdapter = new MarkdownAdapter(job);\n  const page = await mdAdapter.toDoc({\n    file: markdown,\n    assets: job.assetsManager,\n  });\n  if (!page) {\n    return;\n  }\n  return page.id;\n}\n\n/**\n * Imports a zip file containing Markdown files and assets into a collection.\n * @param options Object containing import options\n * @param options.collection The target doc collection\n * @param options.imported The zip file as a Blob\n * @returns A Promise that resolves to an array of IDs of the newly created docs\n */\nasync function importMarkdownZip({\n  collection,\n  imported,\n}: ImportMarkdownZipOptions) {\n  const unzip = new Unzip();\n  await unzip.load(imported);\n\n  const docIds: string[] = [];\n  const pendingAssets = new Map<string, File>();\n  const pendingPathBlobIdMap = new Map<string, string>();\n  const markdownBlobs: [string, Blob][] = [];\n\n  for (const { path, content: blob } of unzip) {\n    if (path.includes('__MACOSX') || path.includes('.DS_Store')) {\n      continue;\n    }\n\n    const fileName = path.split('/').pop() ?? '';\n    if (fileName.endsWith('.md')) {\n      markdownBlobs.push([fileName, blob]);\n    } else {\n      const ext = path.split('.').at(-1) ?? '';\n      const mime = extMimeMap.get(ext) ?? '';\n      const key = await sha(await blob.arrayBuffer());\n      pendingPathBlobIdMap.set(path, key);\n      pendingAssets.set(key, new File([blob], fileName, { type: mime }));\n    }\n  }\n\n  await Promise.all(\n    markdownBlobs.map(async ([fileName, blob]) => {\n      const fileNameWithoutExt = fileName.replace(/\\.[^/.]+$/, '');\n      const job = new Job({\n        collection,\n        middlewares: [\n          defaultImageProxyMiddleware,\n          fileNameMiddleware(fileNameWithoutExt),\n          docLinkBaseURLMiddleware,\n        ],\n      });\n      const assets = job.assets;\n      const pathBlobIdMap = job.assetsManager.getPathBlobIdMap();\n      for (const [key, value] of pendingAssets.entries()) {\n        assets.set(key, value);\n      }\n      for (const [key, value] of pendingPathBlobIdMap.entries()) {\n        pathBlobIdMap.set(key, value);\n      }\n      const mdAdapter = new MarkdownAdapter(job);\n      const markdown = await blob.text();\n      const doc = await mdAdapter.toDoc({\n        file: markdown,\n        assets: job.assetsManager,\n      });\n      if (doc) {\n        docIds.push(doc.id);\n      }\n    })\n  );\n  return docIds;\n}\n\nexport const MarkdownTransformer = {\n  exportDoc,\n  importMarkdownToBlock,\n  importMarkdownToDoc,\n  importMarkdownZip,\n};\n"]}