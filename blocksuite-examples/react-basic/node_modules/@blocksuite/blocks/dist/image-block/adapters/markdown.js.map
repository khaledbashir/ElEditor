{"version":3,"file":"markdown.js","sourceRoot":"","sources":["../../../src/image-block/adapters/markdown.ts"],"names":[],"mappings":"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","sourcesContent":["import { ImageBlockSchema } from '@blocksuite/affine-model';\nimport {\n  BlockMarkdownAdapterExtension,\n  type BlockMarkdownAdapterMatcher,\n  FetchUtils,\n  type MarkdownAST,\n} from '@blocksuite/affine-shared/adapters';\nimport { getFilenameFromContentDisposition } from '@blocksuite/affine-shared/utils';\nimport { sha } from '@blocksuite/global/utils';\nimport { getAssetName, nanoid } from '@blocksuite/store';\n\nconst isImageNode = (node: MarkdownAST) => node.type === 'image';\n\nexport const imageBlockMarkdownAdapterMatcher: BlockMarkdownAdapterMatcher = {\n  flavour: ImageBlockSchema.model.flavour,\n  toMatch: o => isImageNode(o.node),\n  fromMatch: o => o.node.flavour === ImageBlockSchema.model.flavour,\n  toBlockSnapshot: {\n    enter: async (o, context) => {\n      const { configs, walkerContext, assets } = context;\n      let blobId = '';\n      const imageURL = 'url' in o.node ? o.node.url : '';\n      if (!assets || !imageURL) {\n        return;\n      }\n      if (!FetchUtils.fetchable(imageURL)) {\n        const imageURLSplit = imageURL.split('/');\n        while (imageURLSplit.length > 0) {\n          const key = assets\n            .getPathBlobIdMap()\n            .get(decodeURIComponent(imageURLSplit.join('/')));\n          if (key) {\n            blobId = key;\n            break;\n          }\n          imageURLSplit.shift();\n        }\n      } else {\n        const res = await FetchUtils.fetchImage(\n          imageURL,\n          undefined,\n          configs.get('imageProxy') as string\n        );\n        if (!res) {\n          return;\n        }\n        const clonedRes = res.clone();\n        const file = new File(\n          [await res.blob()],\n          getFilenameFromContentDisposition(\n            res.headers.get('Content-Disposition') ?? ''\n          ) ??\n            (imageURL.split('/').at(-1) ?? 'image') +\n              '.' +\n              (res.headers.get('Content-Type')?.split('/').at(-1) ?? 'png'),\n          {\n            type: res.headers.get('Content-Type') ?? '',\n          }\n        );\n        blobId = await sha(await clonedRes.arrayBuffer());\n        assets?.getAssets().set(blobId, file);\n        await assets?.writeToBlob(blobId);\n      }\n      walkerContext\n        .openNode(\n          {\n            type: 'block',\n            id: nanoid(),\n            flavour: 'affine:image',\n            props: {\n              sourceId: blobId,\n            },\n            children: [],\n          },\n          'children'\n        )\n        .closeNode();\n    },\n  },\n  fromBlockSnapshot: {\n    enter: async (o, context) => {\n      const { assets, walkerContext, updateAssetIds } = context;\n      const blobId = (o.node.props.sourceId ?? '') as string;\n      if (!assets) {\n        return;\n      }\n      await assets.readFromBlob(blobId);\n      const blob = assets.getAssets().get(blobId);\n      if (!blob) {\n        return;\n      }\n      const blobName = getAssetName(assets.getAssets(), blobId);\n      updateAssetIds?.(blobId);\n      walkerContext\n        .openNode(\n          {\n            type: 'paragraph',\n            children: [],\n          },\n          'children'\n        )\n        .openNode(\n          {\n            type: 'image',\n            url: `assets/${blobName}`,\n            title: (o.node.props.caption as string | undefined) ?? null,\n            alt: (blob as File).name ?? null,\n          },\n          'children'\n        )\n        .closeNode()\n        .closeNode();\n    },\n  },\n};\n\nexport const ImageBlockMarkdownAdapterExtension = BlockMarkdownAdapterExtension(\n  imageBlockMarkdownAdapterMatcher\n);\n"]}