{"version":3,"file":"indent-blocks.js","sourceRoot":"","sources":["../../../src/note-block/commands/indent-blocks.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Command } from '@blocksuite/block-std';\n\nimport {\n  calculateCollapsedSiblings,\n  getNearestHeadingBefore,\n  matchFlavours,\n} from '@blocksuite/affine-shared/utils';\n\nexport const indentBlocks: Command<\n  never,\n  never,\n  {\n    blockIds?: string[];\n    stopCapture?: boolean;\n  }\n> = (ctx, next) => {\n  let { blockIds } = ctx;\n  const { std, stopCapture = true } = ctx;\n  const { doc, selection, range, host } = std;\n  const { schema } = doc;\n\n  if (!blockIds || !blockIds.length) {\n    const nativeRange = range.value;\n    if (nativeRange) {\n      const topBlocks = range.getSelectedBlockComponentsByRange(nativeRange, {\n        match: el => el.model.role === 'content',\n        mode: 'highest',\n      });\n      if (topBlocks.length > 0) {\n        blockIds = topBlocks.map(block => block.blockId);\n      }\n    } else {\n      blockIds = std.selection.getGroup('note').map(sel => sel.blockId);\n    }\n  }\n\n  if (!blockIds || !blockIds.length || doc.readonly) return;\n\n  // Find the first model that can be indented\n  let firstIndentIndex = -1;\n  for (let i = 0; i < blockIds.length; i++) {\n    const previousSibling = doc.getPrev(blockIds[i]);\n    const model = doc.getBlock(blockIds[i])?.model;\n    if (\n      model &&\n      previousSibling &&\n      schema.isValid(model.flavour, previousSibling.flavour)\n    ) {\n      firstIndentIndex = i;\n      break;\n    }\n  }\n\n  // No model can be indented\n  if (firstIndentIndex === -1) return;\n\n  if (stopCapture) doc.captureSync();\n\n  const collapsedIds: string[] = [];\n  blockIds.slice(firstIndentIndex).forEach(id => {\n    const model = doc.getBlock(id)?.model;\n    if (!model) return;\n    if (\n      matchFlavours(model, ['affine:paragraph']) &&\n      model.type.startsWith('h') &&\n      model.collapsed\n    ) {\n      const collapsedSiblings = calculateCollapsedSiblings(model);\n      collapsedIds.push(...collapsedSiblings.map(sibling => sibling.id));\n    }\n  });\n  // Models waiting to be indented\n  const indentIds = blockIds\n    .slice(firstIndentIndex)\n    .filter(id => !collapsedIds.includes(id));\n  const firstModel = doc.getBlock(indentIds[0])?.model;\n  if (!firstModel) return;\n\n  {\n    // > # 123\n    // > # 456\n    // > # 789\n    //\n    // we need to update 123 collapsed state to false when indent 456 and 789\n\n    const nearestHeading = getNearestHeadingBefore(firstModel);\n    if (\n      nearestHeading &&\n      matchFlavours(nearestHeading, ['affine:paragraph']) &&\n      nearestHeading.collapsed\n    ) {\n      doc.updateBlock(nearestHeading, {\n        collapsed: false,\n      });\n    }\n  }\n\n  indentIds.forEach(id => {\n    std.command.exec('indentBlock', { blockId: id, stopCapture: false });\n  });\n\n  {\n    // 123\n    //   > # 456\n    // 789\n    // 012\n    //\n    // we need to update 456 collapsed state to false when indent 789 and 012\n    const nearestHeading = getNearestHeadingBefore(firstModel);\n    if (\n      nearestHeading &&\n      matchFlavours(nearestHeading, ['affine:paragraph']) &&\n      nearestHeading.collapsed\n    ) {\n      doc.updateBlock(nearestHeading, {\n        collapsed: false,\n      });\n    }\n  }\n\n  const textSelection = selection.find('text');\n  if (textSelection) {\n    host.updateComplete\n      .then(() => {\n        range.syncTextSelectionToRange(textSelection);\n      })\n      .catch(console.error);\n  }\n\n  return next();\n};\n"]}