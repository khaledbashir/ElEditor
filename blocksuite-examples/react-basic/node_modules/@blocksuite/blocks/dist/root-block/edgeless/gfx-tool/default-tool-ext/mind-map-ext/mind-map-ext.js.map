{"version":3,"file":"mind-map-ext.js","sourceRoot":"","sources":["../../../../../../src/root-block/edgeless/gfx-tool/default-tool-ext/mind-map-ext/mind-map-ext.ts"],"names":[],"mappings":"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","sourcesContent":["import type { PointerEventState } from '@blocksuite/block-std';\nimport type { Bound, IVec } from '@blocksuite/global/utils';\n\nimport {\n  MindmapUtils,\n  NODE_HORIZONTAL_SPACING,\n  NODE_VERTICAL_SPACING,\n  OverlayIdentifier,\n  type SurfaceBlockComponent,\n} from '@blocksuite/affine-block-surface';\nimport {\n  type LayoutType,\n  type LocalConnectorElementModel,\n  MindmapElementModel,\n  type MindmapNode,\n} from '@blocksuite/affine-model';\nimport {\n  type GfxModel,\n  isGfxGroupCompatibleModel,\n} from '@blocksuite/block-std/gfx';\n\nimport type { MindMapIndicatorOverlay } from './indicator-overlay.js';\n\nimport {\n  isMindmapNode,\n  isSingleMindMapNode,\n} from '../../../../../_common/edgeless/mindmap/index.js';\nimport { DefaultModeDragType, DefaultToolExt, type DragState } from '../ext.js';\nimport { calculateResponseArea } from './drag-utils.js';\n\ntype DragMindMapCtx = {\n  mindmap: MindmapElementModel;\n  node: MindmapNode;\n  clear?: () => void;\n  originalMindMapBound: Bound;\n  startPoint: PointerEventState;\n};\n\nexport class MindMapExt extends DefaultToolExt {\n  private _responseAreaUpdated = new Set<MindmapElementModel>();\n\n  override supportedDragTypes: DefaultModeDragType[] = [\n    DefaultModeDragType.ContentMoving,\n  ];\n\n  private get _indicatorOverlay() {\n    return this.std.getOptional(\n      OverlayIdentifier('mindmap-indicator')\n    ) as MindMapIndicatorOverlay | null;\n  }\n\n  private _calcDragResponseArea(mindmap: MindmapElementModel) {\n    calculateResponseArea(mindmap);\n    this._responseAreaUpdated.add(mindmap);\n  }\n\n  /**\n   * Create handlers that can drag and drop mind map nodes\n   * @param dragMindMapCtx\n   * @param dragState\n   * @returns\n   */\n  private _createManipulationHandlers(dragMindMapCtx: DragMindMapCtx): {\n    dragStart?: (evt: PointerEventState) => void;\n    dragMove?: (evt: PointerEventState) => void;\n    dragEnd?: (evt: PointerEventState) => void;\n  } {\n    let hoveredCtx: {\n      mindmap: MindmapElementModel | null;\n      node: MindmapNode | null;\n      detach?: boolean;\n      abort?: () => void;\n      merge?: () => void;\n    } | null = null;\n\n    return {\n      dragMove: (_: PointerEventState) => {\n        const [x, y] = this.defaultTool.dragLastPos;\n        const hoveredMindMap = this._getHoveredMindMap([x, y], dragMindMapCtx);\n        const indicator = this._indicatorOverlay;\n\n        if (indicator) {\n          indicator.currentDragPos = [x, y];\n          indicator.refresh();\n        }\n\n        hoveredCtx?.abort?.();\n\n        const hoveredNode = hoveredMindMap\n          ? MindmapUtils.findTargetNode(hoveredMindMap, [x, y])\n          : null;\n\n        hoveredCtx = {\n          mindmap: hoveredMindMap,\n          node: hoveredNode,\n        };\n\n        // 1. not hovered on any mind map or\n        // 2. hovered on the other mind map but not on any node\n        // then consider user is trying to detach the node\n        if (\n          !hoveredMindMap ||\n          (hoveredMindMap !== dragMindMapCtx.mindmap && !hoveredNode)\n        ) {\n          hoveredCtx.detach = true;\n\n          const reset = (hoveredCtx.abort = MindmapUtils.hideNodeConnector(\n            dragMindMapCtx.mindmap,\n            dragMindMapCtx.node\n          ));\n\n          hoveredCtx.abort = () => {\n            reset?.();\n          };\n        } else {\n          // hovered on the currently dragging mind map but\n          // 1. not hovered on any node or\n          // 2. hovered on the node that is itself or its children (which is not allowed)\n          // then consider user is trying to drop the node to its original position\n          if (\n            !hoveredNode ||\n            MindmapUtils.containsNode(\n              hoveredMindMap,\n              hoveredNode,\n              dragMindMapCtx.node\n            )\n          ) {\n            const { mindmap, node } = dragMindMapCtx;\n\n            // if the node is the root node, then do nothing\n            if (node === mindmap.tree) {\n              return;\n            }\n\n            const nodeBound = node.element.elementBound;\n\n            hoveredCtx.abort = this._drawIndicator({\n              targetMindMap: mindmap,\n              target: node,\n              sourceMindMap: mindmap,\n              source: node,\n              newParent: node.parent!,\n              insertPosition: {\n                type: 'sibling',\n                layoutDir: mindmap.getLayoutDir(node) as Exclude<\n                  LayoutType,\n                  LayoutType.BALANCE\n                >,\n                position: y > nodeBound.y + nodeBound.h / 2 ? 'next' : 'prev',\n              },\n              path: mindmap.getPath(node),\n            });\n          } else {\n            const operation = MindmapUtils.tryMoveNode(\n              hoveredMindMap,\n              hoveredNode,\n              dragMindMapCtx.mindmap,\n              dragMindMapCtx.node,\n              [x, y],\n              options => this._drawIndicator(options)\n            );\n\n            if (operation) {\n              hoveredCtx.abort = operation.abort;\n              hoveredCtx.merge = operation.merge;\n            }\n          }\n        }\n      },\n      dragEnd: (e: PointerEventState) => {\n        if (hoveredCtx?.merge) {\n          hoveredCtx.merge();\n        } else {\n          hoveredCtx?.abort?.();\n\n          if (hoveredCtx?.detach) {\n            const [startX, startY] = this.gfx.viewport.toModelCoord(\n              dragMindMapCtx.startPoint.x,\n              dragMindMapCtx.startPoint.y\n            );\n            const [endX, endY] = this.gfx.viewport.toModelCoord(e.x, e.y);\n\n            dragMindMapCtx.node.element.xywh =\n              dragMindMapCtx.node.element.elementBound\n                .moveDelta(endX - startX, endY - startY)\n                .serialize();\n\n            if (dragMindMapCtx.node !== dragMindMapCtx.mindmap.tree) {\n              MindmapUtils.detachMindmap(\n                dragMindMapCtx.mindmap,\n                dragMindMapCtx.node\n              );\n              const mindmap = MindmapUtils.createFromTree(\n                dragMindMapCtx.node,\n                dragMindMapCtx.mindmap.style,\n                dragMindMapCtx.mindmap.layoutType,\n                this.gfx.surface!\n              );\n\n              mindmap.layout();\n            } else {\n              dragMindMapCtx.mindmap.layout();\n            }\n          }\n        }\n\n        hoveredCtx = null;\n        dragMindMapCtx.clear?.();\n        this._responseAreaUpdated.clear();\n      },\n    };\n  }\n\n  /**\n   * Create handlers that can translate entire mind map\n   */\n  private _createTranslationHandlers(\n    _: DragState,\n    ctx: {\n      mindmaps: Set<MindmapElementModel>;\n      nodes: Set<GfxModel>;\n    }\n  ): {\n    dragStart?: (evt: PointerEventState) => void;\n    dragMove?: (evt: PointerEventState) => void;\n    dragEnd?: (evt: PointerEventState) => void;\n  } {\n    return {\n      dragStart: (_: PointerEventState) => {\n        ctx.nodes.forEach(node => {\n          node.stash('xywh');\n        });\n      },\n      dragEnd: (_: PointerEventState) => {\n        ctx.mindmaps.forEach(mindmap => {\n          mindmap.layout();\n        });\n      },\n    };\n  }\n\n  private _drawIndicator(options: {\n    targetMindMap: MindmapElementModel;\n    target: MindmapNode;\n    sourceMindMap: MindmapElementModel;\n    source: MindmapNode;\n    newParent: MindmapNode;\n    insertPosition:\n      | {\n          type: 'sibling';\n          layoutDir: Exclude<LayoutType, LayoutType.BALANCE>;\n          position: 'prev' | 'next';\n        }\n      | { type: 'child'; layoutDir: Exclude<LayoutType, LayoutType.BALANCE> };\n    path: number[];\n  }) {\n    const indicatorOverlay = this._indicatorOverlay;\n\n    if (!indicatorOverlay) {\n      return () => {};\n    }\n\n    // draw the indicator at given position\n    const { newParent, insertPosition, targetMindMap, target, source, path } =\n      options;\n    const children = newParent.children.filter(\n      node => node.element.id !== source.id\n    );\n\n    indicatorOverlay.setIndicatorInfo({\n      targetMindMap,\n      target,\n      parent: newParent,\n      insertPosition,\n      parentChildren: children,\n      path,\n    });\n\n    return () => {\n      indicatorOverlay.clear();\n    };\n  }\n\n  private _getHoveredMindMap(\n    position: IVec,\n    dragMindMapCtx: DragMindMapCtx\n  ): MindmapElementModel | null {\n    const mindmap =\n      (this.gfx\n        .getElementByPoint(position[0], position[1], {\n          all: true,\n          responsePadding: [NODE_HORIZONTAL_SPACING, NODE_VERTICAL_SPACING * 2],\n        })\n        .find(el => {\n          if (!(el instanceof MindmapElementModel)) {\n            return false;\n          }\n\n          if (\n            el === dragMindMapCtx.mindmap &&\n            !dragMindMapCtx.originalMindMapBound.containsPoint(position)\n          ) {\n            return false;\n          }\n\n          return true;\n        }) as MindmapElementModel) ?? null;\n\n    if (\n      mindmap &&\n      (!this._responseAreaUpdated.has(mindmap) || !mindmap.tree.responseArea)\n    ) {\n      this._calcDragResponseArea(mindmap);\n    }\n\n    return mindmap;\n  }\n\n  private _setupDragNodeImage(\n    mindmapNode: MindmapNode,\n    event: PointerEventState\n  ) {\n    const surfaceBlock = this.gfx.surfaceComponent as SurfaceBlockComponent;\n    const renderer = surfaceBlock?.renderer;\n    const indicatorOverlay = this._indicatorOverlay;\n\n    if (!renderer || !indicatorOverlay) {\n      return;\n    }\n\n    const nodeBound = mindmapNode.element.elementBound;\n\n    const pos = this.gfx.viewport.toModelCoord(event.x, event.y);\n    const canvas = renderer.getCanvasByBound(\n      mindmapNode.element.elementBound,\n      [mindmapNode.element],\n      undefined,\n      undefined,\n      false\n    );\n\n    indicatorOverlay.dragNodePos = [nodeBound.x - pos[0], nodeBound.y - pos[1]];\n    indicatorOverlay.dragNodeImage = canvas;\n\n    return () => {\n      indicatorOverlay.dragNodeImage = null;\n      indicatorOverlay.currentDragPos = null;\n    };\n  }\n\n  private _updateNodeOpacity(\n    mindmap: MindmapElementModel,\n    mindNode: MindmapNode\n  ) {\n    const OPACITY = 0.3;\n    const updatedNodes = new Set<\n      BlockSuite.SurfaceElementModel | LocalConnectorElementModel\n    >();\n    const traverse = (node: MindmapNode, parent: MindmapNode | null) => {\n      node.element.opacity = OPACITY;\n      updatedNodes.add(node.element);\n\n      if (parent) {\n        const connectorId = `#${parent.element.id}-${node.element.id}`;\n        const connector = mindmap.connectors.get(connectorId);\n\n        if (connector) {\n          connector.opacity = OPACITY;\n          updatedNodes.add(connector);\n        }\n      }\n\n      if (node.children.length) {\n        node.children.forEach(child => traverse(child, node));\n      }\n    };\n\n    const parentNode = mindmap.getParentNode(mindNode.element.id) ?? null;\n\n    traverse(mindNode, parentNode);\n\n    return () => {\n      updatedNodes.forEach(el => {\n        el.opacity = 1;\n      });\n    };\n  }\n\n  override initDrag(dragState: DragState) {\n    if (dragState.dragType !== DefaultModeDragType.ContentMoving) {\n      return {};\n    }\n\n    if (isSingleMindMapNode(dragState.movedElements)) {\n      const mindmap = dragState.movedElements[0].group as MindmapElementModel;\n      const mindmapNode = mindmap.getNode(dragState.movedElements[0].id)!;\n      const mindmapBound = mindmap.elementBound;\n\n      dragState.movedElements.splice(0, 1);\n\n      mindmapBound.x -= NODE_HORIZONTAL_SPACING;\n      mindmapBound.y -= NODE_VERTICAL_SPACING * 2;\n      mindmapBound.w += NODE_HORIZONTAL_SPACING * 2;\n      mindmapBound.h += NODE_VERTICAL_SPACING * 4;\n\n      this._calcDragResponseArea(mindmap);\n\n      const clearDragImage = this._setupDragNodeImage(\n        mindmapNode,\n        dragState.event\n      );\n      const clearOpacity = this._updateNodeOpacity(mindmap, mindmapNode);\n\n      const mindMapDragCtx: DragMindMapCtx = {\n        mindmap,\n        node: mindmapNode,\n        clear: () => {\n          clearOpacity();\n          clearDragImage?.();\n          dragState.movedElements.push(mindmapNode.element);\n        },\n        originalMindMapBound: mindmapBound,\n        startPoint: dragState.event,\n      };\n\n      return this._createManipulationHandlers(mindMapDragCtx);\n    }\n\n    const mindmapNodes = new Set<GfxModel>();\n    const mindmaps = new Set<MindmapElementModel>();\n    dragState.movedElements.forEach(el => {\n      if (isMindmapNode(el)) {\n        const mindmap =\n          el.group instanceof MindmapElementModel\n            ? el.group\n            : (el as MindmapElementModel);\n\n        mindmaps.add(mindmap);\n        mindmap.childElements.forEach(child => mindmapNodes.add(child));\n      } else if (isGfxGroupCompatibleModel(el)) {\n        el.descendantElements.forEach(desc => {\n          if (desc.group instanceof MindmapElementModel) {\n            mindmaps.add(desc.group);\n            desc.group.childElements.forEach(_el => mindmapNodes.add(_el));\n          }\n        });\n      }\n    });\n\n    if (mindmapNodes.size > 1) {\n      mindmapNodes.forEach(node => dragState.movedElements.push(node));\n      return this._createTranslationHandlers(dragState, {\n        mindmaps,\n        nodes: mindmapNodes,\n      });\n    }\n\n    return {};\n  }\n}\n"]}