export function isFixed(node, computedStyle = window.getComputedStyle(node)) {
    return computedStyle.position === 'fixed';
}
export function isScrollable(element, computedStyle = window.getComputedStyle(element)) {
    const overflowRegex = /(auto|scroll|overlay)/;
    const properties = ['overflow', 'overflowX', 'overflowY'];
    return properties.some(property => {
        const value = computedStyle[property];
        return typeof value === 'string' ? overflowRegex.test(value) : false;
    });
}
export function getScrollableAncestors(element, limit) {
    const scrollParents = [];
    if (!element) {
        return scrollParents;
    }
    let currentNode = element;
    while (currentNode) {
        if (limit != null && scrollParents.length >= limit) {
            break;
        }
        if (!(currentNode instanceof HTMLElement)) {
            break;
        }
        const computedStyle = window.getComputedStyle(currentNode);
        if (currentNode !== element) {
            if (isScrollable(currentNode, computedStyle)) {
                scrollParents.push(currentNode);
            }
        }
        if (isFixed(currentNode, computedStyle)) {
            break;
        }
        currentNode = currentNode.parentNode;
    }
    return scrollParents;
}
export function getFirstScrollableAncestor(node) {
    const [firstScrollableAncestor] = getScrollableAncestors(node, 1);
    return firstScrollableAncestor ?? null;
}
//# sourceMappingURL=get-scrollable-ancestors.js.map