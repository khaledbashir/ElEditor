import type { Activators, Active, CollisionDetection, Coordinates, DndClientRect, DragCancelEvent, DragEndEvent, DragMoveEvent, DragOverEvent, DragStartEvent, Modifiers, Over } from './types.js';
export interface OverlayData {
    overlay: HTMLElement;
    cleanup?: () => void;
}
export type DndContextConfig = {
    container: HTMLElement;
    collisionDetection?: CollisionDetection;
    modifiers?: Modifiers;
    activators: Activators;
    onDragStart?(event: DragStartEvent): void;
    onDragMove?(event: DragMoveEvent): void;
    onDragOver?(event: DragOverEvent): void;
    onDragEnd?(event: DragEndEvent): void;
    onDragCancel?(event: DragCancelEvent): void;
    createOverlay?: (active: Active) => OverlayData | undefined;
};
export declare class DndContext {
    protected config: DndContextConfig;
    private dragMove;
    private droppableNodes$;
    private initialCoordinates$;
    private initScrollOffset$;
    private session$;
    private startSession;
    activationCoordinates$: import("@preact/signals-core").Signal<Coordinates | undefined>;
    private translate$;
    active$: import("@preact/signals-core").Signal<Active | undefined>;
    initActiveRect$: import("@preact/signals-core").Signal<DndClientRect | undefined>;
    activeNodeRectDelta$: import("@preact/signals-core").ReadonlySignal<Coordinates>;
    collisionRect$: import("@preact/signals-core").ReadonlySignal<{
        top: number;
        bottom: number;
        left: number;
        right: number;
        width: number;
        height: number;
    } | undefined>;
    enabledDroppableContainers$: import("@preact/signals-core").ReadonlySignal<import("./types.js").DroppableContainer[]>;
    droppableRects$: import("@preact/signals-core").ReadonlySignal<Map<string, DndClientRect>>;
    collisions$: import("@preact/signals-core").ReadonlySignal<import("./types.js").Collision[] | undefined>;
    overId$: import("@preact/signals-core").ReadonlySignal<string | undefined>;
    over$: import("@preact/signals-core").ReadonlySignal<Over | undefined> & {
        preValue: Over | undefined;
    };
    overlay$: import("@preact/signals-core").Signal<{
        node: HTMLElement;
        rect: DndClientRect;
    } | undefined>;
    scrollableAncestor$: import("@preact/signals-core").ReadonlySignal<{
        node: Element;
        rect: {
            top: number;
            left: number;
            width: number;
            height: number;
            bottom: number;
            right: number;
        };
        max: {
            x: number;
            y: number;
        };
    } | undefined>;
    modifiedTranslate$: import("@preact/signals-core").ReadonlySignal<Coordinates>;
    scrollOffset$: import("@preact/signals-core").Signal<Coordinates>;
    appliedTranslate$: import("@preact/signals-core").ReadonlySignal<Coordinates>;
    disposables: Array<() => void>;
    dragEndCleanupQueue: Array<() => void>;
    scale$: import("@preact/signals-core").Signal<{
        x: number;
        y: number;
    }>;
    scrollAdjustedTranslate$: import("@preact/signals-core").ReadonlySignal<Coordinates>;
    transform$: import("@preact/signals-core").ReadonlySignal<Coordinates>;
    get activators(): Activators;
    get collisionDetection(): CollisionDetection;
    get container(): HTMLElement;
    constructor(config: DndContextConfig);
    private addActiveClass;
    private addTransition;
    private autoScroll;
    private collectDroppableNodes;
    private createOverlay;
    private dragComplete;
    private dragEndCleanup;
    private dragStart;
    private getDroppableNode;
    private listenActivators;
    private listenMoveEvent;
    private listenOverEvent;
    private listenScroll;
    private onScroll;
    private setPointerEvents;
}
export declare const createDndContext: (config: DndContextConfig) => DndContext;
export declare const draggableDataName: {
    dataset: string;
    attribute: string;
};
export declare const draggable: (values_0: string) => import("lit-html/directive.js").DirectiveResult<{
    new (partInfo: import("lit-html/directive.js").PartInfo): {
        render(_ids_0: string): unknown;
        update(part: import("lit-html").AttributePart, ids: string[]): unknown;
        readonly _$isConnected: boolean;
    };
}>;
export declare const dragHandlerDataName: {
    dataset: string;
    attribute: string;
};
export declare const dragHandler: (values_0: string) => import("lit-html/directive.js").DirectiveResult<{
    new (partInfo: import("lit-html/directive.js").PartInfo): {
        render(_ids_0: string): unknown;
        update(part: import("lit-html").AttributePart, ids: string[]): unknown;
        readonly _$isConnected: boolean;
    };
}>;
export declare const droppableDataName: {
    dataset: string;
    attribute: string;
};
export declare const droppable: (values_0: string) => import("lit-html/directive.js").DirectiveResult<{
    new (partInfo: import("lit-html/directive.js").PartInfo): {
        render(_ids_0: string): unknown;
        update(part: import("lit-html").AttributePart, ids: string[]): unknown;
        readonly _$isConnected: boolean;
    };
}>;
//# sourceMappingURL=dnd-context.d.ts.map