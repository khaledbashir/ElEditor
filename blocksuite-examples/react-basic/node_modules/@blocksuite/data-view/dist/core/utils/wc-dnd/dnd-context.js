import { computed, effect, signal } from '@preact/signals-core';
import { add } from './utils/adjustment.js';
import { applyModifiers } from './utils/apply-modifiers.js';
import { closestCenter } from './utils/closest-center.js';
import { createDataDirective } from './utils/data-directive.js';
import { asHTMLElement } from './utils/element.js';
import { getFirstScrollableAncestor } from './utils/get-scrollable-ancestors.js';
import { raf } from './utils/raf.js';
import { getClientRect } from './utils/rect.js';
import { getAdjustedRect } from './utils/rect-adjustment.js';
import { computedCache } from './utils/signal.js';
const timeWeight = 1 / 16;
const distanceWeight = 2 / 8;
const moveDistance = (diff, delta) => (diff * distanceWeight + (diff / Math.abs(diff)) * 2) * delta * timeWeight;
const defaultCoordinates = {
    x: 0,
    y: 0,
};
export class DndContext {
    get activators() {
        return this.config.activators;
    }
    get collisionDetection() {
        return this.config.collisionDetection ?? closestCenter;
    }
    get container() {
        return this.config.container;
    }
    constructor(config) {
        this.config = config;
        this.dragMove = (coordinates) => {
            this.activationCoordinates$.value = coordinates;
            this.autoScroll();
        };
        this.droppableNodes$ = signal(new Map());
        this.initialCoordinates$ = signal();
        this.initScrollOffset$ = signal(defaultCoordinates);
        this.session$ = signal();
        this.startSession = (id, activeNode, sessionCreator) => {
            this.collectDroppableNodes();
            this.session$.value = sessionCreator({
                onStart: coordinates => {
                    const { onDragStart } = this.config;
                    const active = {
                        id,
                        node: activeNode,
                        rect: getClientRect(activeNode),
                    };
                    onDragStart?.({
                        active: active,
                    });
                    this.dragStart(active, coordinates);
                },
                onCancel: this.dragComplete(true),
                onEnd: this.dragComplete(),
                onMove: this.dragMove,
            });
        };
        this.activationCoordinates$ = signal();
        this.translate$ = computed(() => {
            const init = this.initialCoordinates$.value;
            const current = this.activationCoordinates$.value;
            if (!init || !current) {
                return defaultCoordinates;
            }
            return {
                x: current.x - init.x,
                y: current.y - init.y,
            };
        });
        this.active$ = signal();
        this.initActiveRect$ = signal();
        this.activeNodeRectDelta$ = computed(() => {
            const initCoord = this.initialCoordinates$.value;
            const initNodeRect = this.initActiveRect$.value;
            if (!initNodeRect || !initCoord) {
                return defaultCoordinates;
            }
            return {
                x: initCoord.x - initNodeRect.left,
                y: initCoord.y - initNodeRect.top,
            };
        });
        this.collisionRect$ = computed(() => {
            return this.active$.value?.rect
                ? getAdjustedRect(this.active$.value.rect, this.appliedTranslate$.value)
                : undefined;
        });
        this.enabledDroppableContainers$ = computed(() => {
            return [...this.droppableNodes$.value.values()].filter(node => !node.disabled);
        });
        this.droppableRects$ = computed(() => {
            const map = new Map();
            this.enabledDroppableContainers$.value.forEach(container => {
                const element = container.node;
                if (element) {
                    map.set(container.id, container.rect);
                }
            });
            return map;
        });
        this.collisions$ = computed(() => {
            return this.active$.value && this.collisionRect$.value
                ? this.collisionDetection({
                    active: this.active$.value,
                    collisionRect: this.collisionRect$.value,
                    droppableRects: this.droppableRects$.value,
                    droppableContainers: this.enabledDroppableContainers$.value,
                    pointerCoordinates: this.activationCoordinates$.value,
                })
                : undefined;
        });
        this.overId$ = computed(() => {
            return this.collisions$.value?.[0]?.id;
        });
        this.over$ = computedCache(() => {
            const active = this.active$.value;
            if (!active) {
                return;
            }
            const id = this.overId$.value;
            const overContainer = this.getDroppableNode(id);
            return overContainer && overContainer.rect
                ? {
                    id: overContainer.id,
                    rect: overContainer.rect,
                    disabled: overContainer.disabled,
                }
                : undefined;
        });
        this.overlay$ = signal();
        this.scrollableAncestor$ = computed(() => {
            if (!this.active$.value) {
                return;
            }
            const scrollableAncestor = getFirstScrollableAncestor(this.active$.value.node);
            if (!scrollableAncestor) {
                return;
            }
            return {
                node: scrollableAncestor,
                rect: getClientRect(scrollableAncestor),
                max: {
                    x: scrollableAncestor.scrollWidth - scrollableAncestor.clientWidth,
                    y: scrollableAncestor.scrollHeight - scrollableAncestor.clientHeight,
                },
            };
        });
        this.modifiedTranslate$ = computed(() => {
            if (!this.active$.value) {
                return defaultCoordinates;
            }
            return applyModifiers(this.config.modifiers, {
                transform: {
                    x: this.translate$.value.x - this.activeNodeRectDelta$.value.x,
                    y: this.translate$.value.y - this.activeNodeRectDelta$.value.y,
                    scaleX: 1,
                    scaleY: 1,
                },
                active: this.active$.value,
                activeNodeRect: this.active$.value.rect,
                over: this.over$.preValue,
                scrollContainerRect: this.scrollableAncestor$.value?.rect,
                overlayNodeRect: this.overlay$.value?.rect,
            });
        });
        this.scrollOffset$ = signal(defaultCoordinates);
        // eslint-disable-next-line perfectionist/sort-classes
        this.appliedTranslate$ = computed(() => {
            return add(this.modifiedTranslate$.value, this.scrollOffset$.value);
        });
        this.disposables = [];
        this.dragEndCleanupQueue = [];
        this.scale$ = signal({ x: 1, y: 1 });
        this.scrollAdjustedTranslate$ = computed(() => {
            const translate = this.translate$.value;
            const scrollOffset = this.scrollOffset$.value;
            return add(translate, scrollOffset);
        });
        this.transform$ = computed(() => {
            return this.appliedTranslate$.value;
        });
        this.listenActivators();
        this.listenMoveEvent();
        this.listenOverEvent();
    }
    addActiveClass(node) {
        const hasClass = node.classList.contains('dnd-active');
        if (hasClass) {
            return;
        }
        node.classList.add('dnd-active');
        this.dragEndCleanupQueue.push(() => {
            node.classList.remove('dnd-active');
        });
    }
    addTransition(node) {
        const old = node.style.transition;
        node.style.transition = 'transform 0.2s';
        this.dragEndCleanupQueue.push(() => {
            node.style.transition = old;
        });
    }
    autoScroll() {
        const currentOverlayRect = this.overlay$.value
            ? getClientRect(this.overlay$.value.node)
            : {
                top: this.activationCoordinates$.value?.y ?? 0,
                left: this.activationCoordinates$.value?.x ?? 0,
                width: 0,
                height: 0,
                bottom: this.activationCoordinates$.value?.y ?? 0,
                right: this.activationCoordinates$.value?.x ?? 0,
            };
        const scrollableAncestor = this.scrollableAncestor$.value;
        if (!scrollableAncestor) {
            return;
        }
        const { node, rect, max } = scrollableAncestor;
        let topDiff = 0;
        let leftDiff = 0;
        if (currentOverlayRect.top < rect.top) {
            topDiff = currentOverlayRect.top - rect.top;
        }
        if (currentOverlayRect.left < rect.left) {
            leftDiff = currentOverlayRect.left - rect.left;
        }
        if (currentOverlayRect.bottom > rect.bottom) {
            topDiff = currentOverlayRect.bottom - rect.bottom;
        }
        if (currentOverlayRect.right > rect.right) {
            leftDiff = currentOverlayRect.right - rect.right;
        }
        if (topDiff || leftDiff) {
            const run = (delta) => {
                if (leftDiff) {
                    const newScrollLeft = node.scrollLeft + moveDistance(leftDiff, delta);
                    if (newScrollLeft < 0) {
                        node.scrollLeft = 0;
                    }
                    else if (newScrollLeft > max.x) {
                        node.scrollLeft = max.x;
                    }
                    else {
                        node.scrollLeft = newScrollLeft;
                    }
                }
                if (topDiff) {
                    const newScrollTop = node.scrollTop + moveDistance(topDiff, delta);
                    if (newScrollTop < 0) {
                        node.scrollTop = 0;
                    }
                    else if (newScrollTop > max.y) {
                        node.scrollTop = max.y;
                    }
                    else {
                        node.scrollTop = newScrollTop;
                    }
                }
                this.onScroll(node.scrollLeft, node.scrollTop);
                raf(run);
            };
            raf(run);
        }
        else {
            raf();
        }
    }
    collectDroppableNodes() {
        const map = new Map();
        const droppableNodes = this.container.querySelectorAll(`[${droppableDataName.attribute}]`);
        droppableNodes.forEach(node => {
            const ele = asHTMLElement(node);
            const id = ele?.dataset[droppableDataName.dataset];
            if (id) {
                map.set(id, {
                    id,
                    disabled: false,
                    node: ele,
                    rect: getClientRect(ele),
                });
            }
        });
        this.droppableNodes$.value = map;
    }
    createOverlay(active) {
        const overlay = this.config.createOverlay?.(active);
        if (!overlay) {
            return;
        }
        this.overlay$.value = {
            node: overlay.overlay,
            rect: getClientRect(overlay.overlay),
        };
        this.dragEndCleanupQueue.push(() => {
            overlay.cleanup?.();
        });
    }
    dragComplete(cancel = false) {
        return () => {
            let event = null;
            const active = this.active$.peek();
            if (active && this.modifiedTranslate$.value) {
                event = {
                    active: active,
                    collisions: this.collisions$.peek(),
                    delta: this.modifiedTranslate$.peek(),
                    over: this.over$.peek(),
                };
            }
            this.dragEndCleanup();
            if (event) {
                this.config[cancel ? 'onDragCancel' : 'onDragEnd']?.(event);
            }
        };
    }
    dragEndCleanup() {
        this.active$.value?.node.classList?.remove('dnd-active');
        this.activationCoordinates$.value = undefined;
        this.active$.value = undefined;
        this.session$.value = undefined;
        raf();
        this.dragEndCleanupQueue.forEach(f => f());
    }
    dragStart(active, coordinates) {
        this.active$.value = active;
        this.initialCoordinates$.value = coordinates;
        this.scale$.value = {
            x: active.rect.width / active.node.offsetWidth,
            y: active.rect.height / active.node.offsetHeight,
        };
        this.createOverlay(active);
        this.listenScroll();
        this.addActiveClass(active.node);
        this.setPointerEvents(this.config.container);
        this.droppableNodes$.value.forEach(v => {
            this.addTransition(v.node);
        });
    }
    getDroppableNode(id) {
        if (id == null) {
            return;
        }
        return this.droppableNodes$.value.get(id);
    }
    listenActivators() {
        const unsubList = this.activators.map(activator => {
            return activator(this.container, this.startSession);
        });
        this.disposables.push(() => {
            unsubList.forEach(unsub => {
                unsub();
            });
        });
    }
    listenMoveEvent() {
        this.disposables.push(effect(() => {
            const active = this.active$.value;
            if (!active) {
                return;
            }
            const translate = this.modifiedTranslate$.value;
            this.config.onDragMove?.({
                active,
                collisions: this.collisions$.value,
                delta: {
                    x: translate.x,
                    y: translate.y,
                },
                over: this.over$.value,
            });
            if (this.overlay$.value) {
                const transform = this.transform$.value;
                const scale = this.scale$.value;
                this.overlay$.value.node.style.transform = `translate(${transform.x / scale.x}px,${transform.y / scale.y}px)`;
            }
        }));
    }
    listenOverEvent() {
        this.disposables.push(effect(() => {
            if (!this.active$.value) {
                return;
            }
            this.config.onDragOver?.({
                active: this.active$.value,
                collisions: this.collisions$.peek(),
                delta: {
                    x: this.modifiedTranslate$.peek().x,
                    y: this.modifiedTranslate$.peek().y,
                },
                over: this.over$.value,
            });
        }));
    }
    listenScroll() {
        const scrollAncestor = this.scrollableAncestor$.value?.node;
        if (!scrollAncestor) {
            return;
        }
        this.initScrollOffset$.value = {
            x: scrollAncestor.scrollLeft,
            y: scrollAncestor.scrollTop,
        };
        this.scrollOffset$.value = defaultCoordinates;
        const onScroll = () => {
            this.onScroll(scrollAncestor.scrollLeft, scrollAncestor.scrollTop);
        };
        scrollAncestor.addEventListener('scroll', onScroll);
        this.dragEndCleanupQueue.push(() => {
            scrollAncestor.removeEventListener('scroll', onScroll);
        });
    }
    onScroll(x, y) {
        this.scrollOffset$.value = {
            x: (x - this.initScrollOffset$.value.x) * this.scale$.value.x,
            y: (y - this.initScrollOffset$.value.y) * this.scale$.value.y,
        };
    }
    setPointerEvents(container) {
        const old = container.style.pointerEvents;
        container.style.pointerEvents = 'none';
        this.dragEndCleanupQueue.push(() => {
            container.style.pointerEvents = old;
        });
    }
}
export const createDndContext = (config) => {
    return new DndContext(config);
};
export const draggableDataName = {
    dataset: 'wcDndDraggableId',
    attribute: 'data-wc-dnd-draggable-id',
};
export const draggable = createDataDirective(draggableDataName);
export const dragHandlerDataName = {
    dataset: 'wcDndDragHandlerId',
    attribute: 'data-wc-dnd-drag-handler-id',
};
export const dragHandler = createDataDirective(dragHandlerDataName);
export const droppableDataName = {
    dataset: 'wcDndDroppableId',
    attribute: 'data-wc-dnd-droppable-id',
};
export const droppable = createDataDirective(droppableDataName);
//# sourceMappingURL=dnd-context.js.map