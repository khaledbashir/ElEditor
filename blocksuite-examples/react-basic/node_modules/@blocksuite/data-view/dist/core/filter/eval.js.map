{"version":3,"file":"eval.js","sourceRoot":"","sources":["../../../src/core/filter/eval.ts"],"names":[],"mappings":"AAGA,OAAO,EAAE,aAAa,EAAE,MAAM,wBAAwB,CAAC;AAEvD,MAAM,OAAO,GAAG,CAAC,GAAgB,EAAE,GAA4B,EAAW,EAAE;IAC1E,OAAO,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;AACvB,CAAC,CAAC;AAEF,MAAM,SAAS,GAAG,CAAC,KAAa,EAAW,EAAE;IAC3C,OAAO,KAAK,EAAE,KAAK,CAAC;AACtB,CAAC,CAAC;AACF,MAAM,CAAC,MAAM,UAAU,GAAG,CACxB,WAAmB,EACnB,GAA4B,EACnB,EAAE;IACX,MAAM,KAAK,GAAG,CAAC,MAAc,EAAW,EAAE;QACxC,IAAI,MAAM,CAAC,IAAI,KAAK,QAAQ,EAAE,CAAC;YAC7B,MAAM,KAAK,GAAG,OAAO,CAAC,MAAM,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;YACxC,MAAM,IAAI,GAAG,aAAa,CAAC,eAAe,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;YAC5D,IAAI,CAAC,IAAI,EAAE,CAAC;gBACV,OAAO,IAAI,CAAC;YACd,CAAC;YACD,MAAM,YAAY,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC;YACtC,MAAM,IAAI,GAAc,EAAE,CAAC;YAC3B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,YAAY,EAAE,CAAC,EAAE,EAAE,CAAC;gBACtC,MAAM,QAAQ,GAAG,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;gBAC3C,MAAM,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;gBAC7B,IAAI,QAAQ,IAAI,IAAI,EAAE,CAAC;oBACrB,OAAO,IAAI,CAAC;gBACd,CAAC;gBACD,IAAI,CAAC,OAAO,CAAC,aAAa,CAAC,QAAQ,CAAC,EAAE,CAAC;oBACrC,OAAO,IAAI,CAAC;gBACd,CAAC;gBACD,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YACtB,CAAC;YACD,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;YACvB,IAAI,CAAC;gBACH,OAAO,IAAI,CAAC,KAAK,IAAI,SAAS,EAAE,GAAG,IAAI,CAAC,CAAC;YAC3C,CAAC;YAAC,OAAO,CAAC,EAAE,CAAC;gBACX,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;gBACjB,OAAO,IAAI,CAAC;YACd,CAAC;QACH,CAAC;aAAM,IAAI,MAAM,CAAC,IAAI,KAAK,OAAO,EAAE,CAAC;YACnC,IAAI,MAAM,CAAC,EAAE,KAAK,KAAK,EAAE,CAAC;gBACxB,OAAO,MAAM,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;YAChD,CAAC;iBAAM,IAAI,MAAM,CAAC,EAAE,KAAK,IAAI,EAAE,CAAC;gBAC9B,OAAO,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;YAC/C,CAAC;QACH,CAAC;QACD,OAAO,IAAI,CAAC;IACd,CAAC,CAAC;IACF,OAAO,KAAK,CAAC,WAAW,CAAC,CAAC;AAC5B,CAAC,CAAC","sourcesContent":["import type { Value, VariableRef } from '../expression/types.js';\nimport type { Filter } from './types.js';\n\nimport { filterMatcher } from './filter-fn/matcher.js';\n\nconst evalRef = (ref: VariableRef, row: Record<string, unknown>): unknown => {\n  return row[ref.name];\n};\n\nconst evalValue = (value?: Value): unknown => {\n  return value?.value;\n};\nexport const evalFilter = (\n  filterGroup: Filter,\n  row: Record<string, unknown>\n): boolean => {\n  const evalF = (filter: Filter): boolean => {\n    if (filter.type === 'filter') {\n      const value = evalRef(filter.left, row);\n      const func = filterMatcher.getFilterByName(filter.function);\n      if (!func) {\n        return true;\n      }\n      const expectArgLen = func.args.length;\n      const args: unknown[] = [];\n      for (let i = 0; i < expectArgLen; i++) {\n        const argValue = evalValue(filter.args[i]);\n        const argType = func.args[i];\n        if (argValue == null) {\n          return true;\n        }\n        if (!argType.valueValidate(argValue)) {\n          return true;\n        }\n        args.push(argValue);\n      }\n      const impl = func.impl;\n      try {\n        return impl(value ?? undefined, ...args);\n      } catch (e) {\n        console.error(e);\n        return true;\n      }\n    } else if (filter.type === 'group') {\n      if (filter.op === 'and') {\n        return filter.conditions.every(f => evalF(f));\n      } else if (filter.op === 'or') {\n        return filter.conditions.some(f => evalF(f));\n      }\n    }\n    return true;\n  };\n  return evalF(filterGroup);\n};\n"]}