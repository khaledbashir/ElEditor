import { converts } from './type-presets.js';
import { tv, } from './type-variable.js';
const setMap2 = (map2, key1, key2, value) => {
    let map = map2.get(key1);
    if (!map) {
        map2.set(key1, (map = new Map()));
    }
    map.set(key2, value);
    return map;
};
const getMap2 = (map2, key1, key2) => {
    return map2.get(key1)?.get(key2);
};
export class TypeSystem {
    constructor(converts) {
        this._unify = (ctx, left, right) => {
            if (left == null)
                return true;
            if (right == null)
                return false;
            if (tv.typeVarReference.is(left)) {
                return this.unifyReference(ctx, left, right);
            }
            if (tv.typeVarReference.is(right)) {
                return this.unifyReference(ctx, right, left, false);
            }
            return this.unifyNormalType(ctx, left, right);
        };
        this.convertMapFromTo = new Map();
        this.convertMapToFrom = new Map();
        this.unify = (left, right) => {
            return this._unify({}, left, right);
        };
        converts.forEach(config => {
            this.registerConvert(config.from, config.to, config.convert);
        });
    }
    registerConvert(from, to, convert, level = 0) {
        const currentConfig = getMap2(this.convertMapFromTo, from.name, to.name);
        if (currentConfig && currentConfig.level <= level) {
            return;
        }
        const config = {
            level,
            from,
            to,
            convert,
        };
        setMap2(this.convertMapFromTo, from.name, to.name, config);
        setMap2(this.convertMapToFrom, to.name, from.name, config);
        this.convertMapToFrom.get(from.name)?.forEach(config => {
            this.registerConvert(config.from, to, value => convert(config.convert(value)));
        });
    }
    unifyNormalType(ctx, left, right, covariance = true) {
        if (!left || !right) {
            return false;
        }
        if (left.name !== right.name) {
            [left, right] = covariance ? [left, right] : [right, left];
            const convertConfig = this.convertMapFromTo
                .get(left.name)
                ?.get(right.name);
            if (convertConfig == null) {
                return false;
            }
            left = convertConfig.to;
        }
        return left.unify(ctx, right, this._unify);
    }
    unifyReference(ctx, left, right, covariance = true) {
        if (!right) {
            return false;
        }
        let leftDefine = ctx[left.varName];
        if (!leftDefine) {
            ctx[left.varName] = leftDefine = {
                define: tv.typeVarDefine.create(left.varName),
            };
        }
        const leftType = leftDefine.type;
        if (tv.typeVarReference.is(right)) {
            return this.unifyReference(ctx, right, leftType, !covariance);
        }
        if (!leftType) {
            leftDefine.type = right;
            return true;
        }
        return this.unifyNormalType(ctx, leftType, right, covariance);
    }
    instanceFn(template, realArgs, realRt, ctx) {
        const newCtx = {
            ...ctx,
        };
        template.vars.forEach(v => {
            newCtx[v.varName] = {
                define: v,
            };
        });
        for (let i = 0; i < template.args.length; i++) {
            const arg = template.args[i];
            const realArg = realArgs[i];
            if (arg == null) {
                return;
            }
            if (realArg != null) {
                if (!this._unify(newCtx, realArg, arg)) {
                    console.log('arg', realArg, arg);
                    return;
                }
            }
        }
        this._unify(newCtx, template.rt, realRt);
        return template.subst(newCtx);
    }
}
export const typeSystem = new TypeSystem(converts);
//# sourceMappingURL=type-system.js.map