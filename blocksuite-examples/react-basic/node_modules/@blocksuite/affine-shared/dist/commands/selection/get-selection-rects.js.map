{"version":3,"file":"get-selection-rects.js","sourceRoot":"","sources":["../../../src/commands/selection/get-selection-rects.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  BlockSelection,\n  Command,\n  TextSelection,\n} from '@blocksuite/block-std';\n\nimport { getViewportElement } from '../../utils/index.js';\n\nexport interface SelectionRect {\n  width: number;\n  height: number;\n  top: number;\n  left: number;\n\n  /**\n   * The block id that the rect is in. Only available for block selections.\n   */\n  blockId?: string;\n}\n\nexport const getSelectionRectsCommand: Command<\n  'currentTextSelection' | 'currentBlockSelections',\n  'selectionRects',\n  {\n    textSelection?: TextSelection;\n    blockSelections?: BlockSelection[];\n  }\n> = (ctx, next) => {\n  let textSelection;\n  let blockSelections;\n\n  // priority parameters\n  if (ctx.textSelection) {\n    textSelection = ctx.textSelection;\n  } else if (ctx.blockSelections) {\n    blockSelections = ctx.blockSelections;\n  } else if (ctx.currentTextSelection) {\n    textSelection = ctx.currentTextSelection;\n  } else if (ctx.currentBlockSelections) {\n    blockSelections = ctx.currentBlockSelections;\n  } else {\n    console.error(\n      'No selection provided, may forgot to call getTextSelection or getBlockSelections or provide the selection directly.'\n    );\n    return;\n  }\n\n  const { std } = ctx;\n\n  const container = getViewportElement(std.host);\n  const containerRect = container?.getBoundingClientRect();\n\n  if (textSelection) {\n    const range = std.range.textSelectionToRange(textSelection);\n\n    if (range) {\n      const nativeRects = Array.from(range.getClientRects());\n      const rectsWithoutFiltered = nativeRects\n        .map(rect => ({\n          width: rect.right - rect.left,\n          height: rect.bottom - rect.top,\n          top:\n            rect.top - (containerRect?.top ?? 0) + (container?.scrollTop ?? 0),\n          left:\n            rect.left -\n            (containerRect?.left ?? 0) +\n            (container?.scrollLeft ?? 0),\n        }))\n        .filter(rect => rect.width > 0 && rect.height > 0);\n\n      return next({\n        selectionRects: filterCoveringRects(rectsWithoutFiltered),\n      });\n    }\n  } else if (blockSelections && blockSelections.length > 0) {\n    const result = blockSelections\n      .map(blockSelection => {\n        const block = std.view.getBlock(blockSelection.blockId);\n        if (!block) return;\n\n        const rect = block.getBoundingClientRect();\n\n        return {\n          width: rect.width,\n          height: rect.height,\n          top:\n            rect.top - (containerRect?.top ?? 0) + (container?.scrollTop ?? 0),\n          left:\n            rect.left -\n            (containerRect?.left ?? 0) +\n            (container?.scrollLeft ?? 0),\n          blockId: blockSelection.blockId,\n        };\n      })\n      .filter(rect => !!rect);\n\n    return next({ selectionRects: result });\n  }\n\n  return;\n};\n\ndeclare global {\n  namespace BlockSuite {\n    interface CommandContext {\n      selectionRects?: SelectionRect[];\n    }\n\n    interface Commands {\n      /**\n       * Get the selection rects of the current selection or given selections.\n       *\n       * @chain may be `getTextSelection`, `getBlockSelections`, or nothing.\n       * @param textSelection The provided text selection.\n       * @param blockSelections The provided block selections. If `textSelection` is provided, this will be ignored.\n       * @returns The selection rects.\n       */\n      getSelectionRects: typeof getSelectionRectsCommand;\n    }\n  }\n}\n\nfunction covers(rect1: SelectionRect, rect2: SelectionRect): boolean {\n  return (\n    rect1.left <= rect2.left &&\n    rect1.top <= rect2.top &&\n    rect1.left + rect1.width >= rect2.left + rect2.width &&\n    rect1.top + rect1.height >= rect2.top + rect2.height\n  );\n}\n\nfunction intersects(rect1: SelectionRect, rect2: SelectionRect): boolean {\n  return (\n    rect1.left <= rect2.left + rect2.width &&\n    rect1.left + rect1.width >= rect2.left &&\n    rect1.top <= rect2.top + rect2.height &&\n    rect1.top + rect1.height >= rect2.top\n  );\n}\n\nfunction merge(rect1: SelectionRect, rect2: SelectionRect): SelectionRect {\n  const left = Math.min(rect1.left, rect2.left);\n  const top = Math.min(rect1.top, rect2.top);\n  const right = Math.max(rect1.left + rect1.width, rect2.left + rect2.width);\n  const bottom = Math.max(rect1.top + rect1.height, rect2.top + rect2.height);\n\n  return {\n    width: right - left,\n    height: bottom - top,\n    top,\n    left,\n  };\n}\n\nexport function filterCoveringRects(rects: SelectionRect[]): SelectionRect[] {\n  let mergedRects: SelectionRect[] = [];\n  let hasChanges: boolean;\n\n  do {\n    hasChanges = false;\n    const newMergedRects: SelectionRect[] = [...mergedRects];\n\n    for (const rect of rects) {\n      let merged = false;\n\n      for (let i = 0; i < newMergedRects.length; i++) {\n        if (covers(newMergedRects[i], rect)) {\n          merged = true;\n          break;\n        } else if (intersects(newMergedRects[i], rect)) {\n          newMergedRects[i] = merge(newMergedRects[i], rect);\n          merged = true;\n          hasChanges = true;\n          break;\n        }\n      }\n\n      if (!merged) {\n        newMergedRects.push(rect);\n      }\n    }\n\n    if (!hasChanges) {\n      for (let i = 0; i < newMergedRects.length; i++) {\n        for (let j = i + 1; j < newMergedRects.length; j++) {\n          if (intersects(newMergedRects[i], newMergedRects[j])) {\n            newMergedRects[i] = merge(newMergedRects[i], newMergedRects[j]);\n            newMergedRects.splice(j, 1);\n            hasChanges = true;\n            break;\n          }\n        }\n      }\n    }\n\n    mergedRects = newMergedRects;\n  } while (hasChanges);\n\n  return mergedRects;\n}\n"]}