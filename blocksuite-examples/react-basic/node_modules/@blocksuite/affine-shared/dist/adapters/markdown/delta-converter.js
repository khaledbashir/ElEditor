import { createIdentifier, } from '@blocksuite/global/di';
import { DeltaASTConverter, } from '../types/adapter.js';
export const InlineDeltaToMarkdownAdapterMatcherIdentifier = createIdentifier('InlineDeltaToMarkdownAdapterMatcher');
export function InlineDeltaToMarkdownAdapterExtension(matcher) {
    const identifier = InlineDeltaToMarkdownAdapterMatcherIdentifier(matcher.name);
    return {
        setup: di => {
            di.addImpl(identifier, () => matcher);
        },
        identifier,
    };
}
export const MarkdownASTToDeltaMatcherIdentifier = createIdentifier('MarkdownASTToDeltaMatcher');
export function MarkdownASTToDeltaExtension(matcher) {
    const identifier = MarkdownASTToDeltaMatcherIdentifier(matcher.name);
    return {
        setup: di => {
            di.addImpl(identifier, () => matcher);
        },
        identifier,
    };
}
export class MarkdownDeltaConverter extends DeltaASTConverter {
    constructor(configs, inlineDeltaMatchers, markdownASTToDeltaMatchers) {
        super();
        this.configs = configs;
        this.inlineDeltaMatchers = inlineDeltaMatchers;
        this.markdownASTToDeltaMatchers = markdownASTToDeltaMatchers;
    }
    applyTextFormatting(delta) {
        let mdast = {
            type: 'text',
            value: delta.attributes?.underline
                ? `<u>${delta.insert}</u>`
                : delta.insert,
        };
        const context = {
            configs: this.configs,
            current: mdast,
        };
        for (const matcher of this.inlineDeltaMatchers) {
            if (matcher.match(delta)) {
                mdast = matcher.toAST(delta, context);
                context.current = mdast;
            }
        }
        return mdast;
    }
    astToDelta(ast) {
        const context = {
            configs: this.configs,
            options: Object.create(null),
            toDelta: (ast) => this.astToDelta(ast),
        };
        for (const matcher of this.markdownASTToDeltaMatchers) {
            if (matcher.match(ast)) {
                return matcher.toDelta(ast, context);
            }
        }
        return 'children' in ast
            ? ast.children.flatMap(child => this.astToDelta(child))
            : [];
    }
    deltaToAST(deltas, depth = 0) {
        if (depth > 0) {
            deltas.unshift({ insert: ' '.repeat(4).repeat(depth) });
        }
        return deltas.map(delta => this.applyTextFormatting(delta));
    }
}
//# sourceMappingURL=delta-converter.js.map