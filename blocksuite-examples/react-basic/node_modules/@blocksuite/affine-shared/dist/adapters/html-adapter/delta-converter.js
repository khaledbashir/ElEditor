import { createIdentifier, } from '@blocksuite/global/di';
import { DeltaASTConverter, } from '../types/adapter.js';
import { TextUtils } from '../utils/text.js';
export const InlineDeltaToHtmlAdapterMatcherIdentifier = createIdentifier('InlineDeltaToHtmlAdapterMatcher');
export function InlineDeltaToHtmlAdapterExtension(matcher) {
    const identifier = InlineDeltaToHtmlAdapterMatcherIdentifier(matcher.name);
    return {
        setup: di => {
            di.addImpl(identifier, () => matcher);
        },
        identifier,
    };
}
export const HtmlASTToDeltaMatcherIdentifier = createIdentifier('HtmlASTToDeltaMatcher');
export function HtmlASTToDeltaExtension(matcher) {
    const identifier = HtmlASTToDeltaMatcherIdentifier(matcher.name);
    return {
        setup: di => {
            di.addImpl(identifier, () => matcher);
        },
        identifier,
    };
}
export class HtmlDeltaConverter extends DeltaASTConverter {
    constructor(configs, inlineDeltaMatchers, htmlASTToDeltaMatchers) {
        super();
        this.configs = configs;
        this.inlineDeltaMatchers = inlineDeltaMatchers;
        this.htmlASTToDeltaMatchers = htmlASTToDeltaMatchers;
    }
    _applyTextFormatting(delta) {
        let hast = {
            type: 'text',
            value: delta.insert,
        };
        const context = {
            configs: this.configs,
            current: hast,
        };
        for (const matcher of this.inlineDeltaMatchers) {
            if (matcher.match(delta)) {
                hast = matcher.toAST(delta, context);
                context.current = hast;
            }
        }
        return hast;
    }
    _spreadAstToDelta(ast, options = Object.create(null)) {
        const context = {
            configs: this.configs,
            options,
            toDelta: (ast, options) => this._spreadAstToDelta(ast, options),
        };
        for (const matcher of this.htmlASTToDeltaMatchers) {
            if (matcher.match(ast)) {
                return matcher.toDelta(ast, context);
            }
        }
        return 'children' in ast
            ? ast.children.flatMap(child => this._spreadAstToDelta(child, options))
            : [];
    }
    astToDelta(ast, options = Object.create(null)) {
        return this._spreadAstToDelta(ast, options).reduce((acc, cur) => {
            return TextUtils.mergeDeltas(acc, cur);
        }, []);
    }
    deltaToAST(deltas, depth = 0) {
        if (depth > 0) {
            deltas.unshift({ insert: ' '.repeat(4).repeat(depth) });
        }
        return deltas.map(delta => this._applyTextFormatting(delta));
    }
}
//# sourceMappingURL=delta-converter.js.map