import { ColorScheme } from '@blocksuite/affine-model';
import { Extension, StdIdentifier, } from '@blocksuite/block-std';
import { createIdentifier } from '@blocksuite/global/di';
import { signal } from '@preact/signals-core';
import { combinedDarkCssVariables, combinedLightCssVariables, } from '@toeverything/theme';
import { isInsideEdgelessEditor } from '../utils/index.js';
const TRANSPARENT = 'transparent';
export const ThemeExtensionIdentifier = createIdentifier('AffineThemeExtension');
export function OverrideThemeExtension(service) {
    return {
        setup: di => {
            di.override(ThemeExtensionIdentifier, () => service);
        },
    };
}
export const ThemeProvider = createIdentifier('AffineThemeProvider');
export class ThemeService extends Extension {
    get appTheme() {
        return this.app$.peek();
    }
    get edgelessTheme() {
        return this.edgeless$.peek();
    }
    get theme() {
        return isInsideEdgelessEditor(this.std.host)
            ? this.edgelessTheme
            : this.appTheme;
    }
    get theme$() {
        return isInsideEdgelessEditor(this.std.host) ? this.edgeless$ : this.app$;
    }
    constructor(std) {
        super();
        this.std = std;
        const extension = this.std.getOptional(ThemeExtensionIdentifier);
        this.app$ = extension?.getAppTheme?.() || getThemeObserver().theme$;
        this.edgeless$ =
            extension?.getEdgelessTheme?.(this.std.doc.id) ||
                getThemeObserver().theme$;
    }
    static setup(di) {
        di.addImpl(ThemeProvider, ThemeService, [StdIdentifier]);
    }
    /**
     * Generates a CSS's color property with `var` or `light-dark` functions.
     *
     * Sometimes used to set the frame/note background.
     *
     * @param color - A color value.
     * @param fallback  - If color value processing fails, it will be used as a fallback.
     * @returns - A color property string.
     *
     * @example
     *
     * ```
     * `rgba(255,0,0)`
     * `#fff`
     * `light-dark(#fff, #000)`
     * `var(--affine-palette-shape-blue)`
     * ```
     */
    generateColorProperty(color, fallback = 'transparent', theme = this.theme) {
        let result = undefined;
        if (typeof color === 'object') {
            result = color[theme] ?? color.normal;
        }
        else {
            result = color;
        }
        if (!result) {
            result = fallback;
        }
        if (result.startsWith('--')) {
            return result.endsWith(TRANSPARENT) ? TRANSPARENT : `var(${result})`;
        }
        return result ?? TRANSPARENT;
    }
    /**
     * Gets a color with the current theme.
     *
     * @param color - A color value.
     * @param fallback - If color value processing fails, it will be used as a fallback.
     * @param real - If true, it returns the computed style.
     * @returns - A color property string.
     *
     * @example
     *
     * ```
     * `rgba(255,0,0)`
     * `#fff`
     * `--affine-palette-shape-blue`
     * ```
     */
    getColorValue(color, fallback = TRANSPARENT, real = false, theme = this.theme) {
        let result = undefined;
        if (typeof color === 'object') {
            result = color[theme] ?? color.normal;
        }
        else {
            result = color;
        }
        if (!result) {
            result = fallback;
        }
        if (real && result.startsWith('--')) {
            result = result.endsWith(TRANSPARENT)
                ? TRANSPARENT
                : this.getCssVariableColor(result, theme);
        }
        return result ?? TRANSPARENT;
    }
    getCssVariableColor(property, theme = this.theme) {
        if (property.startsWith('--')) {
            if (property.endsWith(TRANSPARENT)) {
                return TRANSPARENT;
            }
            const key = property;
            const color = theme === ColorScheme.Dark
                ? combinedDarkCssVariables[key]
                : combinedLightCssVariables[key];
            return color;
        }
        return property;
    }
}
export class ThemeObserver {
    constructor() {
        this.theme$ = signal(ColorScheme.Light);
        const COLOR_SCHEMES = Object.values(ColorScheme);
        this.observer = new MutationObserver(() => {
            const mode = document.documentElement.dataset.theme;
            if (!mode)
                return;
            if (!COLOR_SCHEMES.includes(mode))
                return;
            if (mode === this.theme$.value)
                return;
            this.theme$.value = mode;
        });
        this.observer.observe(document.documentElement, {
            attributes: true,
            attributeFilter: ['data-theme'],
        });
    }
    destroy() {
        this.observer.disconnect();
    }
}
export const getThemeObserver = (function () {
    let observer;
    return function () {
        if (observer)
            return observer;
        observer = new ThemeObserver();
        return observer;
    };
})();
//# sourceMappingURL=theme-service.js.map