import type { GfxController, GfxModel } from '@blocksuite/block-std/gfx';
import type { IBound, IVec } from '@blocksuite/global/utils';
import { type BrushElementModel, type Connection, ConnectorElementModel, GroupElementModel, type LocalConnectorElementModel } from '@blocksuite/affine-model';
import { Bound, PointLocation } from '@blocksuite/global/utils';
import { Overlay } from '../renderer/overlay.js';
import { AStarRunner } from '../utils/a-star.js';
export type Connectable = Exclude<BlockSuite.EdgelessModel, ConnectorElementModel | BrushElementModel | GroupElementModel>;
export type OrthogonalConnectorInput = {
    startBound: Bound | null;
    endBound: Bound | null;
    startPoint: PointLocation;
    endPoint: PointLocation;
};
export declare const ConnectorEndpointLocations: IVec[];
export declare const ConnectorEndpointLocationsOnTriangle: IVec[];
export declare function isConnectorWithLabel(model: GfxModel | BlockSuite.SurfaceLocalModel): boolean;
export declare function calculateNearestLocation(point: IVec, bounds: IBound, locations?: IVec[], shortestDistance?: number): IVec;
export declare function isConnectorAndBindingsAllSelected(connector: ConnectorElementModel | LocalConnectorElementModel, selected: GfxModel[]): boolean;
export declare function getAnchors(ele: GfxModel): {
    point: PointLocation;
    coord: IVec;
}[];
export declare function getNearestConnectableAnchor(ele: Connectable, point: IVec): PointLocation;
export declare class ConnectionOverlay extends Overlay {
    static overlayName: string;
    private _emphasisColor;
    private _themeDisposer;
    highlightPoint: IVec | null;
    points: IVec[];
    sourceBounds: IBound | null;
    targetBounds: IBound | null;
    constructor(gfx: GfxController);
    private _findConnectablesInViews;
    private _getEmphasisColor;
    private _setupThemeListener;
    _clearRect(): void;
    clear(): void;
    dispose(): void;
    render(ctx: CanvasRenderingContext2D): void;
    /**
     * Render the connector at the given point. It will try to find
     * the closest connectable element and render the connector. If the
     * point is not close to any connectable element, it will just render
     * the connector at the given point.
     * @param point the point to render the connector
     * @param excludedIds the ids of the elements that should be excluded
     * @returns the connection result
     */
    renderConnector(point: IVec, excludedIds?: string[]): Connection;
}
export declare class PathGenerator {
    protected _aStarRunner: AStarRunner | null;
    protected _prepareOrthogonalConnectorInfo(connectorInfo: OrthogonalConnectorInput): [
        IVec,
        IVec,
        IVec,
        IVec,
        Bound | null,
        Bound | null,
        Bound | null,
        Bound | null
    ];
    generateOrthogonalConnectorPath(input: OrthogonalConnectorInput): IVec[];
}
export declare class ConnectorPathGenerator extends PathGenerator {
    private options;
    constructor(options: {
        getElementById: (id: string) => GfxModel | null;
    });
    static updatePath(connector: ConnectorElementModel | LocalConnectorElementModel, path: PointLocation[] | null, elementGetter?: (id: string) => GfxModel | null): void;
    private _computeStartEndPoint;
    private _generateConnectorPath;
    private _generateCurveConnectorPath;
    private _generateStraightConnectorPath;
    private _getConnectionPoint;
    private _getConnectorEndElement;
    hasRelatedElement(connecter: ConnectorElementModel | LocalConnectorElementModel): boolean;
}
//# sourceMappingURL=connector-manager.d.ts.map