{"version":3,"file":"text.js","sourceRoot":"","sources":["../../../src/adapters/utils/text.ts"],"names":[],"mappings":"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","sourcesContent":["import type { DeltaInsert } from '@blocksuite/inline/types';\n\nimport type { MindMapTreeNode } from '../types/mindmap.js';\n\nimport { buildMindMapTree } from './mindmap.js';\n\nexport function getShapeType(elementModel: Record<string, unknown>): string {\n  let shapeType = '';\n  if (elementModel.type !== 'shape') {\n    return shapeType;\n  }\n\n  if (\n    'shapeType' in elementModel &&\n    typeof elementModel.shapeType === 'string'\n  ) {\n    shapeType = elementModel.shapeType;\n  }\n  return shapeType;\n}\n\nexport function getShapeText(elementModel: Record<string, unknown>): string {\n  let text = '';\n  if (elementModel.type !== 'shape') {\n    return text;\n  }\n\n  if (\n    'text' in elementModel &&\n    typeof elementModel.text === 'object' &&\n    elementModel.text\n  ) {\n    let delta: DeltaInsert[] = [];\n    if ('delta' in elementModel.text) {\n      delta = elementModel.text.delta as DeltaInsert[];\n    }\n    text = delta.map(d => d.insert).join('');\n  }\n  return text;\n}\n\nexport function getConnectorText(\n  elementModel: Record<string, unknown>\n): string {\n  let text = '';\n  if (elementModel.type !== 'connector') {\n    return text;\n  }\n\n  if (\n    'text' in elementModel &&\n    typeof elementModel.text === 'object' &&\n    elementModel.text\n  ) {\n    let delta: DeltaInsert[] = [];\n    if ('delta' in elementModel.text) {\n      delta = elementModel.text.delta as DeltaInsert[];\n    }\n    text = delta.map(d => d.insert).join('');\n  }\n  return text;\n}\n\nexport function getGroupTitle(elementModel: Record<string, unknown>): string {\n  let title = '';\n  if (elementModel.type !== 'group') {\n    return title;\n  }\n\n  if (\n    'title' in elementModel &&\n    typeof elementModel.title === 'object' &&\n    elementModel.title\n  ) {\n    let delta: DeltaInsert[] = [];\n    if ('delta' in elementModel.title) {\n      delta = elementModel.title.delta as DeltaInsert[];\n    }\n    title = delta.map(d => d.insert).join('');\n  }\n  return title;\n}\n\nexport function getTextElementText(\n  elementModel: Record<string, unknown>\n): string {\n  let text = '';\n  if (elementModel.type !== 'text') {\n    return text;\n  }\n  if (\n    'text' in elementModel &&\n    typeof elementModel.text === 'object' &&\n    elementModel.text\n  ) {\n    let delta: DeltaInsert[] = [];\n    if ('delta' in elementModel.text) {\n      delta = elementModel.text.delta as DeltaInsert[];\n    }\n    text = delta.map(d => d.insert).join('');\n  }\n  return text;\n}\n\n/**\n * traverse the mindMapTree and construct the content string\n * like:\n * - Root\n *   - Child 1\n *     - Child 1.1\n *     - Child 1.2\n *   - Child 2\n *     - Child 2.1\n *     - Child 2.2\n *   - Child 3\n *     - Child 3.1\n *     - Child 3.2\n * @param elementModel - the mindmap element model\n * @param elements - the elements map\n * @returns the mindmap tree text\n */\nexport function getMindMapTreeText(\n  elementModel: Record<string, unknown>,\n  elements: Record<string, Record<string, unknown>>,\n  options: {\n    prefix: string;\n    repeat: number;\n  } = {\n    prefix: ' ',\n    repeat: 2,\n  }\n): string {\n  let mindMapContent = '';\n  if (elementModel.type !== 'mindmap') {\n    return mindMapContent;\n  }\n\n  const mindMapTree = buildMindMapTree(elementModel);\n  if (!mindMapTree) {\n    return mindMapContent;\n  }\n\n  let layer = 0;\n  const traverseMindMapTree = (\n    node: MindMapTreeNode,\n    prefix: string,\n    repeat: number\n  ) => {\n    const shapeElement = elements[node.id as string];\n    const shapeText = getShapeText(shapeElement);\n    if (shapeElement) {\n      mindMapContent += `${prefix.repeat(layer * repeat)}- ${shapeText}\\n`;\n    }\n    node.children.forEach(child => {\n      layer++;\n      traverseMindMapTree(child, prefix, repeat);\n      layer--;\n    });\n  };\n  traverseMindMapTree(mindMapTree, options.prefix, options.repeat);\n\n  return mindMapContent;\n}\n"]}