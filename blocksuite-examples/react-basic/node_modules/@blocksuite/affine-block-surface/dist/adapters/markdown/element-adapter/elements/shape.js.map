{"version":3,"file":"shape.js","sourceRoot":"","sources":["../../../../../src/adapters/markdown/element-adapter/elements/shape.ts"],"names":[],"mappings":"AAGA,OAAO,EAAE,YAAY,EAAE,YAAY,EAAE,MAAM,wBAAwB,CAAC;AAEpE,MAAM,CAAC,MAAM,6BAA6B,GACxC;IACE,IAAI,EAAE,OAAO;IACb,KAAK,EAAE,YAAY,CAAC,EAAE,CAAC,YAAY,CAAC,IAAI,KAAK,OAAO;IACpD,KAAK,EAAE,CAAC,YAAY,EAAE,OAAO,EAAE,EAAE;QAC/B,IAAI,OAAO,GAAG,EAAE,CAAC;QACjB,MAAM,EAAE,aAAa,EAAE,GAAG,OAAO,CAAC;QAClC,MAAM,eAAe,GAAG,aAAa,CAAC,gBAAgB,CACpD,8BAA8B,CACQ,CAAC;QACzC,IAAI,eAAe,IAAI,eAAe,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YAClD,8CAA8C;YAC9C,sDAAsD;YACtD,uDAAuD;YACvD,MAAM,aAAa,GAAG,eAAe,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE,CACnD,OAAO,CAAC,GAAG,CAAC,YAAY,CAAC,EAAY,CAAC,CACvC,CAAC;YACF,IAAI,aAAa,EAAE,CAAC;gBAClB,OAAO,IAAI,CAAC;YACd,CAAC;QACH,CAAC;QAED,wDAAwD;QACxD,MAAM,IAAI,GAAG,YAAY,CAAC,YAAY,CAAC,CAAC;QACxC,MAAM,IAAI,GAAG,YAAY,CAAC,YAAY,CAAC,CAAC;QACxC,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,EAAE,CAAC;YACnB,OAAO,IAAI,CAAC;QACd,CAAC;QAED,MAAM,SAAS,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;QAC/D,OAAO,GAAG,GAAG,SAAS,sBAAsB,IAAI,GAAG,CAAC;QACpD,OAAO;YACL,IAAI,EAAE,WAAW;YACjB,QAAQ,EAAE;gBACR;oBACE,IAAI,EAAE,MAAM;oBACZ,KAAK,EAAE,OAAO;iBACf;aACF;SACF,CAAC;IACJ,CAAC;CACF,CAAC","sourcesContent":["import type { MindMapTreeNode } from '../../../types/mindmap.js';\nimport type { ElementModelToMarkdownAdapterMatcher } from '../type.js';\n\nimport { getShapeText, getShapeType } from '../../../utils/text.js';\n\nexport const shapeToMarkdownAdapterMatcher: ElementModelToMarkdownAdapterMatcher =\n  {\n    name: 'shape',\n    match: elementModel => elementModel.type === 'shape',\n    toAST: (elementModel, context) => {\n      let content = '';\n      const { walkerContext } = context;\n      const mindMapNodeMaps = walkerContext.getGlobalContext(\n        'surface:mindMap:nodeMapArray'\n      ) as Array<Map<string, MindMapTreeNode>>;\n      if (mindMapNodeMaps && mindMapNodeMaps.length > 0) {\n        // Check if the elementModel is a mindMap node\n        // If it is, we should return { content: '' } directly\n        // And get the content when we handle the whole mindMap\n        const isMindMapNode = mindMapNodeMaps.some(nodeMap =>\n          nodeMap.has(elementModel.id as string)\n        );\n        if (isMindMapNode) {\n          return null;\n        }\n      }\n\n      // If it is not, we should return the text and shapeType\n      const text = getShapeText(elementModel);\n      const type = getShapeType(elementModel);\n      if (!text && !type) {\n        return null;\n      }\n\n      const shapeType = type.charAt(0).toUpperCase() + type.slice(1);\n      content = `${shapeType}, with text label \"${text}\"`;\n      return {\n        type: 'paragraph',\n        children: [\n          {\n            type: 'text',\n            value: content,\n          },\n        ],\n      };\n    },\n  };\n"]}