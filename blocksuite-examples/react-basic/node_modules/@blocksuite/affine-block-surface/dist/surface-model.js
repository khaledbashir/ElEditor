import { SurfaceBlockModel as BaseSurfaceModel } from '@blocksuite/block-std/gfx';
import { DisposableGroup } from '@blocksuite/global/utils';
import { defineBlockSchema, DocCollection } from '@blocksuite/store';
import { elementsCtorMap } from './element-model/index.js';
import { SurfaceBlockTransformer } from './surface-transformer.js';
import { connectorWatcher } from './watchers/connector.js';
import { groupRelationWatcher } from './watchers/group.js';
export const SurfaceBlockSchema = defineBlockSchema({
    flavour: 'affine:surface',
    props: (internalPrimitives) => ({
        elements: internalPrimitives.Boxed(new DocCollection.Y.Map()),
    }),
    metadata: {
        version: 5,
        role: 'hub',
        parent: ['affine:page'],
        children: [
            'affine:frame',
            'affine:image',
            'affine:bookmark',
            'affine:attachment',
            'affine:embed-*',
            'affine:edgeless-text',
        ],
    },
    transformer: () => new SurfaceBlockTransformer(),
    toModel: () => new SurfaceBlockModel(),
});
export class SurfaceBlockModel extends BaseSurfaceModel {
    constructor() {
        super(...arguments);
        this._disposables = new DisposableGroup();
    }
    _init() {
        this._extendElement(elementsCtorMap);
        super._init();
        [connectorWatcher(this), groupRelationWatcher(this)].forEach(disposable => this._disposables.add(disposable));
    }
    getConnectors(id) {
        const connectors = this.getElementsByType('connector');
        return connectors.filter(connector => connector.source?.id === id || connector.target?.id === id);
    }
    getElementsByType(type) {
        return super.getElementsByType(type);
    }
}
//# sourceMappingURL=surface-model.js.map