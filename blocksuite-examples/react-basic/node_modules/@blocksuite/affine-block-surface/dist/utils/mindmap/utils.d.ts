import { LayoutType, type MindmapElementModel, type MindmapNode, type MindmapRoot, type MindmapStyle, type NodeType, type ShapeElementModel } from '@blocksuite/affine-model';
import { type SurfaceBlockModel } from '@blocksuite/block-std/gfx';
import { type IVec } from '@blocksuite/global/utils';
export declare function getHoveredArea(target: ShapeElementModel, position: [number, number], layoutDir: LayoutType): 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';
/**
 * Hide the connector between the target node and its parent
 */
export declare function hideNodeConnector(mindmap: MindmapElementModel, 
/**
 * The mind map node which's connector will be hide
 */
target: MindmapNode): (() => void) | undefined;
export declare function applyStyle(mindmap: MindmapElementModel, shouldFitContent?: boolean): void;
/**
 *
 * @param mindmap the mind map to add the node to
 * @param parent the parent node or the parent node id
 * @param node the node must be an detached node
 * @param targetIndex the index to insert the node at
 * @returns
 */
export declare function addNode(mindmap: MindmapElementModel, parent: string | MindmapNode, node: MindmapNode, targetIndex?: number): void;
export declare function addTree(mindmap: MindmapElementModel, parent: string | MindmapNode, tree: NodeType | MindmapNode, 
/**
 * `sibling` indicates where to insert a subtree among peer elements.
 * If it's a string, it represents a peer element's ID;
 * if it's a number, it represents its index.
 * The subtree will be inserted before the sibling element.
 */
sibling?: string | number): MindmapNode | null | undefined;
/**
 * Detach a mindmap node or subtree. It is similar to `removeChild` but
 * it does not delete the node.
 *
 * So the node can be used to create a new mind map or merge into other mind map
 * @param mindmap the mind map that the subtree belongs to
 * @param subtree the subtree to detach
 */
export declare function detachMindmap(mindmap: MindmapElementModel, subtree: string | MindmapNode): MindmapNode | undefined;
export declare function handleLayout(mindmap: MindmapElementModel, tree?: MindmapNode | MindmapRoot, shouldApplyStyle?: boolean, layoutType?: LayoutType): void;
export declare function createFromTree(tree: MindmapNode, style: MindmapStyle, layoutType: LayoutType, surface: SurfaceBlockModel): MindmapElementModel;
/**
 * Move a subtree from one mind map to another
 * @param from the mind map that the `subtree` belongs to
 * @param subtree the subtree to move
 * @param to the mind map to move the `subtree` to
 * @param parent the new parent node to attach the `subtree` to
 * @param index the index to insert the `subtree` at
 */
export declare function moveNode(from: MindmapElementModel, subtree: MindmapNode, to: MindmapElementModel, parent: MindmapNode | string, index: number): void | MindmapNode;
export declare function findTargetNode(mindmap: MindmapElementModel, position: IVec): MindmapNode | null;
/**
 * Try to move a node to another mind map.
 * It will show a merge indicator if the node can be merged to the target mind map.
 * @param targetMindMap
 * @param target
 * @param sourceMindMap
 * @param source
 * @param position
 * @return return two functions, `abort` and `merge`. `abort` will cancel the operation and `merge` will merge the node to the target mind map.
 */
export declare function tryMoveNode(targetMindMap: MindmapElementModel, target: MindmapNode, sourceMindMap: MindmapElementModel, source: MindmapNode, position: IVec, callback: (option: {
    targetMindMap: MindmapElementModel;
    target: MindmapNode;
    sourceMindMap: MindmapElementModel;
    source: MindmapNode;
    newParent: MindmapNode;
    insertPosition: {
        type: 'sibling';
        layoutDir: Exclude<LayoutType, LayoutType.BALANCE>;
        position: 'prev' | 'next';
    } | {
        type: 'child';
        layoutDir: Exclude<LayoutType, LayoutType.BALANCE>;
    };
    path: number[];
}) => () => void): {
    abort: () => void;
    merge: () => void;
} | null;
/**
 * Check if the mind map contains the target node.
 * @param mindmap Mind map to check
 * @param targetNode Node to check
 * @param searchParent If provided, check if the node is a descendant of the parent node. Otherwise, check the whole mind map.
 * @returns
 */
export declare function containsNode(mindmap: MindmapElementModel, targetNode: MindmapNode, searchParent?: MindmapNode): boolean;
//# sourceMappingURL=utils.d.ts.map