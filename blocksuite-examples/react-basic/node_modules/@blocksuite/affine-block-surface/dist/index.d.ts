export { type IModelCoord, ZOOM_MAX, ZOOM_MIN, ZOOM_STEP } from './consts.js';
export { GRID_GAP_MAX, GRID_GAP_MIN } from './consts.js';
export { SurfaceElementModel, SurfaceGroupLikeModel, } from './element-model/base.js';
export { CanvasElementType } from './element-model/index.js';
import { isConnectorAndBindingsAllSelected, isConnectorWithLabel } from './managers/connector-manager.js';
export { calculateNearestLocation, ConnectionOverlay, ConnectorEndpointLocations, ConnectorEndpointLocationsOnTriangle, ConnectorPathGenerator, PathGenerator, } from './managers/connector-manager.js';
export { CanvasRenderer } from './renderer/canvas-renderer.js';
export * from './renderer/elements/group/consts.js';
export type { ElementRenderer } from './renderer/elements/index.js';
export { elementRenderers, normalizeShapeBound, } from './renderer/elements/index.js';
export { fitContent } from './renderer/elements/shape/utils.js';
export * from './renderer/elements/type.js';
export { Overlay, OverlayIdentifier } from './renderer/overlay.js';
import { getCursorByCoord, getLineHeight, isFontStyleSupported, isFontWeightSupported, normalizeTextBound, splitIntoLines } from './renderer/elements/text/utils.js';
import { getFontFacesByFontFamily, wrapFontFamily } from './utils/font.js';
export { SurfaceBlockComponent } from './surface-block.js';
export type { SurfaceContext } from './surface-block.js';
export { SurfaceBlockModel, SurfaceBlockSchema } from './surface-model.js';
export type { SurfaceBlockService } from './surface-service.js';
export { EdgelessSurfaceBlockSpec, PageSurfaceBlockSpec, } from './surface-spec.js';
export { SurfaceBlockTransformer } from './surface-transformer.js';
export { AStarRunner } from './utils/a-star.js';
export { NODE_FIRST_LEVEL_HORIZONTAL_SPACING, NODE_HORIZONTAL_SPACING, NODE_VERTICAL_SPACING, } from './utils/mindmap/layout.js';
export { RoughCanvas } from './utils/rough/canvas.js';
import { almostEqual, clamp, getPointFromBoundsWithRotation, getStroke, getSvgPathFromStroke, intersects, isOverlap, isPointIn, lineIntersects, linePolygonIntersects, normalizeDegAngle, polygonGetPointTangent, polygonNearestPoint, polygonPointDistance, polyLineNearestPoint, rotatePoints, sign, toDegree, toRadian } from '@blocksuite/global/utils';
import { generateKeyBetween } from 'fractional-indexing';
import { generateElementId, normalizeWheelDeltaY } from './utils/index.js';
import { addTree, containsNode, createFromTree, detachMindmap, findTargetNode, hideNodeConnector, moveNode, tryMoveNode } from './utils/mindmap/utils.js';
export type { Options } from './utils/rough/core.js';
export { sortIndex } from './utils/sort.js';
export { updateXYWH } from './utils/update-xywh.js';
export declare const ConnectorUtils: {
    isConnectorAndBindingsAllSelected: typeof isConnectorAndBindingsAllSelected;
    isConnectorWithLabel: typeof isConnectorWithLabel;
};
export declare const TextUtils: {
    splitIntoLines: typeof splitIntoLines;
    normalizeTextBound: typeof normalizeTextBound;
    getLineHeight: typeof getLineHeight;
    getCursorByCoord: typeof getCursorByCoord;
    isFontWeightSupported: typeof isFontWeightSupported;
    isFontStyleSupported: typeof isFontStyleSupported;
    wrapFontFamily: typeof wrapFontFamily;
    getFontFaces: () => FontFace[];
    getFontFacesByFontFamily: typeof getFontFacesByFontFamily;
    isSameFontFamily: (fontFamily: import("@blocksuite/affine-model").FontFamily | string) => (fontFace: FontFace) => boolean;
};
export declare const CommonUtils: {
    almostEqual: typeof almostEqual;
    clamp: typeof clamp;
    generateElementId: typeof generateElementId;
    generateKeyBetween: typeof generateKeyBetween;
    getPointFromBoundsWithRotation: typeof getPointFromBoundsWithRotation;
    getStroke: typeof getStroke;
    getSvgPathFromStroke: typeof getSvgPathFromStroke;
    intersects: typeof intersects;
    isOverlap: typeof isOverlap;
    isPointIn: typeof isPointIn;
    lineIntersects: typeof lineIntersects;
    linePolygonIntersects: typeof linePolygonIntersects;
    normalizeDegAngle: typeof normalizeDegAngle;
    normalizeWheelDeltaY: typeof normalizeWheelDeltaY;
    polygonGetPointTangent: typeof polygonGetPointTangent;
    polygonNearestPoint: typeof polygonNearestPoint;
    polygonPointDistance: typeof polygonPointDistance;
    polyLineNearestPoint: typeof polyLineNearestPoint;
    rotatePoints: typeof rotatePoints;
    sign: typeof sign;
    toDegree: typeof toDegree;
    toRadian: typeof toRadian;
};
export declare const MindmapUtils: {
    addTree: typeof addTree;
    createFromTree: typeof createFromTree;
    detachMindmap: typeof detachMindmap;
    moveNode: typeof moveNode;
    findTargetNode: typeof findTargetNode;
    tryMoveNode: typeof tryMoveNode;
    hideNodeConnector: typeof hideNodeConnector;
    containsNode: typeof containsNode;
};
//# sourceMappingURL=index.d.ts.map