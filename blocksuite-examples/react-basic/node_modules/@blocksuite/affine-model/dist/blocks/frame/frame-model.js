var _a;
import { canSafeAddToContainer, descendantElementsImpl, generateKeyBetweenV2, GfxCompatible, gfxGroupCompatibleSymbol, hasDescendantElementImpl, } from '@blocksuite/block-std/gfx';
import { Bound } from '@blocksuite/global/utils';
import { BlockModel, defineBlockSchema } from '@blocksuite/store';
export const FrameBlockSchema = defineBlockSchema({
    flavour: 'affine:frame',
    props: (internal) => ({
        title: internal.Text(),
        background: '--affine-palette-transparent',
        xywh: `[0,0,100,100]`,
        index: 'a0',
        childElementIds: Object.create(null),
        presentationIndex: generateKeyBetweenV2(null, null),
        lockedBySelf: false,
    }),
    metadata: {
        version: 1,
        role: 'content',
        parent: ['affine:surface'],
        children: [],
    },
    toModel: () => {
        return new FrameBlockModel();
    },
});
export class FrameBlockModel extends GfxCompatible(BlockModel) {
    constructor() {
        super(...arguments);
        this[_a] = true;
    }
    static { _a = gfxGroupCompatibleSymbol; }
    get childElements() {
        if (!this.surface)
            return [];
        const elements = [];
        for (const key of this.childIds) {
            const element = this.surface.getElementById(key) ||
                this.surface.doc.getBlockById(key);
            element && elements.push(element);
        }
        return elements;
    }
    get childIds() {
        return [...(this.childElementIds ? Object.keys(this.childElementIds) : [])];
    }
    get descendantElements() {
        return descendantElementsImpl(this);
    }
    addChild(element) {
        if (!canSafeAddToContainer(this, element))
            return;
        this.doc.transact(() => {
            this.childElementIds = { ...this.childElementIds, [element.id]: true };
        });
    }
    addChildren(elements) {
        elements = [...new Set(elements)].filter(element => canSafeAddToContainer(this, element));
        const newChildren = {};
        for (const element of elements) {
            const id = typeof element === 'string' ? element : element.id;
            newChildren[id] = true;
        }
        this.doc.transact(() => {
            this.childElementIds = {
                ...this.childElementIds,
                ...newChildren,
            };
        });
    }
    containsBound(bound) {
        return this.elementBound.contains(bound);
    }
    hasChild(element) {
        return this.childElementIds ? element.id in this.childElementIds : false;
    }
    hasDescendant(element) {
        return hasDescendantElementImpl(this, element);
    }
    includesPoint(x, y, _) {
        const bound = Bound.deserialize(this.xywh);
        return bound.isPointInBound([x, y]);
    }
    intersectsBound(selectedBound) {
        const bound = Bound.deserialize(this.xywh);
        return (bound.isIntersectWithBound(selectedBound) || selectedBound.contains(bound));
    }
    removeChild(element) {
        this.doc.transact(() => {
            this.childElementIds && delete this.childElementIds[element.id];
        });
    }
}
//# sourceMappingURL=frame-model.js.map