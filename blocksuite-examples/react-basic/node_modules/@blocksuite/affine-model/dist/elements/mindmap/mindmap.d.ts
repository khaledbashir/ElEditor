import type { BaseElementProps, GfxModel, PointTestOptions, SerializedElement } from '@blocksuite/block-std/gfx';
import type { Bound, SerializedXYWH, XYWH } from '@blocksuite/global/utils';
import { GfxGroupLikeElementModel } from '@blocksuite/block-std/gfx';
import { type Y } from '@blocksuite/store';
import { z } from 'zod';
import type { MindmapStyleGetter } from './style.js';
import { LayoutType, MindmapStyle } from '../../consts/mindmap.js';
import { LocalConnectorElementModel } from '../connector/local-connector.js';
export type NodeDetail = {
    /**
     * The index of the node, it decides the layout order of the node
     */
    index: string;
    parent?: string;
    collapsed?: boolean;
};
export type MindmapNode = {
    id: string;
    detail: NodeDetail;
    element: BlockSuite.SurfaceElementModel;
    children: MindmapNode[];
    parent: MindmapNode | null;
    /**
     * This area is used to determine where to place the dragged node.
     *
     * When dragging another node into this area, it will become a sibling of the this node.
     * But if it is dragged into the small area located right after the this node, it will become a child of the this node.
     */
    responseArea?: Bound;
    /**
     * This property override the preferredDir or default layout direction.
     * It is used during dragging that would temporary change the layout direction
     */
    overriddenDir?: LayoutType;
};
export type MindmapRoot = MindmapNode & {
    left: MindmapNode[];
    right: MindmapNode[];
};
declare const baseNodeSchema: z.ZodObject<{
    text: z.ZodString;
    xywh: z.ZodOptional<z.ZodString>;
}, "strip", z.ZodTypeAny, {
    text: string;
    xywh?: string | undefined;
}, {
    text: string;
    xywh?: string | undefined;
}>;
type Node = z.infer<typeof baseNodeSchema> & {
    children?: Node[];
};
declare const nodeSchema: z.ZodType<Node>;
export type NodeType = z.infer<typeof nodeSchema>;
export type SerializedMindmapElement = SerializedElement & {
    children: Record<string, NodeDetail>;
};
type MindmapElementProps = BaseElementProps & {
    children: Y.Map<NodeDetail>;
};
export declare class MindmapElementModel extends GfxGroupLikeElementModel<MindmapElementProps> {
    private _layout;
    private _nodeMap;
    private _queueBuildTree;
    private _queuedLayout;
    private _stashedNode;
    private _tree;
    connectors: Map<string, LocalConnectorElementModel>;
    get nodeMap(): Map<string, MindmapNode>;
    get rotate(): number;
    set rotate(_: number);
    get styleGetter(): MindmapStyleGetter;
    get tree(): MindmapRoot;
    get type(): string;
    static propsToY(props: Record<string, unknown>): MindmapElementProps;
    private _cfgBalanceLayoutDir;
    private _isConnectorOutdated;
    protected _getXYWH(): Bound;
    /**
     * @deprecated
     * you should not call this method directly
     */
    addChild(_element: GfxModel): void;
    addNode(
    /**
     * The parent node id of the new node. If it's null, the node will be the root node
     */
    parent: string | MindmapNode | null, sibling?: string | number, position?: 'before' | 'after', props?: Record<string, unknown>): string;
    buildTree(): void;
    /**
     *
     * @param subtree The subtree of root, this only take effects when the layout type is BALANCED.
     * @returns
     */
    getChildNodes(id: string, subtree?: 'left' | 'right'): MindmapNode[];
    /**
     * Get all the connectors start from the given node
     * @param node
     * @returns
     */
    getConnectors(node: MindmapNode): {
        outdated: boolean | {
            outdated: boolean;
            cacheKey: string;
        };
        connector: LocalConnectorElementModel;
    }[] | null;
    getLayoutDir(node: string | MindmapNode): LayoutType;
    getNode(id: string): MindmapNode | null;
    getParentNode(id: string): MindmapNode | null;
    /**
     * Path is an array of indexes that represent the path from the root node to the target node.
     * The first element of the array is always 0, which represents the root node.
     * @param element
     * @returns
     *
     * @example
     * ```ts
     * const path = mindmap.getPath('nodeId');
     * // [0, 1, 2]
     * ```
     */
    getPath(element: string | MindmapNode): number[];
    getSiblingNode(id: string, direction?: 'prev' | 'next', 
    /**
     * The subtree of which that the sibling node belongs to,
     * this is used when the layout type is BALANCED.
     */
    subtree?: 'left' | 'right'): MindmapNode | null;
    includesPoint(x: number, y: number, options: PointTestOptions): boolean;
    layout(_tree?: MindmapNode | MindmapRoot, _options?: {
        applyStyle?: boolean;
        layoutType?: LayoutType;
        calculateTreeBound?: boolean;
        stashed?: boolean;
    }): void;
    moveTo(targetXYWH: SerializedXYWH | XYWH): void;
    onCreated(): void;
    removeChild(element: GfxModel): void;
    protected requestBuildTree(): void;
    requestLayout(): void;
    serialize(): SerializedMindmapElement;
    setLayoutMethod(layoutMethod: MindmapElementModel['layout']): void;
    /**
     * Stash mind map node and its children's xywh property
     * @param node
     * @returns a function that write back the stashed xywh into yjs
     */
    stashTree(node: MindmapNode | string): (() => void) | undefined;
    toggleCollapse(node: MindmapNode, options?: {
        layout?: boolean;
    }): void;
    traverse(callback: (node: MindmapNode, parent: MindmapNode | null) => void, root?: MindmapNode, options?: {
        stopOnCollapse?: boolean;
    }): void;
    accessor children: Y.Map<NodeDetail>;
    accessor layoutType: LayoutType;
    accessor style: MindmapStyle;
}
declare global {
    namespace BlockSuite {
        interface SurfaceGroupLikeModelMap {
            mindmap: MindmapElementModel;
        }
    }
}
export {};
//# sourceMappingURL=mindmap.d.ts.map