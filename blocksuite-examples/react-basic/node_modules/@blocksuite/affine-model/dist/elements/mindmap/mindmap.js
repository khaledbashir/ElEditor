var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
import { convert, field, GfxGroupLikeElementModel, observe, watch, } from '@blocksuite/block-std/gfx';
import { assertType, deserializeXYWH, keys, last, noop, pick, } from '@blocksuite/global/utils';
import { DocCollection } from '@blocksuite/store';
import { generateKeyBetween } from 'fractional-indexing';
import { z } from 'zod';
import { ConnectorMode } from '../../consts/connector.js';
import { LayoutType, MindmapStyle } from '../../consts/mindmap.js';
import { LocalConnectorElementModel } from '../connector/local-connector.js';
import { mindmapStyleGetters } from './style.js';
import { findInfiniteLoop } from './utils.js';
const baseNodeSchema = z.object({
    text: z.string(),
    xywh: z.optional(z.string()),
});
const nodeSchema = baseNodeSchema.extend({
    children: z.lazy(() => nodeSchema.array()).optional(),
});
function isNodeType(node) {
    return typeof node.text === 'string' && Array.isArray(node.children);
}
function observeChildren(_, instance, transaction) {
    if (instance.children.doc) {
        instance.setChildIds(Array.from(instance.children.keys()), transaction?.local ?? true);
        instance.buildTree();
        instance.connectors.clear();
    }
}
function watchLayoutType(_, instance, local) {
    if (!local) {
        return;
    }
    instance.surface.doc.transact(() => {
        instance['_tree']?.children.forEach(child => {
            if (!instance.children.has(child.id)) {
                return;
            }
            instance.children.set(child.id, {
                index: child.detail.index,
                parent: child.detail.parent,
            });
        });
    });
    instance.buildTree();
}
function watchStyle(_, instance, local) {
    if (!local)
        return;
    instance.layout();
}
let MindmapElementModel = (() => {
    let _classSuper = GfxGroupLikeElementModel;
    let _children_decorators;
    let _children_initializers = [];
    let _children_extraInitializers = [];
    let _layoutType_decorators;
    let _layoutType_initializers = [];
    let _layoutType_extraInitializers = [];
    let _style_decorators;
    let _style_initializers = [];
    let _style_extraInitializers = [];
    return class MindmapElementModel extends _classSuper {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            _children_decorators = [convert((initialValue, instance) => {
                    if (!(initialValue instanceof DocCollection.Y.Map)) {
                        nodeSchema.parse(initialValue);
                        assertType(initialValue);
                        const map = new DocCollection.Y.Map();
                        const surface = instance.surface;
                        const doc = surface.doc;
                        const recursive = (node, parent = null, index = 'a0') => {
                            const id = surface.addElement({
                                type: 'shape',
                                text: node.text,
                                xywh: node.xywh ? node.xywh : `[0, 0, 100, 30]`,
                            });
                            map.set(id, {
                                index,
                                parent: parent ?? undefined,
                            });
                            let curIdx = 'a0';
                            node.children?.forEach(childNode => {
                                recursive(childNode, id, curIdx);
                                curIdx = generateKeyBetween(curIdx, null);
                            });
                        };
                        doc.transact(() => {
                            recursive(initialValue);
                        });
                        instance.requestBuildTree();
                        instance.requestLayout();
                        return map;
                    }
                    else {
                        instance.requestBuildTree();
                        instance.requestLayout();
                        return initialValue;
                    }
                }), observe(observeChildren), field()];
            _layoutType_decorators = [watch(watchLayoutType), field()];
            _style_decorators = [watch(watchStyle), field()];
            __esDecorate(this, null, _children_decorators, { kind: "accessor", name: "children", static: false, private: false, access: { has: obj => "children" in obj, get: obj => obj.children, set: (obj, value) => { obj.children = value; } }, metadata: _metadata }, _children_initializers, _children_extraInitializers);
            __esDecorate(this, null, _layoutType_decorators, { kind: "accessor", name: "layoutType", static: false, private: false, access: { has: obj => "layoutType" in obj, get: obj => obj.layoutType, set: (obj, value) => { obj.layoutType = value; } }, metadata: _metadata }, _layoutType_initializers, _layoutType_extraInitializers);
            __esDecorate(this, null, _style_decorators, { kind: "accessor", name: "style", static: false, private: false, access: { has: obj => "style" in obj, get: obj => obj.style, set: (obj, value) => { obj.style = value; } }, metadata: _metadata }, _style_initializers, _style_extraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        get nodeMap() {
            return this._nodeMap;
        }
        get rotate() {
            return 0;
        }
        set rotate(_) { }
        get styleGetter() {
            return mindmapStyleGetters[this.style];
        }
        get tree() {
            return this._tree;
        }
        get type() {
            return 'mindmap';
        }
        static propsToY(props) {
            if (props.children &&
                !isNodeType(props.children) &&
                !(props.children instanceof DocCollection.Y.Map)) {
                const children = new DocCollection.Y.Map();
                keys(props.children).forEach(key => {
                    const detail = pick(props.children[key], ['index', 'parent']);
                    children.set(key, detail);
                });
                props.children = children;
            }
            return props;
        }
        _cfgBalanceLayoutDir() {
            if (this.layoutType !== LayoutType.BALANCE) {
                return;
            }
            const tree = this._tree;
            const splitPoint = Math.ceil(tree.children.length / 2);
            tree.right.push(...tree.children.slice(0, splitPoint));
            tree.left.push(...tree.children.slice(splitPoint));
            tree.left.reverse();
        }
        _isConnectorOutdated(options, updateKey = true) {
            const collapsed = 'collapsed' in options;
            const { connector, from, layout } = options;
            if (!from.element || (!collapsed && !options.to.element)) {
                return { outdated: true, cacheKey: '' };
            }
            const cacheKey = collapsed
                ? `${from.element.xywh}-collapsed-${layout}-${this.style}`
                : `${from.element.xywh}-${options.to.element.xywh}-${layout}-${this.style}`;
            if (connector.cache.get('MINDMAP_CONNECTOR') === cacheKey) {
                return false;
            }
            else if (updateKey) {
                connector.cache.set('MINDMAP_CONNECTOR', cacheKey);
            }
            return true;
        }
        _getXYWH() {
            return super._getXYWH();
        }
        /**
         * @deprecated
         * you should not call this method directly
         */
        addChild(_element) {
            noop();
        }
        addNode(
        /**
         * The parent node id of the new node. If it's null, the node will be the root node
         */
        parent, sibling, position = 'after', props = {}) {
            if (parent && typeof parent !== 'string') {
                parent = parent.id;
            }
            assertType(parent);
            if (parent && !this._nodeMap.has(parent)) {
                throw new Error(`Parent node ${parent} not found`);
            }
            props['text'] = new DocCollection.Y.Text(props['text'] ?? 'New node');
            const type = props.type ?? 'shape';
            let id;
            this.surface.doc.transact(() => {
                const parentNode = parent ? this._nodeMap.get(parent) : null;
                if (parentNode) {
                    let index = last(parentNode.children)
                        ? generateKeyBetween(last(parentNode.children).detail.index, null)
                        : 'a0';
                    sibling = sibling ?? last(parentNode.children)?.id;
                    const siblingNode = typeof sibling === 'number'
                        ? parentNode.children[sibling]
                        : sibling
                            ? this._nodeMap.get(sibling)
                            : undefined;
                    const path = siblingNode
                        ? this.getPath(siblingNode)
                        : this.getPath(parentNode).concat([0]);
                    const style = this.styleGetter.getNodeStyle(siblingNode ?? parentNode, path);
                    id = this.surface.addElement({
                        type,
                        xywh: '[0,0,100,30]',
                        maxWidth: false,
                        ...props,
                        ...style.node,
                    });
                    if (siblingNode) {
                        const siblingIndex = parentNode.children.findIndex(val => val.id === sibling);
                        index =
                            position === 'after'
                                ? generateKeyBetween(siblingNode.detail.index, parentNode.children[siblingIndex + 1]?.detail.index ?? null)
                                : generateKeyBetween(parentNode.children[siblingIndex - 1]?.detail.index ?? null, siblingNode.detail.index);
                    }
                    const nodeDetail = {
                        index,
                        parent: parent,
                    };
                    this.children.set(id, nodeDetail);
                }
                else {
                    const rootStyle = this.styleGetter.root;
                    id = this.surface.addElement({
                        type,
                        xywh: '[0,0,113,41]',
                        maxWidth: false,
                        ...props,
                        ...rootStyle,
                    });
                    this.children.clear();
                    this.children.set(id, {
                        index: 'a0',
                    });
                }
            });
            this.layout();
            return id;
        }
        buildTree() {
            const mindmapNodeMap = new Map();
            const nodesMap = this.children;
            // The element may be removed
            if (!nodesMap || nodesMap.size === 0) {
                this._nodeMap = mindmapNodeMap;
                // @ts-ignore
                this._tree = null;
                return;
            }
            let rootNode;
            nodesMap.forEach((val, id) => {
                if (!mindmapNodeMap.has(id)) {
                    mindmapNodeMap.set(id, {
                        id,
                        index: val.index,
                        detail: val,
                        element: this.surface.getElementById(id),
                        children: [],
                        parent: null,
                    });
                }
                const node = mindmapNodeMap.get(id);
                // some node may be already created during
                // iterating its children
                if (!node.detail) {
                    node.detail = val;
                }
                if (!val.parent) {
                    rootNode = node;
                    rootNode.left = [];
                    rootNode.right = [];
                }
                else {
                    if (!mindmapNodeMap.has(val.parent)) {
                        mindmapNodeMap.set(val.parent, {
                            id: val.parent,
                            detail: nodesMap.get(val.parent),
                            parent: null,
                            children: [],
                            element: this.surface.getElementById(val.parent),
                        });
                    }
                    const parent = mindmapNodeMap.get(val.parent);
                    parent.children.push(node);
                    node.parent = parent;
                }
            });
            mindmapNodeMap.forEach(node => {
                node.children.sort((a, b) => a.detail.index === b.detail.index
                    ? 0
                    : a.detail.index > b.detail.index
                        ? 1
                        : -1);
            });
            if (!rootNode) {
                return;
            }
            const loops = findInfiniteLoop(rootNode, mindmapNodeMap);
            if (loops.length) {
                this.surface.doc.withoutTransact(() => {
                    loops.forEach(loop => {
                        if (loop.detached) {
                            loop.chain.forEach(node => {
                                this.children.delete(node.id);
                            });
                        }
                        else {
                            const child = last(loop.chain);
                            if (child) {
                                this.children.set(child.id, {
                                    index: child.detail.index,
                                });
                            }
                        }
                    });
                });
                return;
            }
            this._nodeMap = mindmapNodeMap;
            this._tree = rootNode;
            if (this.layoutType === LayoutType.BALANCE) {
                this._cfgBalanceLayoutDir();
            }
            else {
                this._tree[this.layoutType === LayoutType.RIGHT ? 'right' : 'left'] =
                    this._tree.children;
            }
        }
        /**
         *
         * @param subtree The subtree of root, this only take effects when the layout type is BALANCED.
         * @returns
         */
        getChildNodes(id, subtree) {
            const node = this._nodeMap.get(id);
            if (!node) {
                return [];
            }
            if (subtree && id === this._tree.id) {
                return this._tree[subtree];
            }
            return node.children;
        }
        /**
         * Get all the connectors start from the given node
         * @param node
         * @returns
         */
        getConnectors(node) {
            if (!this._nodeMap.has(node.id)) {
                return null;
            }
            if (node.detail.collapsed) {
                const id = `#${node.id}-collapsed`;
                const layout = this.getLayoutDir(node);
                const connector = this.connectors.get(id) ?? new LocalConnectorElementModel(this.surface);
                const connectorExist = this.connectors.has(id);
                const connectorStyle = this.styleGetter.getNodeStyle(node, this.getPath(node).concat([0])).connector;
                const outdated = this._isConnectorOutdated({
                    connector,
                    from: node,
                    collapsed: true,
                    layout,
                });
                if (!connectorExist) {
                    connector.id = id;
                    this.connectors.set(id, connector);
                }
                if (outdated) {
                    const nodeBound = node.element.elementBound;
                    connector.id = id;
                    connector.source = {
                        id: node.id,
                        position: layout === LayoutType.LEFT ? [0, 0.5] : [1, 0.5],
                    };
                    connector.target = {
                        position: layout === LayoutType.LEFT
                            ? [nodeBound.x - 6, nodeBound.y + nodeBound.h / 2]
                            : [nodeBound.x + nodeBound.w + 6, nodeBound.y + nodeBound.h / 2],
                    };
                    Object.entries(connectorStyle).forEach(([key, value]) => {
                        // @ts-ignore
                        connector[key] = value;
                    });
                    connector.mode = ConnectorMode.Straight;
                }
                return [{ outdated, connector }];
            }
            else {
                const from = node;
                return from.children.map(to => {
                    const layout = this.getLayoutDir(to);
                    const id = `#${from.id}-${to.id}`;
                    const connectorExist = this.connectors.has(id);
                    const connectorStyle = this.styleGetter.getNodeStyle(to, this.getPath(to)).connector;
                    const connector = this.connectors.get(id) ??
                        new LocalConnectorElementModel(this.surface);
                    const outdated = this._isConnectorOutdated({
                        connector,
                        from,
                        to,
                        layout,
                    });
                    if (!connectorExist) {
                        connector.id = id;
                        this.connectors.set(id, connector);
                    }
                    if (outdated) {
                        connector.source = {
                            id: from.id,
                            position: layout === LayoutType.RIGHT ? [1, 0.5] : [0, 0.5],
                        };
                        connector.target = {
                            id: to.id,
                            position: layout === LayoutType.RIGHT ? [0, 0.5] : [1, 0.5],
                        };
                        Object.entries(connectorStyle).forEach(([key, value]) => {
                            // @ts-ignore
                            connector[key] = value;
                        });
                    }
                    return { outdated, connector };
                });
            }
        }
        getLayoutDir(node) {
            node = typeof node === 'string' ? this._nodeMap.get(node) : node;
            assertType(node);
            let current = node;
            const root = this._tree;
            while (current) {
                if (current.overriddenDir !== undefined) {
                    return current.overriddenDir;
                }
                const parent = current.detail.parent
                    ? (this._nodeMap.get(current.detail.parent) ?? null)
                    : null;
                if (parent === root) {
                    return (parent.overriddenDir ??
                        (root.left.includes(current)
                            ? LayoutType.LEFT
                            : root.right.includes(current)
                                ? LayoutType.RIGHT
                                : this.layoutType));
                }
                current = parent;
            }
            return this.layoutType;
        }
        getNode(id) {
            return this._nodeMap.get(id) ?? null;
        }
        getParentNode(id) {
            const node = this.children.get(id);
            return node?.parent ? (this._nodeMap.get(node.parent) ?? null) : null;
        }
        /**
         * Path is an array of indexes that represent the path from the root node to the target node.
         * The first element of the array is always 0, which represents the root node.
         * @param element
         * @returns
         *
         * @example
         * ```ts
         * const path = mindmap.getPath('nodeId');
         * // [0, 1, 2]
         * ```
         */
        getPath(element) {
            let node = this._nodeMap.get(typeof element === 'string' ? element : element.id);
            if (!node) {
                throw new Error('Node not found');
            }
            const path = [];
            while (node && node !== this._tree) {
                const parent = this._nodeMap.get(node.detail.parent);
                path.unshift(parent.children.indexOf(node));
                node = parent;
            }
            path.unshift(0);
            return path;
        }
        getSiblingNode(id, direction = 'next', 
        /**
         * The subtree of which that the sibling node belongs to,
         * this is used when the layout type is BALANCED.
         */
        subtree) {
            const node = this._nodeMap.get(id);
            if (!node) {
                return null;
            }
            const parent = this._nodeMap.get(node.detail.parent);
            if (!parent) {
                return null;
            }
            const childrenTree = subtree && parent.id === this._tree.id
                ? this._tree[subtree]
                : parent.children;
            const idx = childrenTree.indexOf(node);
            if (idx === -1) {
                return null;
            }
            const siblingIndex = direction === 'next' ? idx + 1 : idx - 1;
            const sibling = childrenTree[siblingIndex] ?? null;
            return sibling;
        }
        includesPoint(x, y, options) {
            const bound = this.elementBound;
            bound.x -= options.responsePadding?.[0] ?? 0;
            bound.w += (options.responsePadding?.[0] ?? 0) * 2;
            bound.y -= options.responsePadding?.[1] ?? 0;
            bound.h += (options.responsePadding?.[1] ?? 0) * 2;
            return bound.containsPoint([x, y]);
        }
        layout(_tree = this.tree, _options = {
            applyStyle: true,
            calculateTreeBound: true,
            stashed: true,
        }) {
            // should be implemented by the view
            // otherwise, it would be just an empty function
            if (this._layout) {
                this._layout(_tree, _options);
            }
        }
        moveTo(targetXYWH) {
            const { x, y } = this;
            const targetPos = typeof targetXYWH === 'string' ? deserializeXYWH(targetXYWH) : targetXYWH;
            const offsetX = targetPos[0] - x;
            const offsetY = targetPos[1] - y + targetPos[3];
            this.surface.doc.transact(() => {
                this.childElements.forEach(el => {
                    const deserializedXYWH = deserializeXYWH(el.xywh);
                    el.xywh =
                        `[${deserializedXYWH[0] + offsetX},${deserializedXYWH[1] + offsetY},${deserializedXYWH[2]},${deserializedXYWH[3]}]`;
                });
            });
        }
        onCreated() {
            this.buildTree();
        }
        removeChild(element) {
            if (!this._nodeMap.has(element.id)) {
                return;
            }
            const surface = this.surface;
            const removedDescendants = [];
            const remove = (node) => {
                node.children?.forEach(child => {
                    remove(child);
                });
                this.children?.delete(node.id);
                removedDescendants.push(node.id);
            };
            surface.doc.transact(() => {
                remove(this._nodeMap.get(element.id));
            });
            queueMicrotask(() => {
                removedDescendants.forEach(id => surface.deleteElement(id));
            });
            // This transaction may not end
            // force to build the elements
            this.buildTree();
            this.requestLayout();
        }
        requestBuildTree() {
            if (this._queueBuildTree) {
                return;
            }
            this._queueBuildTree = true;
            queueMicrotask(() => {
                this.buildTree();
                this._queueBuildTree = false;
            });
        }
        requestLayout() {
            if (!this._queuedLayout) {
                this._queuedLayout = true;
                queueMicrotask(() => {
                    this.layout();
                    this._queuedLayout = false;
                });
            }
        }
        serialize() {
            const result = super.serialize();
            return result;
        }
        setLayoutMethod(layoutMethod) {
            this._layout = layoutMethod;
        }
        /**
         * Stash mind map node and its children's xywh property
         * @param node
         * @returns a function that write back the stashed xywh into yjs
         */
        stashTree(node) {
            const mindNode = typeof node === 'string' ? this.getNode(node) : node;
            if (!mindNode || this._stashedNode.has(mindNode.id)) {
                return;
            }
            const stashed = new Set();
            const traverse = (node) => {
                node.element.stash('xywh');
                stashed.add(node.element);
                if (node.children.length) {
                    node.children.forEach(child => traverse(child));
                }
            };
            traverse(mindNode);
            return () => {
                this._stashedNode.delete(mindNode.id);
                stashed.forEach(el => {
                    el.pop('xywh');
                });
            };
        }
        toggleCollapse(node, options = {}) {
            if (!this._nodeMap.has(node.id)) {
                return;
            }
            const { layout = false } = options;
            if (node && node.children.length > 0) {
                const collapsed = node.detail.collapsed ? false : true;
                const isExpand = !collapsed;
                const changeNodesVisibility = (node) => {
                    node.element.hidden = collapsed;
                    if (isExpand && node.detail.collapsed) {
                        return;
                    }
                    node.children.forEach(child => {
                        changeNodesVisibility(child);
                    });
                };
                node.children.forEach(changeNodesVisibility);
                this.surface.doc.transact(() => {
                    this.children.set(node.id, {
                        ...node.detail,
                        collapsed,
                    });
                });
            }
            if (layout) {
                this.requestLayout();
            }
        }
        traverse(callback, root = this._tree, options = {}) {
            const { stopOnCollapse = false } = options;
            const traverse = (node, parent) => {
                callback(node, parent);
                if (stopOnCollapse && node.detail.collapsed) {
                    return;
                }
                node?.children.forEach(child => {
                    traverse(child, node);
                });
            };
            if (root) {
                traverse(root, null);
            }
        }
        #children_accessor_storage;
        get children() { return this.#children_accessor_storage; }
        set children(value) { this.#children_accessor_storage = value; }
        #layoutType_accessor_storage;
        get layoutType() { return this.#layoutType_accessor_storage; }
        set layoutType(value) { this.#layoutType_accessor_storage = value; }
        #style_accessor_storage;
        get style() { return this.#style_accessor_storage; }
        set style(value) { this.#style_accessor_storage = value; }
        constructor() {
            super(...arguments);
            this._layout = null;
            this._nodeMap = new Map();
            this._queueBuildTree = false;
            this._queuedLayout = false;
            this._stashedNode = new Set();
            this.connectors = new Map();
            this.#children_accessor_storage = __runInitializers(this, _children_initializers, new DocCollection.Y.Map());
            this.#layoutType_accessor_storage = (__runInitializers(this, _children_extraInitializers), __runInitializers(this, _layoutType_initializers, LayoutType.RIGHT));
            this.#style_accessor_storage = (__runInitializers(this, _layoutType_extraInitializers), __runInitializers(this, _style_initializers, MindmapStyle.ONE));
            __runInitializers(this, _style_extraInitializers);
        }
    };
})();
export { MindmapElementModel };
//# sourceMappingURL=mindmap.js.map