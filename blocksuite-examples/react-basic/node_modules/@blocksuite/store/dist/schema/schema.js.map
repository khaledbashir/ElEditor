{"version":3,"file":"schema.js","sourceRoot":"","sources":["../../src/schema/schema.ts"],"names":[],"mappings":"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","sourcesContent":["import { minimatch } from 'minimatch';\n\nimport type { BlockSchemaType } from './base.js';\n\nimport { SCHEMA_NOT_FOUND_MESSAGE } from '../consts.js';\nimport { BlockSchema } from './base.js';\nimport { SchemaValidateError } from './error.js';\n\nexport class Schema {\n  readonly flavourSchemaMap = new Map<string, BlockSchemaType>();\n\n  validate = (\n    flavour: string,\n    parentFlavour?: string,\n    childFlavours?: string[]\n  ): void => {\n    const schema = this.flavourSchemaMap.get(flavour);\n    if (!schema) {\n      throw new SchemaValidateError(flavour, SCHEMA_NOT_FOUND_MESSAGE);\n    }\n\n    const validateChildren = () => {\n      childFlavours?.forEach(childFlavour => {\n        const childSchema = this.flavourSchemaMap.get(childFlavour);\n        if (!childSchema) {\n          throw new SchemaValidateError(childFlavour, SCHEMA_NOT_FOUND_MESSAGE);\n        }\n        this.validateSchema(childSchema, schema);\n      });\n    };\n\n    if (schema.model.role === 'root') {\n      if (parentFlavour) {\n        throw new SchemaValidateError(\n          schema.model.flavour,\n          'Root block cannot have parent.'\n        );\n      }\n\n      validateChildren();\n      return;\n    }\n\n    if (!parentFlavour) {\n      throw new SchemaValidateError(\n        schema.model.flavour,\n        'Hub/Content must have parent.'\n      );\n    }\n\n    const parentSchema = this.flavourSchemaMap.get(parentFlavour);\n    if (!parentSchema) {\n      throw new SchemaValidateError(parentFlavour, SCHEMA_NOT_FOUND_MESSAGE);\n    }\n    this.validateSchema(schema, parentSchema);\n    validateChildren();\n  };\n\n  get versions() {\n    return Object.fromEntries(\n      Array.from(this.flavourSchemaMap.values()).map(\n        (schema): [string, number] => [schema.model.flavour, schema.version]\n      )\n    );\n  }\n\n  private _matchFlavour(childFlavour: string, parentFlavour: string) {\n    return (\n      minimatch(childFlavour, parentFlavour) ||\n      minimatch(parentFlavour, childFlavour)\n    );\n  }\n\n  private _validateParent(\n    child: BlockSchemaType,\n    parent: BlockSchemaType\n  ): boolean {\n    const _childFlavour = child.model.flavour;\n    const _parentFlavour = parent.model.flavour;\n\n    const childValidFlavours = child.model.parent || ['*'];\n    const parentValidFlavours = parent.model.children || ['*'];\n\n    return parentValidFlavours.some(parentValidFlavour => {\n      return childValidFlavours.some(childValidFlavour => {\n        if (parentValidFlavour === '*' && childValidFlavour === '*') {\n          return true;\n        }\n\n        if (parentValidFlavour === '*') {\n          return this._matchFlavour(childValidFlavour, _parentFlavour);\n        }\n\n        if (childValidFlavour === '*') {\n          return this._matchFlavour(_childFlavour, parentValidFlavour);\n        }\n\n        return (\n          this._matchFlavour(_childFlavour, parentValidFlavour) &&\n          this._matchFlavour(childValidFlavour, _parentFlavour)\n        );\n      });\n    });\n  }\n\n  private _validateRole(child: BlockSchemaType, parent: BlockSchemaType) {\n    const childRole = child.model.role;\n    const parentRole = parent.model.role;\n    const childFlavour = child.model.flavour;\n    const parentFlavour = parent.model.flavour;\n\n    if (childRole === 'root') {\n      throw new SchemaValidateError(\n        childFlavour,\n        `Root block cannot have parent: ${parentFlavour}.`\n      );\n    }\n\n    if (childRole === 'hub' && parentRole === 'content') {\n      throw new SchemaValidateError(\n        childFlavour,\n        `Hub block cannot be child of content block: ${parentFlavour}.`\n      );\n    }\n\n    if (childRole === 'content' && parentRole === 'root') {\n      throw new SchemaValidateError(\n        childFlavour,\n        `Content block can only be child of hub block or itself. But get: ${parentFlavour}.`\n      );\n    }\n  }\n\n  isValid(child: string, parent: string) {\n    const childSchema = this.flavourSchemaMap.get(child);\n    const parentSchema = this.flavourSchemaMap.get(parent);\n    if (!childSchema || !parentSchema) {\n      return false;\n    }\n    try {\n      this.validateSchema(childSchema, parentSchema);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  register(blockSchema: BlockSchemaType[]) {\n    blockSchema.forEach(schema => {\n      BlockSchema.parse(schema);\n      this.flavourSchemaMap.set(schema.model.flavour, schema);\n    });\n    return this;\n  }\n\n  toJSON() {\n    return Object.fromEntries(\n      Array.from(this.flavourSchemaMap.values()).map(\n        (schema): [string, Record<string, unknown>] => [\n          schema.model.flavour,\n          {\n            role: schema.model.role,\n            parent: schema.model.parent,\n            children: schema.model.children,\n          },\n        ]\n      )\n    );\n  }\n\n  validateSchema(child: BlockSchemaType, parent: BlockSchemaType) {\n    this._validateRole(child, parent);\n\n    const relationCheckSuccess = this._validateParent(child, parent);\n\n    if (!relationCheckSuccess) {\n      throw new SchemaValidateError(\n        child.model.flavour,\n        `Block cannot have parent: ${parent.model.flavour}.`\n      );\n    }\n  }\n}\n"]}