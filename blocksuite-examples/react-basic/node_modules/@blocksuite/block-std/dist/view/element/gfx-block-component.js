var _a;
import { BlockSuiteError, ErrorCode } from '@blocksuite/global/exceptions';
import { Bound } from '@blocksuite/global/utils';
import { nothing } from 'lit';
import { GfxControllerIdentifier } from '../../gfx/identifiers.js';
import { BlockComponent } from './block-component.js';
export function isGfxBlockComponent(element) {
    return element?.[GfxElementSymbol] === true;
}
export const GfxElementSymbol = Symbol('GfxElement');
function updateTransform(element) {
    element.style.transformOrigin = '0 0';
    element.style.transform = element.getCSSTransform();
}
function handleGfxConnection(instance) {
    instance.style.position = 'absolute';
    instance.disposables.add(instance.gfx.viewport.viewportUpdated.on(() => {
        updateTransform(instance);
    }));
    instance.disposables.add(instance.doc.slots.blockUpdated.on(({ type, id }) => {
        if (id === instance.model.id && type === 'update') {
            updateTransform(instance);
        }
    }));
    updateTransform(instance);
}
export class GfxBlockComponent extends BlockComponent {
    constructor() {
        super(...arguments);
        this[_a] = true;
    }
    static { _a = GfxElementSymbol; }
    get gfx() {
        return this.std.get(GfxControllerIdentifier);
    }
    connectedCallback() {
        super.connectedCallback();
        handleGfxConnection(this);
    }
    getCSSTransform() {
        const viewport = this.gfx.viewport;
        const { translateX, translateY, zoom } = viewport;
        const bound = Bound.deserialize(this.model.xywh);
        const scaledX = bound.x * zoom;
        const scaledY = bound.y * zoom;
        const deltaX = scaledX - bound.x;
        const deltaY = scaledY - bound.y;
        return `translate(${translateX + deltaX}px, ${translateY + deltaY}px) scale(${zoom})`;
    }
    getRenderingRect() {
        const { xywh$ } = this.model;
        if (!xywh$) {
            throw new BlockSuiteError(ErrorCode.GfxBlockElementError, `Error on rendering '${this.model.flavour}': Gfx block's model should have 'xywh' property.`);
        }
        const [x, y, w, h] = JSON.parse(xywh$.value);
        return { x, y, w, h, zIndex: this.toZIndex() };
    }
    renderBlock() {
        const { x, y, w, h, zIndex } = this.getRenderingRect();
        this.style.left = `${x}px`;
        this.style.top = `${y}px`;
        this.style.width = `${w}px`;
        this.style.height = `${h}px`;
        this.style.zIndex = zIndex;
        return this.renderGfxBlock();
    }
    renderGfxBlock() {
        return nothing;
    }
    renderPageContent() {
        return nothing;
    }
    async scheduleUpdate() {
        const parent = this.parentElement;
        if (this.hasUpdated || !parent || !('scheduleUpdateChildren' in parent)) {
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            super.scheduleUpdate();
        }
        else {
            await parent.scheduleUpdateChildren(this.model.id);
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            super.scheduleUpdate();
        }
    }
    toZIndex() {
        return this.gfx.layer.getZIndex(this.model).toString() ?? '0';
    }
    updateZIndex() {
        this.style.zIndex = this.toZIndex();
    }
}
export function toGfxBlockComponent(CustomBlock) {
    var _b;
    // @ts-ignore
    return class extends CustomBlock {
        constructor() {
            super(...arguments);
            this[_b] = true;
        }
        static { _b = GfxElementSymbol; }
        get gfx() {
            return this.std.get(GfxControllerIdentifier);
        }
        connectedCallback() {
            super.connectedCallback();
            handleGfxConnection(this);
        }
        getCSSTransform() {
            const viewport = this.gfx.viewport;
            const { translateX, translateY, zoom } = viewport;
            const bound = Bound.deserialize(this.model.xywh);
            const scaledX = bound.x * zoom;
            const scaledY = bound.y * zoom;
            const deltaX = scaledX - bound.x;
            const deltaY = scaledY - bound.y;
            return `translate(${translateX + deltaX}px, ${translateY + deltaY}px) scale(${zoom})`;
        }
        getRenderingRect() {
            const { xywh$ } = this.model;
            if (!xywh$) {
                throw new BlockSuiteError(ErrorCode.GfxBlockElementError, `Error on rendering '${this.model.flavour}': Gfx block's model should have 'xywh' property.`);
            }
            const [x, y, w, h] = JSON.parse(xywh$.value);
            return { x, y, w, h, zIndex: this.toZIndex() };
        }
        renderBlock() {
            const { x, y, w, h, zIndex } = this.getRenderingRect();
            this.style.left = `${x}px`;
            this.style.top = `${y}px`;
            this.style.width = typeof w === 'number' ? `${w}px` : w;
            this.style.height = typeof h === 'number' ? `${h}px` : h;
            this.style.zIndex = zIndex;
            return this.renderGfxBlock();
        }
        renderGfxBlock() {
            return this.renderPageContent();
        }
        renderPageContent() {
            return super.renderBlock();
        }
        async scheduleUpdate() {
            const parent = this.parentElement;
            if (this.hasUpdated || !parent || !('scheduleUpdateChildren' in parent)) {
                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                super.scheduleUpdate();
            }
            else {
                await parent.scheduleUpdateChildren(this.model.id);
                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                super.scheduleUpdate();
            }
        }
        toZIndex() {
            return this.gfx.layer.getZIndex(this.model).toString() ?? '0';
        }
        updateZIndex() {
            this.style.zIndex = this.toZIndex();
        }
    };
}
//# sourceMappingURL=gfx-block-component.js.map