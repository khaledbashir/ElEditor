import { type Container } from '@blocksuite/global/di';
import { type Bound, DisposableGroup, type IVec } from '@blocksuite/global/utils';
import type { PointerEventState } from '../../event/index.js';
import type { Extension } from '../../extension/extension.js';
import type { EditorHost } from '../../view/index.js';
import type { GfxController } from '../index.js';
import type { GfxElementGeometry, PointTestOptions } from '../model/base.js';
import type { GfxPrimitiveElementModel } from '../model/surface/element-model.js';
import type { GfxLocalElementModel } from '../model/surface/local-element-model.js';
export type EventsHandlerMap = {
    click: PointerEventState;
    dblclick: PointerEventState;
    pointerdown: PointerEventState;
    pointerenter: PointerEventState;
    pointerleave: PointerEventState;
    pointermove: PointerEventState;
    pointerup: PointerEventState;
};
export type SupportedEvent = keyof EventsHandlerMap;
export declare const GfxElementModelViewExtIdentifier: import("@blocksuite/global/di").ServiceIdentifier<typeof GfxElementModelView> & ((variant: import("@blocksuite/global/di").ServiceVariant) => import("@blocksuite/global/di").ServiceIdentifier<typeof GfxElementModelView>);
export declare class GfxElementModelView<T extends GfxLocalElementModel | GfxPrimitiveElementModel = GfxPrimitiveElementModel | GfxLocalElementModel, RendererContext = object> implements GfxElementGeometry, Extension {
    readonly gfx: GfxController;
    static type: string;
    private _handlers;
    private _isConnected;
    protected disposable: DisposableGroup;
    readonly model: T;
    get isConnected(): boolean;
    get rotate(): number;
    get surface(): import("../index.js").SurfaceBlockModel;
    get type(): string;
    constructor(model: T, gfx: GfxController);
    static setup(di: Container): void;
    containsBound(bounds: Bound): boolean;
    dispatch<K extends keyof EventsHandlerMap>(event: K, evt: EventsHandlerMap[K]): void;
    getLineIntersections(start: IVec, end: IVec): import("@blocksuite/global/utils").PointLocation[] | null;
    getNearestPoint(point: IVec): IVec;
    getRelativePointLocation(relativePoint: IVec): import("@blocksuite/global/utils").PointLocation;
    includesPoint(x: number, y: number, _: PointTestOptions, __: EditorHost): boolean;
    intersectsBound(bound: Bound): boolean;
    off<K extends keyof EventsHandlerMap>(event: K, callback: (evt: EventsHandlerMap[K]) => void): void;
    on<K extends keyof EventsHandlerMap>(event: K, callback: (evt: EventsHandlerMap[K]) => void): () => void;
    once<K extends keyof EventsHandlerMap>(event: K, callback: (evt: EventsHandlerMap[K]) => void): () => void;
    onCreated(): void;
    /**
     * Called when the view is destroyed.
     * Override this method requires calling `super.onDestroyed()`.
     */
    onDestroyed(): void;
    render(_: RendererContext): void;
}
//# sourceMappingURL=view.d.ts.map