import { createIdentifier } from '@blocksuite/global/di';
import { BlockSuiteError, ErrorCode } from '@blocksuite/global/exceptions';
import { DisposableGroup, } from '@blocksuite/global/utils';
export const GfxElementModelViewExtIdentifier = createIdentifier('GfxElementModelView');
export class GfxElementModelView {
    get isConnected() {
        return this._isConnected;
    }
    get rotate() {
        return this.model.rotate;
    }
    get surface() {
        return this.model.surface;
    }
    get type() {
        return this.model.type;
    }
    constructor(model, gfx) {
        this.gfx = gfx;
        this._handlers = new Map();
        this._isConnected = true;
        this.disposable = new DisposableGroup();
        this.model = model;
        this.onCreated();
    }
    static setup(di) {
        if (!this.type) {
            throw new BlockSuiteError(ErrorCode.ValueNotExists, 'The GfxElementModelView should have a static `type` property.');
        }
        di.addImpl(GfxElementModelViewExtIdentifier(this.type), () => this);
    }
    containsBound(bounds) {
        return this.model.containsBound(bounds);
    }
    dispatch(event, evt) {
        this._handlers.get(event)?.forEach(callback => callback(evt));
    }
    getLineIntersections(start, end) {
        return this.model.getLineIntersections(start, end);
    }
    getNearestPoint(point) {
        return this.model.getNearestPoint(point);
    }
    getRelativePointLocation(relativePoint) {
        return this.model.getRelativePointLocation(relativePoint);
    }
    includesPoint(x, y, _, __) {
        return this.model.includesPoint(x, y, _, __);
    }
    intersectsBound(bound) {
        return (this.containsBound(bound) ||
            bound.points.some((point, i, points) => this.getLineIntersections(point, points[(i + 1) % points.length])));
    }
    off(event, callback) {
        if (!this._handlers.has(event)) {
            return;
        }
        const callbacks = this._handlers.get(event);
        const index = callbacks.indexOf(callback);
        if (index !== -1) {
            callbacks.splice(index, 1);
        }
    }
    on(event, callback) {
        if (!this._handlers.has(event)) {
            this._handlers.set(event, []);
        }
        this._handlers.get(event).push(callback);
        return () => this.off(event, callback);
    }
    once(event, callback) {
        const off = this.on(event, evt => {
            off();
            callback(evt);
        });
        return off;
    }
    onCreated() { }
    /**
     * Called when the view is destroyed.
     * Override this method requires calling `super.onDestroyed()`.
     */
    onDestroyed() {
        this._isConnected = false;
        this.disposable.dispose();
        this._handlers.clear();
    }
    render(_) { }
}
//# sourceMappingURL=view.js.map