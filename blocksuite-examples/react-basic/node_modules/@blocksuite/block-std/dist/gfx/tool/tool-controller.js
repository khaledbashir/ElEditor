import { BlockSuiteError, ErrorCode } from '@blocksuite/global/exceptions';
import { DisposableGroup, Slot, } from '@blocksuite/global/utils';
import { Signal } from '@preact/signals-core';
import { GfxExtension, GfxExtensionIdentifier } from '../extension.js';
import { ToolIdentifier, } from './tool.js';
const supportedEvents = [
    'dragStart',
    'dragEnd',
    'dragMove',
    'pointerMove',
    'contextMenu',
    'pointerDown',
    'pointerUp',
    'click',
    'doubleClick',
    'tripleClick',
    'pointerOut',
];
export var MouseButton;
(function (MouseButton) {
    MouseButton[MouseButton["FIFTH"] = 4] = "FIFTH";
    MouseButton[MouseButton["FOURTH"] = 3] = "FOURTH";
    MouseButton[MouseButton["MAIN"] = 0] = "MAIN";
    MouseButton[MouseButton["MIDDLE"] = 1] = "MIDDLE";
    MouseButton[MouseButton["SECONDARY"] = 2] = "SECONDARY";
})(MouseButton || (MouseButton = {}));
export const eventTarget = Symbol('eventTarget');
export class ToolController extends GfxExtension {
    constructor() {
        super(...arguments);
        this._builtInHookSlot = new Slot();
        this._disposableGroup = new DisposableGroup();
        this._toolOption$ = new Signal({});
        this._tools = new Map();
        this.currentToolName$ = new Signal();
        this.dragging$ = new Signal(false);
        /**
         * The area that is being dragged.
         * The coordinates are in browser space.
         */
        this.draggingViewArea$ = new Signal({
            startX: 0,
            startY: 0,
            x: 0,
            y: 0,
            w: 0,
            h: 0,
            endX: 0,
            endY: 0,
        });
        /**
         * The last mouse move position
         * The coordinates are in browser space
         */
        this.lastMousePos$ = new Signal({
            x: 0,
            y: 0,
        });
    }
    static { this.key = 'ToolController'; }
    get currentTool$() {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const self = this;
        return {
            get value() {
                return self._tools.get(self.currentToolName$.value);
            },
            peek() {
                return self._tools.get(self.currentToolName$.peek());
            },
        };
    }
    get currentToolOption$() {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const self = this;
        return {
            peek() {
                const option = self._toolOption$.peek();
                if (!option.type) {
                    option.type = '';
                }
                return option;
            },
            get value() {
                const option = self._toolOption$.value;
                if (!option.type) {
                    option.type = '';
                }
                return option;
            },
        };
    }
    /**
     * The area that is being dragged.
     * The coordinates are in model space.
     */
    get draggingArea$() {
        const compute = (peek) => {
            const area = peek
                ? this.draggingViewArea$.peek()
                : this.draggingViewArea$.value;
            const [startX, startY] = this.gfx.viewport.toModelCoord(area.startX, area.startY);
            const [endX, endY] = this.gfx.viewport.toModelCoord(area.endX, area.endY);
            return {
                x: Math.min(startX, endX),
                y: Math.min(startY, endY),
                w: Math.abs(endX - startX),
                h: Math.abs(endY - startY),
                startX,
                startY,
                endX,
                endY,
            };
        };
        return {
            value() {
                return compute(false);
            },
            peek() {
                return compute(true);
            },
        };
    }
    static extendGfx(gfx) {
        Object.defineProperty(gfx, 'tool', {
            get() {
                return this.std.provider.get(ToolControllerIdentifier);
            },
        });
    }
    _createBuiltInHookCtx(eventName, data) {
        const ctx = {
            prevented: false,
            slotCtx: {
                event: eventName,
                data,
                preventDefault() {
                    ctx.prevented = true;
                },
            },
        };
        return ctx;
    }
    _initializeEvents() {
        const hooks = {};
        /**
         * Invoke the hook and the tool handler.
         * @returns false if the handler is prevented by the hook
         */
        const invokeToolHandler = (evtName, evt, tool) => {
            const evtHooks = hooks[evtName];
            const stopHandler = evtHooks?.reduce((pre, hook) => {
                return pre || hook(evt) === false;
            }, false);
            tool = tool ?? this.currentTool$.peek();
            if (stopHandler) {
                return false;
            }
            try {
                tool?.[evtName](evt);
                return true;
            }
            catch (e) {
                throw new BlockSuiteError(ErrorCode.ExecutionError, `Error occurred while executing ${evtName} handler of tool "${tool?.toolName}"`, {
                    cause: e,
                });
            }
        };
        /**
         * Hook into the event lifecycle.
         * All hooks will be executed despite the current active tool.
         * This is useful for tools that need to perform some action before an event is handled.
         * @param evtName
         * @param handler
         */
        const addHook = (evtName, handler) => {
            hooks[evtName] = hooks[evtName] ?? [];
            hooks[evtName].push(handler);
            return () => {
                const idx = hooks[evtName].indexOf(handler);
                if (idx !== -1) {
                    hooks[evtName].splice(idx, 1);
                }
            };
        };
        let dragContext = null;
        this._disposableGroup.add(this.std.event.add('dragStart', ctx => {
            const evt = ctx.get('pointerState');
            if (evt.button === MouseButton.SECONDARY &&
                !this.currentTool$.peek()?.allowDragWithRightButton) {
                return;
            }
            if (evt.button === MouseButton.MIDDLE) {
                evt.raw.preventDefault();
            }
            this.dragging$.value = true;
            this.draggingViewArea$.value = {
                startX: evt.x,
                startY: evt.y,
                endX: evt.x,
                endY: evt.y,
                x: evt.x,
                y: evt.y,
                w: 0,
                h: 0,
            };
            // this means the dragEnd event is not even fired
            // so we need to manually call the dragEnd method
            if (dragContext?.tool) {
                dragContext.tool.dragEnd(evt);
                dragContext = null;
            }
            if (invokeToolHandler('dragStart', evt)) {
                dragContext = this.currentTool$.peek()
                    ? {
                        tool: this.currentTool$.peek(),
                    }
                    : null;
            }
        }));
        this._disposableGroup.add(this.std.event.add('dragMove', ctx => {
            if (!this.dragging$.peek()) {
                return;
            }
            const evt = ctx.get('pointerState');
            const draggingStart = {
                x: this.draggingArea$.peek().startX,
                y: this.draggingArea$.peek().startY,
                originX: this.draggingViewArea$.peek().startX,
                originY: this.draggingViewArea$.peek().startY,
            };
            this.draggingViewArea$.value = {
                ...this.draggingViewArea$.peek(),
                w: Math.abs(evt.x - draggingStart.originX),
                h: Math.abs(evt.y - draggingStart.originY),
                x: Math.min(evt.x, draggingStart.originX),
                y: Math.min(evt.y, draggingStart.originY),
                endX: evt.x,
                endY: evt.y,
            };
            invokeToolHandler('dragMove', evt, dragContext?.tool);
        }));
        this._disposableGroup.add(this.std.event.add('dragEnd', ctx => {
            if (!this.dragging$.peek()) {
                return;
            }
            this.dragging$.value = false;
            const evt = ctx.get('pointerState');
            if (!invokeToolHandler('dragEnd', evt, dragContext?.tool)) {
                // if the tool dragEnd is prevented by the hook, call the dragEnd method manually
                // this guarantee the dragStart and dragEnd events are always called together
                if (dragContext?.tool) {
                    dragContext.tool.dragEnd(evt);
                }
            }
            dragContext = null;
            this.draggingViewArea$.value = {
                x: 0,
                y: 0,
                startX: 0,
                startY: 0,
                endX: 0,
                endY: 0,
                w: 0,
                h: 0,
            };
        }));
        this._disposableGroup.add(this.std.event.add('pointerMove', ctx => {
            const evt = ctx.get('pointerState');
            this.lastMousePos$.value = {
                x: evt.x,
                y: evt.y,
            };
            invokeToolHandler('pointerMove', evt);
        }));
        this._disposableGroup.add(this.std.event.add('contextMenu', ctx => {
            const evt = ctx.get('defaultState');
            // when in editing mode, allow context menu to pop up
            if (this.gfx.selection.editing)
                return;
            evt.event.preventDefault();
        }));
        supportedEvents.slice(5).forEach(evtName => {
            this._disposableGroup.add(this.std.event.add(evtName, ctx => {
                const evt = ctx.get('pointerState');
                invokeToolHandler(evtName, evt);
            }));
        });
        this._builtInHookSlot.on(evt => {
            hooks[evt.event]?.forEach(hook => hook(evt));
        });
        return {
            addHook,
        };
    }
    _register(tools) {
        if (this._tools.has(tools.toolName)) {
            this._tools.get(tools.toolName)?.unmounted();
        }
        this._tools.set(tools.toolName, tools);
        tools.mounted();
    }
    get(key) {
        return this._tools.get(key);
    }
    mounted() {
        const { addHook } = this._initializeEvents();
        const eventTarget = {
            addHook,
        };
        this.std.provider.getAll(ToolIdentifier).forEach(tool => {
            // @ts-ignore
            tool['eventTarget'] = eventTarget;
            this._register(tool);
        });
    }
    setTool(toolName, ...args) {
        const option = typeof toolName === 'string' ? args[0] : toolName;
        const toolNameStr = typeof toolName === 'string'
            ? toolName
            : toolName.type;
        const beforeUpdateCtx = this._createBuiltInHookCtx('beforeToolUpdate', {
            toolName: toolNameStr,
        });
        this._builtInHookSlot.emit(beforeUpdateCtx.slotCtx);
        if (beforeUpdateCtx.prevented) {
            return;
        }
        this.gfx.selection.set({ elements: [] });
        this.currentTool$.peek()?.deactivate();
        this.currentToolName$.value = toolNameStr;
        const currentTool = this.currentTool$.peek();
        if (!currentTool) {
            throw new BlockSuiteError(ErrorCode.ValueNotExists, `Tool "${this.currentToolName$.value}" is not defined`);
        }
        currentTool.activatedOption = option ?? {};
        this._toolOption$.value = {
            ...currentTool.activatedOption,
            type: toolNameStr,
        };
        currentTool.activate(currentTool.activatedOption);
        const afterUpdateCtx = this._createBuiltInHookCtx('toolUpdate', {
            toolName: toolNameStr,
        });
        this._builtInHookSlot.emit(afterUpdateCtx.slotCtx);
    }
    unmounted() {
        this.currentTool$.peek()?.deactivate();
        this._tools.forEach(tool => {
            tool.unmounted();
            tool['disposable'].dispose();
        });
        this._builtInHookSlot.dispose();
    }
}
export const ToolControllerIdentifier = GfxExtensionIdentifier('ToolController');
//# sourceMappingURL=tool-controller.js.map