import { type IVec, type SerializedXYWH, Slot, type XYWH } from '@blocksuite/global/utils';
import { Bound, DisposableGroup, PointLocation } from '@blocksuite/global/utils';
import { type Y } from '@blocksuite/store';
import type { EditorHost } from '../../../view/index.js';
import type { GfxCompatibleInterface, GfxGroupCompatibleInterface, PointTestOptions } from '../base.js';
import type { GfxGroupModel, GfxModel } from '../model.js';
import type { SurfaceBlockModel } from './surface-model.js';
import { gfxGroupCompatibleSymbol } from '../base.js';
export type BaseElementProps = {
    index: string;
    seed: number;
    lockedBySelf?: boolean;
};
export type SerializedElement = Record<string, unknown> & {
    type: string;
    xywh: SerializedXYWH;
    id: string;
    index: string;
    lockedBySelf?: boolean;
    props: Record<string, unknown>;
};
export declare abstract class GfxPrimitiveElementModel<Props extends BaseElementProps = BaseElementProps> implements GfxCompatibleInterface {
    private _lastXYWH;
    protected _disposable: DisposableGroup;
    protected _id: string;
    protected _local: Map<string | symbol, unknown>;
    protected _onChange: (payload: {
        props: Record<string, unknown>;
        oldValues: Record<string, unknown>;
        local: boolean;
    }) => void;
    /**
     * Used to store a copy of data in the yMap.
     */
    protected _preserved: Map<string, unknown>;
    protected _stashed: Map<keyof Props | string, unknown>;
    propsUpdated: Slot<{
        key: string;
    }>;
    abstract rotate: number;
    surface: SurfaceBlockModel;
    abstract xywh: SerializedXYWH;
    yMap: Y.Map<unknown>;
    get connectable(): boolean;
    get deserializedXYWH(): XYWH;
    /**
     * The bound of the element after rotation.
     * The bound without rotation should be created by `Bound.deserialize(this.xywh)`.
     */
    get elementBound(): Bound;
    get externalBound(): Bound | null;
    get group(): GfxGroupModel | null;
    /**
     * Return the ancestor elements in order from the most recent to the earliest.
     */
    get groups(): GfxGroupModel[];
    get h(): number;
    get id(): string;
    get isConnected(): boolean;
    get responseBound(): Bound;
    abstract get type(): string;
    get w(): number;
    get x(): number;
    get y(): number;
    constructor(options: {
        id: string;
        yMap: Y.Map<unknown>;
        model: SurfaceBlockModel;
        stashedStore: Map<unknown, unknown>;
        onChange: (payload: {
            props: Record<string, unknown>;
            oldValues: Record<string, unknown>;
            local: boolean;
        }) => void;
    });
    static propsToY(props: Record<string, unknown>): Record<string, unknown>;
    containsBound(bounds: Bound): boolean;
    getLineIntersections(start: IVec, end: IVec): PointLocation[] | null;
    getNearestPoint(point: IVec): IVec;
    getRelativePointLocation(relativePoint: IVec): PointLocation;
    includesPoint(x: number, y: number, opt: PointTestOptions, __: EditorHost): boolean;
    intersectsBound(bound: Bound): boolean;
    isLocked(): boolean;
    isLockedByAncestor(): boolean;
    isLockedBySelf(): boolean;
    lock(): void;
    onCreated(): void;
    onDestroyed(): void;
    pop(prop: keyof Props | string): void;
    serialize(): SerializedElement;
    stash(prop: keyof Props | string): void;
    unlock(): void;
    accessor display: boolean;
    /**
     * In some cases, you need to draw something related to the element, but it does not belong to the element itself.
     * And it is also interactive, you can select element by clicking on it. E.g. the title of the group element.
     * In this case, we need to store this kind of external xywh in order to do hit test. This property should not be synced to the doc.
     * This property should be updated every time it gets rendered.
     */
    accessor externalXYWH: SerializedXYWH | undefined;
    accessor hidden: boolean;
    accessor index: string;
    accessor lockedBySelf: boolean | undefined;
    accessor opacity: number;
    accessor responseExtension: [number, number];
    accessor seed: number;
}
export declare abstract class GfxGroupLikeElementModel<Props extends BaseElementProps = BaseElementProps> extends GfxPrimitiveElementModel<Props> implements GfxGroupCompatibleInterface {
    private _childIds;
    private _mutex;
    abstract children: Y.Map<any>;
    [gfxGroupCompatibleSymbol]: true;
    get childElements(): GfxModel[];
    /**
     * The ids of the children. Its role is to provide a unique way to access the children.
     * You should update this field through `setChildIds` when the children are added or removed.
     */
    get childIds(): string[];
    get descendantElements(): GfxModel[];
    get xywh(): `[${number},${number},${number},${number}]`;
    set xywh(_: `[${number},${number},${number},${number}]`);
    protected _getXYWH(): Bound;
    abstract addChild(element: GfxModel): void;
    /**
     * The actual field that stores the children of the group.
     * It should be a ymap decorated with `@field`.
     */
    hasChild(element: GfxCompatibleInterface): boolean;
    /**
     * Check if the group has the given descendant.
     */
    hasDescendant(element: GfxCompatibleInterface): boolean;
    /**
     * Remove the child from the group
     */
    abstract removeChild(element: GfxCompatibleInterface): void;
    /**
     * Set the new value of the childIds
     * @param value the new value of the childIds
     * @param fromLocal if true, the change is happened in the local
     */
    setChildIds(value: string[], fromLocal: boolean): void;
}
export declare function syncElementFromY(model: GfxPrimitiveElementModel, callback: (payload: {
    props: Record<string, unknown>;
    oldValues: Record<string, unknown>;
    local: boolean;
}) => void): () => void;
//# sourceMappingURL=element-model.d.ts.map