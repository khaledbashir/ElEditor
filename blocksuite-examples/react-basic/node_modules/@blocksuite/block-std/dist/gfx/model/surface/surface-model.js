import { assertType, Slot } from '@blocksuite/global/utils';
import { BlockModel, DocCollection, nanoid } from '@blocksuite/store';
import { isGfxGroupCompatibleModel, } from '../base.js';
import { createDecoratorState } from './decorators/common.js';
import { initializeObservers, initializeWatchers } from './decorators/index.js';
import { GfxGroupLikeElementModel, GfxPrimitiveElementModel, syncElementFromY, } from './element-model.js';
export class SurfaceBlockModel extends BlockModel {
    get elementModels() {
        const models = [];
        this._elementModels.forEach(model => models.push(model.model));
        return models;
    }
    get localElementModels() {
        return this.localElements;
    }
    get registeredElementTypes() {
        return Object.keys(this._elementCtorMap);
    }
    constructor() {
        super();
        this._decoratorState = createDecoratorState();
        this._elementCtorMap = Object.create(null);
        this._elementModels = new Map();
        this._elementTypeMap = new Map();
        this._groupLikeModels = new Map();
        this._middlewares = [];
        this._surfaceBlockModel = true;
        this.elementAdded = new Slot();
        this.elementRemoved = new Slot();
        this.elementUpdated = new Slot();
        this.localElementAdded = new Slot();
        this.localElementDeleted = new Slot();
        this.localElements = new Set();
        this.localElementUpdated = new Slot();
        this.created.once(() => this._init());
    }
    _createElementFromProps(props, options) {
        const { type, id, ...rest } = props;
        if (!id) {
            throw new Error('Cannot find id in props');
        }
        const yMap = new DocCollection.Y.Map();
        const elementModel = this._createElementFromYMap(type, id, yMap, {
            ...options,
            newCreate: true,
        });
        props = this._propsToY(type, props);
        yMap.set('type', type);
        yMap.set('id', id);
        Object.keys(rest).forEach(key => {
            if (props[key] !== undefined) {
                // @ts-ignore
                elementModel.model[key] = props[key];
            }
        });
        return elementModel;
    }
    _createElementFromYMap(type, id, yMap, options) {
        const stashed = new Map();
        const Ctor = this._elementCtorMap[type];
        if (!Ctor) {
            throw new Error(`Invalid element type: ${yMap.get('type')}`);
        }
        const state = this._decoratorState;
        state.creating = true;
        state.skipField = options.skipFieldInit ?? false;
        let mounted = false;
        // @ts-ignore
        Ctor['_decoratorState'] = state;
        const elementModel = new Ctor({
            id,
            yMap,
            model: this,
            stashedStore: stashed,
            onChange: payload => mounted && options.onChange({ id, ...payload }),
        });
        // @ts-ignore
        delete Ctor['_decoratorState'];
        state.creating = false;
        state.skipField = false;
        const unmount = () => {
            mounted = false;
            elementModel.onDestroyed();
        };
        const mount = () => {
            initializeObservers(Ctor.prototype, elementModel);
            initializeWatchers(Ctor.prototype, elementModel);
            elementModel['_disposable'].add(syncElementFromY(elementModel, payload => {
                mounted &&
                    options.onChange({
                        id,
                        ...payload,
                    });
            }));
            mounted = true;
            elementModel.onCreated();
        };
        return {
            model: elementModel,
            mount,
            unmount,
        };
    }
    _initElementModels() {
        const elementsYMap = this.elements.getValue();
        const addToType = (type, model) => {
            const sameTypeElements = this._elementTypeMap.get(type) || [];
            if (sameTypeElements.indexOf(model) === -1) {
                sameTypeElements.push(model);
            }
            this._elementTypeMap.set(type, sameTypeElements);
            if (isGfxGroupCompatibleModel(model)) {
                this._groupLikeModels.set(model.id, model);
            }
        };
        const removeFromType = (type, model) => {
            const sameTypeElements = this._elementTypeMap.get(type) || [];
            const index = sameTypeElements.indexOf(model);
            if (index !== -1) {
                sameTypeElements.splice(index, 1);
            }
            if (this._groupLikeModels.has(model.id)) {
                this._groupLikeModels.delete(model.id);
            }
        };
        const onElementsMapChange = (event, transaction) => {
            const { changes, keysChanged } = event;
            const addedElements = [];
            const deletedElements = [];
            keysChanged.forEach(id => {
                const change = changes.keys.get(id);
                const element = this.elements.getValue().get(id);
                switch (change?.action) {
                    case 'add':
                        if (element) {
                            const hasModel = this._elementModels.has(id);
                            const model = hasModel
                                ? this._elementModels.get(id)
                                : this._createElementFromYMap(element.get('type'), element.get('id'), element, {
                                    onChange: payload => {
                                        this.elementUpdated.emit(payload);
                                        Object.keys(payload.props).forEach(key => {
                                            model.model.propsUpdated.emit({ key });
                                        });
                                    },
                                    skipFieldInit: true,
                                });
                            !hasModel && this._elementModels.set(id, model);
                            addToType(model.model.type, model.model);
                            addedElements.push(model);
                        }
                        break;
                    case 'delete':
                        if (this._elementModels.has(id)) {
                            const { model, unmount } = this._elementModels.get(id);
                            removeFromType(model.type, model);
                            this._elementModels.delete(id);
                            deletedElements.push({ model, unmount });
                        }
                        break;
                }
            });
            addedElements.forEach(({ mount, model }) => {
                mount();
                this.elementAdded.emit({ id: model.id, local: transaction.local });
            });
            deletedElements.forEach(({ unmount, model }) => {
                unmount();
                this.elementRemoved.emit({
                    id: model.id,
                    type: model.type,
                    model,
                    local: transaction.local,
                });
            });
        };
        elementsYMap.forEach((val, key) => {
            const model = this._createElementFromYMap(val.get('type'), val.get('id'), val, {
                onChange: payload => {
                    this.elementUpdated.emit(payload),
                        Object.keys(payload.props).forEach(key => {
                            model.model.propsUpdated.emit({ key });
                        });
                },
                skipFieldInit: true,
            });
            this._elementModels.set(key, model);
        });
        this._elementModels.forEach(({ mount, model }) => {
            addToType(model.type, model);
            mount();
        });
        Object.values(this.doc.blocks.peek()).forEach(block => {
            if (isGfxGroupCompatibleModel(block.model)) {
                this._groupLikeModels.set(block.id, block.model);
            }
        });
        elementsYMap.observe(onElementsMapChange);
        const disposable = this.doc.slots.blockUpdated.on(payload => {
            switch (payload.type) {
                case 'add':
                    if (isGfxGroupCompatibleModel(payload.model)) {
                        this._groupLikeModels.set(payload.id, payload.model);
                    }
                    break;
                case 'delete':
                    if (isGfxGroupCompatibleModel(payload.model)) {
                        this._groupLikeModels.delete(payload.id);
                    }
                    {
                        const group = this.getGroup(payload.id);
                        if (group) {
                            // eslint-disable-next-line unicorn/prefer-dom-node-remove
                            group.removeChild(payload.model);
                        }
                    }
                    break;
            }
        });
        this.deleted.on(() => {
            elementsYMap.unobserve(onElementsMapChange);
            disposable.dispose();
        });
    }
    _propsToY(type, props) {
        const ctor = this._elementCtorMap[type];
        if (!ctor) {
            throw new Error(`Invalid element type: ${type}`);
        }
        // @ts-ignore
        return (ctor.propsToY ?? GfxPrimitiveElementModel.propsToY)(props);
    }
    _watchGroupRelationChange() {
        const isGroup = (element) => element instanceof GfxGroupLikeElementModel;
        const disposable = this.elementUpdated.on(({ id, oldValues }) => {
            const element = this.getElementById(id);
            if (isGroup(element) && oldValues['childIds']) {
                if (element.childIds.length === 0) {
                    this.deleteElement(id);
                }
            }
        });
        this.deleted.on(() => {
            disposable.dispose();
        });
    }
    _extendElement(ctorMap) {
        Object.assign(this._elementCtorMap, ctorMap);
    }
    _init() {
        this._initElementModels();
        this._watchGroupRelationChange();
    }
    addElement(props) {
        if (this.doc.readonly) {
            throw new Error('Cannot add element in readonly mode');
        }
        const middlewareCtx = {
            type: 'beforeAdd',
            payload: {
                type: props.type,
                props,
            },
        };
        this._middlewares.forEach(mid => mid(middlewareCtx));
        props = middlewareCtx.payload.props;
        const id = nanoid();
        // @ts-ignore
        props.id = id;
        const elementModel = this._createElementFromProps(props, {
            onChange: payload => {
                this.elementUpdated.emit(payload);
                Object.keys(payload.props).forEach(key => {
                    elementModel.model.propsUpdated.emit({ key });
                });
            },
        });
        this._elementModels.set(id, elementModel);
        this.doc.transact(() => {
            this.elements.getValue().set(id, elementModel.model.yMap);
        });
        return id;
    }
    addLocalElement(elem) {
        this.localElements.add(elem);
        this.localElementAdded.emit(elem);
    }
    applyMiddlewares(middlewares) {
        this._middlewares = middlewares;
    }
    deleteElement(id) {
        if (this.doc.readonly) {
            throw new Error('Cannot remove element in readonly mode');
        }
        if (!this.hasElementById(id)) {
            return;
        }
        this.doc.transact(() => {
            const element = this.getElementById(id);
            const group = this.getGroup(id);
            if (element instanceof GfxGroupLikeElementModel) {
                element.childIds.forEach(childId => {
                    if (this.hasElementById(childId)) {
                        this.deleteElement(childId);
                    }
                    else if (this.doc.hasBlock(childId)) {
                        this.doc.deleteBlock(this.doc.getBlock(childId).model);
                    }
                });
            }
            // eslint-disable-next-line unicorn/prefer-dom-node-remove
            group?.removeChild(element);
            this.elements.getValue().delete(id);
        });
    }
    deleteLocalElement(elem) {
        if (this.localElements.delete(elem)) {
            this.localElementDeleted.emit(elem);
        }
    }
    dispose() {
        super.dispose();
        this.elementAdded.dispose();
        this.elementRemoved.dispose();
        this.elementUpdated.dispose();
        this._elementModels.forEach(({ unmount }) => unmount());
        this._elementModels.clear();
    }
    getElementById(id) {
        return this._elementModels.get(id)?.model ?? null;
    }
    getElementsByType(type) {
        return this._elementTypeMap.get(type) || [];
    }
    getGroup(elem) {
        elem =
            typeof elem === 'string'
                ? (this.getElementById(elem) ??
                    this.doc.getBlock(elem)?.model)
                : elem;
        if (!elem)
            return null;
        assertType(elem);
        for (const group of this._groupLikeModels.values()) {
            if (group.hasChild(elem)) {
                return group;
            }
        }
        return null;
    }
    getGroups(id) {
        const groups = [];
        const visited = new Set();
        let group = this.getGroup(id);
        while (group) {
            if (visited.has(group)) {
                console.warn('Exists a cycle in group relation');
                break;
            }
            visited.add(group);
            groups.push(group);
            group = this.getGroup(group.id);
        }
        return groups;
    }
    hasElementById(id) {
        return this._elementModels.has(id);
    }
    isGroup(element) {
        if (typeof element === 'string') {
            const el = this.getElementById(element);
            if (el)
                return isGfxGroupCompatibleModel(el);
            const blockModel = this.doc.getBlock(element)?.model;
            if (blockModel)
                return isGfxGroupCompatibleModel(blockModel);
            return false;
        }
        else {
            return isGfxGroupCompatibleModel(element);
        }
    }
    updateElement(id, props) {
        if (this.doc.readonly) {
            throw new Error('Cannot update element in readonly mode');
        }
        const elementModel = this.getElementById(id);
        if (!elementModel) {
            throw new Error(`Element ${id} is not found`);
        }
        this.doc.transact(() => {
            props = this._propsToY(elementModel.type, props);
            Object.entries(props).forEach(([key, value]) => {
                // @ts-ignore
                elementModel[key] = value;
            });
        });
    }
}
//# sourceMappingURL=surface-model.js.map