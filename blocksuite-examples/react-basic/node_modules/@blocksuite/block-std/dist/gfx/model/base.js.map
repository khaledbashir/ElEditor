{"version":3,"file":"base.js","sourceRoot":"","sources":["../../../src/gfx/model/base.ts"],"names":[],"mappings":"AAwFA;;GAEG;AACH,MAAM,CAAC,MAAM,wBAAwB,GAAG,MAAM,CAAC,oBAAoB,CAAC,CAAC;AAErE;;GAEG;AACH,MAAM,CAAC,MAAM,yBAAyB,GAAG,CACvC,GAAY,EACU,EAAE;IACxB,IAAI,OAAO,GAAG,KAAK,QAAQ,IAAI,GAAG,KAAK,IAAI;QAAE,OAAO,KAAK,CAAC;IAC1D,OAAO,CACL,wBAAwB,IAAI,GAAG,IAAI,GAAG,CAAC,wBAAwB,CAAC,KAAK,IAAI,CAC1E,CAAC;AACJ,CAAC,CAAC","sourcesContent":["import type {\n  Bound,\n  IBound,\n  IVec,\n  PointLocation,\n  SerializedXYWH,\n  XYWH,\n} from '@blocksuite/global/utils';\n\nimport type { EditorHost } from '../../view/element/lit-host.js';\nimport type { GfxGroupModel, GfxModel } from './model.js';\n\n/**\n * The methods that a graphic element should implement.\n * It is already included in the `GfxCompatibleInterface` interface.\n */\nexport interface GfxElementGeometry {\n  containsBound(bound: Bound): boolean;\n  getNearestPoint(point: IVec): IVec;\n  getLineIntersections(start: IVec, end: IVec): PointLocation[] | null;\n  getRelativePointLocation(point: IVec): PointLocation;\n  includesPoint(\n    x: number,\n    y: number,\n    options: PointTestOptions,\n    host: EditorHost\n  ): boolean;\n  intersectsBound(bound: Bound): boolean;\n}\n\n/**\n * All the model that can be rendered in graphics mode should implement this interface.\n */\nexport interface GfxCompatibleInterface extends IBound, GfxElementGeometry {\n  xywh: SerializedXYWH;\n  index: string;\n\n  /**\n   * Defines the extension of the response area beyond the element's bounding box.\n   * This tuple specifies the horizontal and vertical margins to be added to the element's bound.\n   *\n   * The first value represents the horizontal extension (added to both left and right sides),\n   * and the second value represents the vertical extension (added to both top and bottom sides).\n   *\n   * The response area is computed as:\n   * `[x - horizontal, y - vertical, w + 2 * horizontal, h + 2 * vertical]`.\n   *\n   * Example:\n   * - xywh: `[0, 0, 100, 100]`, `responseExtension: [10, 20]`\n   *   Resulting response area: `[-10, -20, 120, 140]`.\n   * - `responseExtension: [0, 0]` keeps the response area equal to the bounding box.\n   */\n  responseExtension: [number, number];\n\n  readonly group: GfxGroupCompatibleInterface | null;\n\n  readonly groups: GfxGroupCompatibleInterface[];\n\n  readonly deserializedXYWH: XYWH;\n\n  /**\n   * The bound of the element without considering the response extension.\n   */\n  readonly elementBound: Bound;\n\n  /**\n   * The bound of the element considering the response extension.\n   */\n  readonly responseBound: Bound;\n\n  /**\n   * Indicates whether the current block is explicitly locked by self.\n   * For checking the lock status of the element, use `isLocked` instead.\n   * For (un)locking the element, use `(un)lock` instead.\n   */\n  lockedBySelf?: boolean;\n\n  /**\n   * Check if the element is locked. It will check the lock status of the element and its ancestors.\n   */\n  isLocked(): boolean;\n  isLockedBySelf(): boolean;\n  isLockedByAncestor(): boolean;\n\n  lock(): void;\n  unlock(): void;\n}\n\n/**\n * The symbol to mark a model as a container.\n */\nexport const gfxGroupCompatibleSymbol = Symbol('GfxGroupCompatible');\n\n/**\n * Check if the element is a container element.\n */\nexport const isGfxGroupCompatibleModel = (\n  elm: unknown\n): elm is GfxGroupModel => {\n  if (typeof elm !== 'object' || elm === null) return false;\n  return (\n    gfxGroupCompatibleSymbol in elm && elm[gfxGroupCompatibleSymbol] === true\n  );\n};\n\n/**\n * GfxGroupCompatibleElement is a model that can contain other models.\n * It just like a group that in common graphic software.\n */\nexport interface GfxGroupCompatibleInterface extends GfxCompatibleInterface {\n  [gfxGroupCompatibleSymbol]: true;\n\n  /**\n   * All child ids of this container.\n   */\n  childIds: string[];\n\n  /**\n   * All child element models of this container.\n   * Note that the `childElements` may not contains all the children in `childIds`,\n   * because some children may not be loaded.\n   */\n  childElements: GfxModel[];\n\n  descendantElements: GfxModel[];\n\n  addChild(element: GfxCompatibleInterface): void;\n  removeChild(element: GfxCompatibleInterface): void;\n  hasChild(element: GfxCompatibleInterface): boolean;\n\n  hasDescendant(element: GfxCompatibleInterface): boolean;\n}\n\n/**\n * The options for the hit testing of a point.\n */\nexport interface PointTestOptions {\n  /**\n   * The threshold of the hit test. The unit is pixel.\n   */\n  hitThreshold?: number;\n\n  /**\n   * If true, the element bound will be used for the hit testing.\n   * By default, the response bound will be used.\n   */\n  useElementBound?: boolean;\n\n  /**\n   * The padding of the response area for each element when do the hit testing. The unit is pixel.\n   * The first value is the padding for the x-axis, and the second value is the padding for the y-axis.\n   */\n  responsePadding?: [number, number];\n\n  /**\n   * If true, the transparent area of the element will be ignored during the point inclusion test.\n   * Otherwise, the transparent area will be considered as filled area.\n   *\n   * Default is true.\n   */\n  ignoreTransparent?: boolean;\n\n  /**\n   * The zoom level of current view when do the hit testing.\n   */\n  zoom?: number;\n}\n"]}