import type { Constructor, IVec, SerializedXYWH, XYWH } from '@blocksuite/global/utils';
import { Bound, PointLocation } from '@blocksuite/global/utils';
import { BlockModel } from '@blocksuite/store';
import type { EditorHost } from '../../view/index.js';
import type { GfxCompatibleInterface, PointTestOptions } from './base.js';
import type { GfxGroupModel } from './model.js';
import type { SurfaceBlockModel } from './surface/surface-model.js';
/**
 * The props that a graphics block model should have.
 */
export type GfxCompatibleProps = {
    xywh: SerializedXYWH;
    index: string;
    lockedBySelf?: boolean;
};
/**
 * This type include the common props for the graphic block model.
 * You can use this type with Omit to define the props of a graphic block model.
 */
export type GfxCommonBlockProps = GfxCompatibleProps & {
    rotate: number;
    scale: number;
};
/**
 * The graphic block model that can be rendered in the graphics mode.
 * All the graphic block model should extend this class.
 * You can use `GfxCompatibleBlockModel` to convert a BlockModel to a subclass that extends it.
 */
export declare class GfxBlockElementModel<Props extends GfxCompatibleProps = GfxCompatibleProps> extends BlockModel<Props> implements GfxCompatibleInterface {
    private _cacheDeserKey;
    private _cacheDeserXYWH;
    private _externalXYWH;
    connectable: boolean;
    /**
     * Defines the extension of the response area beyond the element's bounding box.
     * This tuple specifies the horizontal and vertical margins to be added to the element's [x, y, width, height].
     *
     * The first value represents the horizontal extension (added to both left and right sides),
     * and the second value represents the vertical extension (added to both top and bottom sides).
     *
     * The response area is computed as:
     * `[x - horizontal, y - vertical, width + 2 * horizontal, height + 2 * vertical]`.
     *
     * Example:
     * - Bounding box: `[0, 0, 100, 100]`, `responseExtension: [10, 20]`
     *   Resulting response area: `[-10, -20, 120, 140]`.
     * - `responseExtension: [0, 0]` keeps the response area equal to the bounding box.
     */
    responseExtension: [number, number];
    rotate: number;
    get deserializedXYWH(): XYWH;
    get elementBound(): Bound;
    get externalBound(): Bound | null;
    get externalXYWH(): SerializedXYWH | undefined;
    set externalXYWH(xywh: SerializedXYWH | undefined);
    get group(): GfxGroupModel | null;
    get groups(): GfxGroupModel[];
    get h(): number;
    get responseBound(): Bound;
    get surface(): SurfaceBlockModel | null;
    get w(): number;
    get x(): number;
    get y(): number;
    containsBound(bounds: Bound): boolean;
    getLineIntersections(start: IVec, end: IVec): PointLocation[] | null;
    getNearestPoint(point: IVec): IVec;
    getRelativePointLocation(relativePoint: IVec): PointLocation;
    includesPoint(x: number, y: number, opt: PointTestOptions, __: EditorHost): boolean;
    intersectsBound(bound: Bound): boolean;
    isLocked(): boolean;
    isLockedByAncestor(): boolean;
    isLockedBySelf(): boolean;
    lock(): void;
    unlock(): void;
}
/**
 * Convert a BlockModel to a GfxBlockElementModel.
 * @param BlockModelSuperClass The BlockModel class to be converted.
 * @returns The returned class is a subclass of the GfxBlockElementModel class and the given BlockModelSuperClass.
 */
export declare function GfxCompatibleBlockModel<Props extends GfxCompatibleProps, T extends Constructor<BlockModel<Props>> = Constructor<BlockModel<Props>>>(BlockModelSuperClass: T): typeof GfxBlockElementModel<Props>;
//# sourceMappingURL=gfx-block-model.d.ts.map