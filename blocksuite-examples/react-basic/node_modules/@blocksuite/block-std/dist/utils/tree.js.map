{"version":3,"file":"tree.js","sourceRoot":"","sources":["../../src/utils/tree.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Doc } from '@blocksuite/store';\n\nimport type { GfxGroupModel, GfxModel } from '../gfx/model/model.js';\n\nimport {\n  type GfxCompatibleInterface,\n  type GfxGroupCompatibleInterface,\n  isGfxGroupCompatibleModel,\n} from '../gfx/model/base.js';\n\n/**\n * Get the top elements from the list of elements, which are in some tree structures.\n *\n * For example: a list `[G1, E1, G2, E2, E3, E4, G4, E5, E6]`,\n * and they are in the elements tree like:\n * ```\n *     G1         G4      E6\n *    /  \\        |\n *  E1   G2       E5\n *       / \\\n *      E2  G3*\n *         / \\\n *        E3 E4\n * ```\n * where the star symbol `*` denote it is not in the list.\n *\n * The result should be `[G1, G4, E6]`\n */\nexport function getTopElements(elements: GfxModel[]): GfxModel[] {\n  const results = new Set(elements);\n\n  elements = [...new Set(elements)];\n\n  elements.forEach(e1 => {\n    elements.forEach(e2 => {\n      if (isGfxGroupCompatibleModel(e1) && e1.hasDescendant(e2)) {\n        results.delete(e2);\n      }\n    });\n  });\n\n  return [...results];\n}\n\nfunction traverse(\n  element: GfxModel,\n  preCallback?: (element: GfxModel) => void | boolean,\n  postCallBack?: (element: GfxModel) => void\n) {\n  // avoid infinite loop caused by circular reference\n  const visited = new Set<GfxModel>();\n\n  const innerTraverse = (element: GfxModel) => {\n    if (visited.has(element)) return;\n    visited.add(element);\n\n    if (preCallback) {\n      const interrupt = preCallback(element);\n      if (interrupt) return;\n    }\n\n    if (isGfxGroupCompatibleModel(element)) {\n      element.childElements.forEach(child => {\n        innerTraverse(child);\n      });\n    }\n\n    postCallBack && postCallBack(element);\n  };\n\n  innerTraverse(element);\n}\n\nexport function descendantElementsImpl(\n  container: GfxGroupCompatibleInterface\n): GfxModel[] {\n  const results: GfxModel[] = [];\n  container.childElements.forEach(child => {\n    traverse(child, element => {\n      results.push(element);\n    });\n  });\n  return results;\n}\n\nexport function hasDescendantElementImpl(\n  container: GfxGroupCompatibleInterface,\n  element: GfxCompatibleInterface\n): boolean {\n  let _container = element.group;\n  while (_container) {\n    if (_container === container) return true;\n    _container = _container.group;\n  }\n  return false;\n}\n\n/**\n * This checker is used to prevent circular reference, when adding a child element to a container.\n */\nexport function canSafeAddToContainer(\n  container: GfxGroupModel,\n  element: GfxCompatibleInterface\n) {\n  if (\n    element === container ||\n    (isGfxGroupCompatibleModel(element) && element.hasDescendant(container))\n  ) {\n    return false;\n  }\n  return true;\n}\n\nexport function isLockedByAncestorImpl(\n  element: GfxCompatibleInterface\n): boolean {\n  return element.groups.some(isLockedBySelfImpl);\n}\n\nexport function isLockedBySelfImpl(element: GfxCompatibleInterface): boolean {\n  return element.lockedBySelf ?? false;\n}\n\nexport function isLockedImpl(element: GfxCompatibleInterface): boolean {\n  return isLockedBySelfImpl(element) || isLockedByAncestorImpl(element);\n}\n\nexport function lockElementImpl(doc: Doc, element: GfxCompatibleInterface) {\n  doc.transact(() => {\n    element.lockedBySelf = true;\n  });\n}\n\nexport function unlockElementImpl(doc: Doc, element: GfxCompatibleInterface) {\n  doc.transact(() => {\n    element.lockedBySelf = false;\n  });\n}\n"]}