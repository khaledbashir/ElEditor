var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
import { isPeekable, Peekable } from '@blocksuite/affine-components/peek';
import { REFERENCE_NODE, RefNodeSlotsProvider, } from '@blocksuite/affine-components/rich-text';
import { EMBED_CARD_HEIGHT, EMBED_CARD_WIDTH, } from '@blocksuite/affine-shared/consts';
import { DocDisplayMetaProvider, DocModeProvider, ThemeProvider, } from '@blocksuite/affine-shared/services';
import { cloneReferenceInfo, cloneReferenceInfoWithoutAliases, matchFlavours, referenceToNode, } from '@blocksuite/affine-shared/utils';
import { Bound } from '@blocksuite/global/utils';
import { DocCollection } from '@blocksuite/store';
import { computed } from '@preact/signals-core';
import { html, nothing } from 'lit';
import { property, queryAsync, state } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
import { styleMap } from 'lit/directives/style-map.js';
import { when } from 'lit/directives/when.js';
import { EmbedBlockComponent } from '../common/embed-block-element.js';
import { renderLinkedDocInCard } from '../common/render-linked-doc.js';
import { SyncedDocErrorIcon } from '../embed-synced-doc-block/styles.js';
import { EmbedLinkedDocBlockConfigIdentifier, } from './embed-linked-doc-config.js';
import { styles } from './styles.js';
import { getEmbedLinkedDocIcons } from './utils.js';
let EmbedLinkedDocBlockComponent = (() => {
    let _classDecorators = [Peekable({
            enableOn: ({ doc }) => !doc.readonly,
        })];
    let _classDescriptor;
    let _classExtraInitializers = [];
    let _classThis;
    let _classSuper = EmbedBlockComponent;
    let __docUpdatedAt_decorators;
    let __docUpdatedAt_initializers = [];
    let __docUpdatedAt_extraInitializers = [];
    let __linkedDocMode_decorators;
    let __linkedDocMode_initializers = [];
    let __linkedDocMode_extraInitializers = [];
    let __loading_decorators;
    let __loading_initializers = [];
    let __loading_extraInitializers = [];
    let __referenceToNode_decorators;
    let __referenceToNode_initializers = [];
    let __referenceToNode_extraInitializers = [];
    let _isBannerEmpty_decorators;
    let _isBannerEmpty_initializers = [];
    let _isBannerEmpty_extraInitializers = [];
    let _isError_decorators;
    let _isError_initializers = [];
    let _isError_extraInitializers = [];
    let _isNoteContentEmpty_decorators;
    let _isNoteContentEmpty_initializers = [];
    let _isNoteContentEmpty_extraInitializers = [];
    let _noteContainer_decorators;
    let _noteContainer_initializers = [];
    let _noteContainer_extraInitializers = [];
    var EmbedLinkedDocBlockComponent = class extends _classSuper {
        static { _classThis = this; }
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            __docUpdatedAt_decorators = [state()];
            __linkedDocMode_decorators = [state()];
            __loading_decorators = [state()];
            __referenceToNode_decorators = [state()];
            _isBannerEmpty_decorators = [property({ attribute: false })];
            _isError_decorators = [property({ attribute: false })];
            _isNoteContentEmpty_decorators = [property({ attribute: false })];
            _noteContainer_decorators = [queryAsync('.affine-embed-linked-doc-content-note.render')];
            __esDecorate(this, null, __docUpdatedAt_decorators, { kind: "accessor", name: "_docUpdatedAt", static: false, private: false, access: { has: obj => "_docUpdatedAt" in obj, get: obj => obj._docUpdatedAt, set: (obj, value) => { obj._docUpdatedAt = value; } }, metadata: _metadata }, __docUpdatedAt_initializers, __docUpdatedAt_extraInitializers);
            __esDecorate(this, null, __linkedDocMode_decorators, { kind: "accessor", name: "_linkedDocMode", static: false, private: false, access: { has: obj => "_linkedDocMode" in obj, get: obj => obj._linkedDocMode, set: (obj, value) => { obj._linkedDocMode = value; } }, metadata: _metadata }, __linkedDocMode_initializers, __linkedDocMode_extraInitializers);
            __esDecorate(this, null, __loading_decorators, { kind: "accessor", name: "_loading", static: false, private: false, access: { has: obj => "_loading" in obj, get: obj => obj._loading, set: (obj, value) => { obj._loading = value; } }, metadata: _metadata }, __loading_initializers, __loading_extraInitializers);
            __esDecorate(this, null, __referenceToNode_decorators, { kind: "accessor", name: "_referenceToNode", static: false, private: false, access: { has: obj => "_referenceToNode" in obj, get: obj => obj._referenceToNode, set: (obj, value) => { obj._referenceToNode = value; } }, metadata: _metadata }, __referenceToNode_initializers, __referenceToNode_extraInitializers);
            __esDecorate(this, null, _isBannerEmpty_decorators, { kind: "accessor", name: "isBannerEmpty", static: false, private: false, access: { has: obj => "isBannerEmpty" in obj, get: obj => obj.isBannerEmpty, set: (obj, value) => { obj.isBannerEmpty = value; } }, metadata: _metadata }, _isBannerEmpty_initializers, _isBannerEmpty_extraInitializers);
            __esDecorate(this, null, _isError_decorators, { kind: "accessor", name: "isError", static: false, private: false, access: { has: obj => "isError" in obj, get: obj => obj.isError, set: (obj, value) => { obj.isError = value; } }, metadata: _metadata }, _isError_initializers, _isError_extraInitializers);
            __esDecorate(this, null, _isNoteContentEmpty_decorators, { kind: "accessor", name: "isNoteContentEmpty", static: false, private: false, access: { has: obj => "isNoteContentEmpty" in obj, get: obj => obj.isNoteContentEmpty, set: (obj, value) => { obj.isNoteContentEmpty = value; } }, metadata: _metadata }, _isNoteContentEmpty_initializers, _isNoteContentEmpty_extraInitializers);
            __esDecorate(this, null, _noteContainer_decorators, { kind: "accessor", name: "noteContainer", static: false, private: false, access: { has: obj => "noteContainer" in obj, get: obj => obj.noteContainer, set: (obj, value) => { obj.noteContainer = value; } }, metadata: _metadata }, _noteContainer_initializers, _noteContainer_extraInitializers);
            __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
            EmbedLinkedDocBlockComponent = _classThis = _classDescriptor.value;
            if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        static { this.styles = styles; }
        get config() {
            return (this.std.provider.getOptional(EmbedLinkedDocBlockConfigIdentifier) || {});
        }
        get docTitle() {
            return this.model.title || this.linkedDoc?.meta?.title || 'Untitled';
        }
        get editorMode() {
            return this._linkedDocMode;
        }
        get linkedDoc() {
            return this.std.collection.getDoc(this.model.pageId);
        }
        _handleDoubleClick(event) {
            if (this.config.handleDoubleClick) {
                this.config.handleDoubleClick(event, this.host, this.referenceInfo$.peek());
                if (event.defaultPrevented) {
                    return;
                }
            }
            if (isPeekable(this)) {
                return;
            }
            event.stopPropagation();
            this.open();
        }
        _isDocEmpty() {
            const linkedDoc = this.linkedDoc;
            if (!linkedDoc) {
                return false;
            }
            return !!linkedDoc && this.isNoteContentEmpty && this.isBannerEmpty;
        }
        _handleClick(event) {
            if (this.config.handleClick) {
                this.config.handleClick(event, this.host, this.referenceInfo$.peek());
                if (event.defaultPrevented) {
                    return;
                }
            }
            this._selectBlock();
        }
        connectedCallback() {
            super.connectedCallback();
            this._cardStyle = this.model.style;
            this._referenceToNode = referenceToNode(this.model);
            this._load().catch(e => {
                console.error(e);
                this.isError = true;
            });
            const linkedDoc = this.linkedDoc;
            if (linkedDoc) {
                this.disposables.add(linkedDoc.collection.meta.docMetaUpdated.on(() => {
                    this._load().catch(e => {
                        console.error(e);
                        this.isError = true;
                    });
                }));
                this.disposables.add(linkedDoc.slots.blockUpdated.on(payload => {
                    if (payload.type === 'update' &&
                        ['', 'caption', 'xywh'].includes(payload.props.key)) {
                        return;
                    }
                    if (payload.type === 'add' && payload.init) {
                        return;
                    }
                    this._load().catch(e => {
                        console.error(e);
                        this.isError = true;
                    });
                }));
                this._setDocUpdatedAt();
                this.disposables.add(this.doc.collection.meta.docMetaUpdated.on(() => {
                    this._setDocUpdatedAt();
                }));
                if (this._referenceToNode) {
                    this._linkedDocMode = this.model.params?.mode ?? 'page';
                }
                else {
                    const docMode = this.std.get(DocModeProvider);
                    this._linkedDocMode = docMode.getPrimaryMode(this.model.pageId);
                    this.disposables.add(docMode.onPrimaryModeChange(mode => {
                        this._linkedDocMode = mode;
                    }, this.model.pageId));
                }
            }
            this.disposables.add(this.model.propsUpdated.on(({ key }) => {
                if (key === 'style') {
                    this._cardStyle = this.model.style;
                }
                if (key === 'pageId' || key === 'style') {
                    this._load().catch(e => {
                        console.error(e);
                        this.isError = true;
                    });
                }
            }));
        }
        getInitialState() {
            return {};
        }
        renderBlock() {
            const linkedDoc = this.linkedDoc;
            const isDeleted = !linkedDoc;
            const isLoading = this._loading;
            const isError = this.isError;
            const isEmpty = this._isDocEmpty() && this.isBannerEmpty;
            const inCanvas = matchFlavours(this.model.parent, ['affine:surface']);
            const cardClassMap = classMap({
                loading: isLoading,
                error: isError,
                deleted: isDeleted,
                empty: isEmpty,
                'banner-empty': this.isBannerEmpty,
                'note-empty': this.isNoteContentEmpty,
                'in-canvas': inCanvas,
                [this._cardStyle]: true,
            });
            const theme = this.std.get(ThemeProvider).theme;
            const { LoadingIcon, ReloadIcon, LinkedDocDeletedBanner, LinkedDocEmptyBanner, SyncedDocErrorBanner, } = getEmbedLinkedDocIcons(theme, this._linkedDocMode, this._cardStyle);
            const icon = isError
                ? SyncedDocErrorIcon
                : isLoading
                    ? LoadingIcon
                    : this.icon$.value;
            const title = isLoading ? 'Loading...' : this.title$;
            const description = this.model.description$;
            const showDefaultNoteContent = isError || isLoading || isDeleted || isEmpty;
            const defaultNoteContent = isError
                ? 'This linked doc failed to load.'
                : isLoading
                    ? ''
                    : isDeleted
                        ? 'This linked doc is deleted.'
                        : isEmpty
                            ? 'Preview of the doc will be displayed here.'
                            : '';
            const dateText = this._cardStyle === 'cube'
                ? this._docUpdatedAt.toLocaleTimeString()
                : this._docUpdatedAt.toLocaleString();
            const showDefaultBanner = isError || isLoading || isDeleted || isEmpty;
            const defaultBanner = isError
                ? SyncedDocErrorBanner
                : isLoading
                    ? LinkedDocEmptyBanner
                    : isDeleted
                        ? LinkedDocDeletedBanner
                        : LinkedDocEmptyBanner;
            const hasDescriptionAlias = Boolean(description.value);
            return this.renderEmbed(() => html `
        <div
          class="affine-embed-linked-doc-block ${cardClassMap}"
          style=${styleMap({
                transform: `scale(${this._scale})`,
                transformOrigin: '0 0',
            })}
          @click=${this._handleClick}
          @dblclick=${this._handleDoubleClick}
        >
          <div class="affine-embed-linked-doc-content">
            <div class="affine-embed-linked-doc-content-title">
              <div class="affine-embed-linked-doc-content-title-icon">
                ${icon}
              </div>

              <div class="affine-embed-linked-doc-content-title-text">
                ${title}
              </div>
            </div>

            ${when(hasDescriptionAlias, () => html `<div class="affine-embed-linked-doc-content-note alias">
                  ${description}
                </div>`, () => when(showDefaultNoteContent, () => html `
                    <div class="affine-embed-linked-doc-content-note default">
                      ${defaultNoteContent}
                    </div>
                  `, () => html `
                    <div
                      class="affine-embed-linked-doc-content-note render"
                    ></div>
                  `))}
            ${isError
                ? html `
                  <div class="affine-embed-linked-doc-card-content-reload">
                    <div
                      class="affine-embed-linked-doc-card-content-reload-button"
                      @click=${this.refreshData}
                    >
                      ${ReloadIcon} <span>Reload</span>
                    </div>
                  </div>
                `
                : html `
                  <div class="affine-embed-linked-doc-content-date">
                    <span>Updated</span>

                    <span>${dateText}</span>
                  </div>
                `}
          </div>

          ${showDefaultBanner
                ? html `
                <div class="affine-embed-linked-doc-banner default">
                  ${defaultBanner}
                </div>
              `
                : nothing}
        </div>
      `);
        }
        updated() {
            // update card style when linked doc deleted
            const linkedDoc = this.linkedDoc;
            const { xywh, style } = this.model;
            const bound = Bound.deserialize(xywh);
            if (linkedDoc && style === 'horizontalThin') {
                bound.w = EMBED_CARD_WIDTH.horizontal;
                bound.h = EMBED_CARD_HEIGHT.horizontal;
                this.doc.withoutTransact(() => {
                    this.doc.updateBlock(this.model, {
                        xywh: bound.serialize(),
                        style: 'horizontal',
                    });
                });
            }
            else if (!linkedDoc && style === 'horizontal') {
                bound.w = EMBED_CARD_WIDTH.horizontalThin;
                bound.h = EMBED_CARD_HEIGHT.horizontalThin;
                this.doc.withoutTransact(() => {
                    this.doc.updateBlock(this.model, {
                        xywh: bound.serialize(),
                        style: 'horizontalThin',
                    });
                });
            }
        }
        #_docUpdatedAt_accessor_storage;
        get _docUpdatedAt() { return this.#_docUpdatedAt_accessor_storage; }
        set _docUpdatedAt(value) { this.#_docUpdatedAt_accessor_storage = value; }
        #_linkedDocMode_accessor_storage;
        get _linkedDocMode() { return this.#_linkedDocMode_accessor_storage; }
        set _linkedDocMode(value) { this.#_linkedDocMode_accessor_storage = value; }
        #_loading_accessor_storage;
        get _loading() { return this.#_loading_accessor_storage; }
        set _loading(value) { this.#_loading_accessor_storage = value; }
        #_referenceToNode_accessor_storage;
        // reference to block/element
        get _referenceToNode() { return this.#_referenceToNode_accessor_storage; }
        set _referenceToNode(value) { this.#_referenceToNode_accessor_storage = value; }
        #isBannerEmpty_accessor_storage;
        get isBannerEmpty() { return this.#isBannerEmpty_accessor_storage; }
        set isBannerEmpty(value) { this.#isBannerEmpty_accessor_storage = value; }
        #isError_accessor_storage;
        get isError() { return this.#isError_accessor_storage; }
        set isError(value) { this.#isError_accessor_storage = value; }
        #isNoteContentEmpty_accessor_storage;
        get isNoteContentEmpty() { return this.#isNoteContentEmpty_accessor_storage; }
        set isNoteContentEmpty(value) { this.#isNoteContentEmpty_accessor_storage = value; }
        #noteContainer_accessor_storage;
        get noteContainer() { return this.#noteContainer_accessor_storage; }
        set noteContainer(value) { this.#noteContainer_accessor_storage = value; }
        constructor() {
            super(...arguments);
            this._load = async () => {
                const { loading = true, isError = false, isBannerEmpty = true, isNoteContentEmpty = true, } = this.getInitialState();
                this._loading = loading;
                this.isError = isError;
                this.isBannerEmpty = isBannerEmpty;
                this.isNoteContentEmpty = isNoteContentEmpty;
                if (!this._loading) {
                    return;
                }
                const linkedDoc = this.linkedDoc;
                if (!linkedDoc) {
                    this._loading = false;
                    return;
                }
                if (!linkedDoc.loaded) {
                    try {
                        linkedDoc.load();
                    }
                    catch (e) {
                        console.error(e);
                        this.isError = true;
                    }
                }
                if (!this.isError && !linkedDoc.root) {
                    await new Promise(resolve => {
                        linkedDoc.slots.rootAdded.once(() => {
                            resolve();
                        });
                    });
                }
                this._loading = false;
                // If it is a link to a block or element, the content will not be rendered.
                if (this._referenceToNode) {
                    return;
                }
                if (!this.isError) {
                    const cardStyle = this.model.style;
                    if (cardStyle === 'horizontal' || cardStyle === 'vertical') {
                        renderLinkedDocInCard(this);
                    }
                }
            };
            this._selectBlock = () => {
                const selectionManager = this.host.selection;
                const blockSelection = selectionManager.create('block', {
                    blockId: this.blockId,
                });
                selectionManager.setGroup('note', [blockSelection]);
            };
            this._setDocUpdatedAt = () => {
                const meta = this.doc.collection.meta.getDocMeta(this.model.pageId);
                if (meta) {
                    const date = meta.updatedDate || meta.createDate;
                    this._docUpdatedAt = new Date(date);
                }
            };
            this._cardStyle = 'horizontal';
            this.convertToEmbed = () => {
                if (this._referenceToNode)
                    return;
                const { doc, caption } = this.model;
                // synced doc entry controlled by awareness flag
                const isSyncedDocEnabled = doc.awarenessStore.getFlag('enable_synced_doc_block');
                if (!isSyncedDocEnabled) {
                    return;
                }
                const parent = doc.getParent(this.model);
                if (!parent) {
                    return;
                }
                const index = parent.children.indexOf(this.model);
                doc.addBlock('affine:embed-synced-doc', {
                    caption,
                    ...cloneReferenceInfoWithoutAliases(this.referenceInfo$.peek()),
                }, parent, index);
                this.std.selection.setGroup('note', []);
                doc.deleteBlock(this.model);
            };
            this.covertToInline = () => {
                const { doc } = this.model;
                const parent = doc.getParent(this.model);
                if (!parent) {
                    return;
                }
                const index = parent.children.indexOf(this.model);
                const yText = new DocCollection.Y.Text();
                yText.insert(0, REFERENCE_NODE);
                yText.format(0, REFERENCE_NODE.length, {
                    reference: {
                        type: 'LinkedPage',
                        ...this.referenceInfo$.peek(),
                    },
                });
                const text = new doc.Text(yText);
                doc.addBlock('affine:paragraph', {
                    text,
                }, parent, index);
                doc.deleteBlock(this.model);
            };
            this.referenceInfo$ = computed(() => {
                const { pageId, params, title$, description$ } = this.model;
                return cloneReferenceInfo({
                    pageId,
                    params,
                    title: title$.value,
                    description: description$.value,
                });
            });
            this.icon$ = computed(() => {
                const { pageId, params, title } = this.referenceInfo$.value;
                return this.std
                    .get(DocDisplayMetaProvider)
                    .icon(pageId, { params, title, referenced: true }).value;
            });
            this.open = () => {
                this.std
                    .getOptional(RefNodeSlotsProvider)
                    ?.docLinkClicked.emit(this.referenceInfo$.peek());
            };
            this.refreshData = () => {
                this._load().catch(e => {
                    console.error(e);
                    this.isError = true;
                });
            };
            this.title$ = computed(() => {
                const { pageId, params, title } = this.referenceInfo$.value;
                return (title ||
                    this.std
                        .get(DocDisplayMetaProvider)
                        .title(pageId, { params, title, referenced: true }));
            });
            this.#_docUpdatedAt_accessor_storage = __runInitializers(this, __docUpdatedAt_initializers, new Date());
            this.#_linkedDocMode_accessor_storage = (__runInitializers(this, __docUpdatedAt_extraInitializers), __runInitializers(this, __linkedDocMode_initializers, 'page'));
            this.#_loading_accessor_storage = (__runInitializers(this, __linkedDocMode_extraInitializers), __runInitializers(this, __loading_initializers, false));
            this.#_referenceToNode_accessor_storage = (__runInitializers(this, __loading_extraInitializers), __runInitializers(this, __referenceToNode_initializers, false));
            this.#isBannerEmpty_accessor_storage = (__runInitializers(this, __referenceToNode_extraInitializers), __runInitializers(this, _isBannerEmpty_initializers, false));
            this.#isError_accessor_storage = (__runInitializers(this, _isBannerEmpty_extraInitializers), __runInitializers(this, _isError_initializers, false));
            this.#isNoteContentEmpty_accessor_storage = (__runInitializers(this, _isError_extraInitializers), __runInitializers(this, _isNoteContentEmpty_initializers, false));
            this.#noteContainer_accessor_storage = (__runInitializers(this, _isNoteContentEmpty_extraInitializers), __runInitializers(this, _noteContainer_initializers, void 0));
            __runInitializers(this, _noteContainer_extraInitializers);
        }
        static {
            __runInitializers(_classThis, _classExtraInitializers);
        }
    };
    return EmbedLinkedDocBlockComponent = _classThis;
})();
export { EmbedLinkedDocBlockComponent };
//# sourceMappingURL=embed-linked-doc-block.js.map