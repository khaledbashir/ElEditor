import { type Signal } from '@preact/signals-core';
import type * as Y from 'yjs';
import { DisposableGroup, Slot } from '@blocksuite/global/utils';
import { type TemplateResult } from 'lit';
import type { VLine } from './components/v-line.js';
import type { DeltaInsert, InlineRange } from './types.js';
import { InlineHookService } from './services/hook.js';
import { AttributeService, DeltaService, EventService, RangeService } from './services/index.js';
import { RenderService } from './services/render.js';
import { InlineTextService } from './services/text.js';
import { type BaseTextAttributes, nativePointToTextPoint, textPointToDomPoint } from './utils/index.js';
import { getTextNodesFromElement } from './utils/text.js';
export type InlineRootElement<T extends BaseTextAttributes = BaseTextAttributes> = HTMLElement & {
    inlineEditor: InlineEditor<T>;
};
export interface InlineRangeProvider {
    inlineRange$: Signal<InlineRange | null>;
    setInlineRange(inlineRange: InlineRange | null): void;
}
export declare class InlineEditor<TextAttributes extends BaseTextAttributes = BaseTextAttributes> {
    static getTextNodesFromElement: typeof getTextNodesFromElement;
    static nativePointToTextPoint: typeof nativePointToTextPoint;
    static textPointToDomPoint: typeof textPointToDomPoint;
    readonly disposables: DisposableGroup;
    readonly attributeService: AttributeService<TextAttributes>;
    getFormat: (inlineRange: InlineRange, loose?: boolean) => TextAttributes;
    normalizeAttributes: (textAttributes?: TextAttributes | undefined) => TextAttributes | undefined;
    resetMarks: () => void;
    setAttributeRenderer: (renderer: import("./types.js").AttributeRenderer<TextAttributes>) => void;
    setAttributeSchema: (schema: import("zod").ZodType<TextAttributes, import("zod").ZodTypeDef, unknown>) => void;
    setMarks: (marks: TextAttributes) => void;
    get marks(): TextAttributes | null;
    readonly textService: InlineTextService<TextAttributes>;
    deleteText: (inlineRange: InlineRange) => void;
    formatText: (inlineRange: InlineRange, attributes: TextAttributes, options?: {
        match?: (delta: DeltaInsert, deltaInlineRange: InlineRange) => boolean;
        mode?: "replace" | "merge";
    }) => void;
    insertLineBreak: (inlineRange: InlineRange) => void;
    insertText: (inlineRange: InlineRange, text: string, attributes?: TextAttributes) => void;
    resetText: (inlineRange: InlineRange) => void;
    setText: (text: string, attributes?: TextAttributes) => void;
    readonly deltaService: DeltaService<TextAttributes>;
    getDeltaByRangeIndex: (rangeIndex: number) => DeltaInsert<TextAttributes> | null;
    getDeltasByInlineRange: (inlineRange: InlineRange) => import("./types.js").DeltaEntry<TextAttributes>[];
    mapDeltasInInlineRange: <Result>(inlineRange: InlineRange, callback: (delta: DeltaInsert<TextAttributes>, rangeIndex: number, deltaIndex: number) => Result) => Result[];
    get embedDeltas(): DeltaInsert<TextAttributes>[];
    readonly rangeService: RangeService<TextAttributes>;
    focusEnd: () => void;
    focusIndex: (index: number) => void;
    focusStart: () => void;
    getInlineRangeFromElement: (element: Element) => InlineRange | null;
    isFirstLine: (inlineRange: InlineRange | null) => boolean;
    isLastLine: (inlineRange: InlineRange | null) => boolean;
    isValidInlineRange: (inlineRange: InlineRange | null) => boolean;
    selectAll: () => void;
    syncInlineRange: (inlineRange?: InlineRange | null) => void;
    toDomRange: (inlineRange: InlineRange) => Range | null;
    toInlineRange: (range: Range) => InlineRange | null;
    getLine: (rangeIndex: InlineRange["index"]) => {
        line: VLine;
        lineIndex: number;
        rangeIndexRelatedToLine: number;
    } | null;
    getNativeRange: () => Range | null;
    getNativeSelection: () => Selection | null;
    getTextPoint: (rangeIndex: InlineRange["index"]) => import("./types.js").TextPoint | null;
    get lastStartRelativePosition(): Y.RelativePosition | null;
    get lastEndRelativePosition(): Y.RelativePosition | null;
    readonly eventService: EventService<TextAttributes>;
    get isComposing(): boolean;
    readonly renderService: RenderService<TextAttributes>;
    waitForUpdate: () => Promise<void>;
    rerenderWholeEditor: () => void;
    render: () => void;
    get rendering(): boolean;
    readonly hooksService: InlineHookService<TextAttributes>;
    get hooks(): {
        beforeinput?: ((props: import("./services/hook.js").BeforeinputHookCtx<TextAttributes>) => void) | undefined;
        compositionEnd?: ((props: import("./services/hook.js").CompositionEndHookCtx<TextAttributes>) => void) | undefined;
    };
    private _eventSource;
    get eventSource(): HTMLElement | null;
    private _isReadonly;
    get isReadonly(): boolean;
    private _mounted;
    get mounted(): boolean;
    private _rootElement;
    get rootElement(): InlineRootElement<TextAttributes>;
    private _inlineRangeProviderOverride;
    get inlineRangeProviderOverride(): boolean;
    readonly inlineRangeProvider: InlineRangeProvider;
    get inlineRange$(): Signal<InlineRange | null>;
    setInlineRange: (inlineRange: InlineRange | null) => void;
    getInlineRange: () => InlineRange | null;
    readonly slots: {
        mounted: Slot<void>;
        unmounted: Slot<void>;
        renderComplete: Slot<void>;
        textChange: Slot<void>;
        inlineRangeSync: Slot<Range | null>;
        /**
         * Corresponding to the `compositionUpdate` and `beforeInput` events, and triggered only when the `inlineRange` is not null.
         */
        inputting: Slot<void>;
        /**
         * Triggered only when the `inlineRange` is not null.
         */
        keydown: Slot<KeyboardEvent>;
    };
    readonly vLineRenderer: ((vLine: VLine) => TemplateResult) | null;
    readonly yText: Y.Text;
    get yTextDeltas(): any;
    get yTextLength(): number;
    get yTextString(): string;
    readonly isEmbed: (delta: DeltaInsert<TextAttributes>) => boolean;
    constructor(yText: InlineEditor['yText'], ops?: {
        isEmbed?: (delta: DeltaInsert<TextAttributes>) => boolean;
        hooks?: InlineHookService<TextAttributes>['hooks'];
        inlineRangeProvider?: InlineRangeProvider;
        vLineRenderer?: (vLine: VLine) => TemplateResult;
    });
    mount(rootElement: HTMLElement, eventSource?: HTMLElement, isReadonly?: boolean): void;
    unmount(): void;
    setReadonly(isReadonly: boolean): void;
    transact(fn: () => void): void;
}
//# sourceMappingURL=inline-editor.d.ts.map