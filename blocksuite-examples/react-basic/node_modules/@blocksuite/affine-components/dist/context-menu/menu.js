import { IS_MOBILE } from '@blocksuite/global/env';
import { computed, signal } from '@preact/signals-core';
import { menuButtonItems } from './button.js';
import { menuDynamicItems } from './dynamic.js';
import { MenuFocusable } from './focusable.js';
import { menuGroupItems } from './group.js';
import { menuInputItems } from './input.js';
import { MenuComponent, MobileMenuComponent } from './menu-renderer.js';
import { subMenuItems } from './sub-menu.js';
export const menu = {
    ...menuButtonItems,
    ...subMenuItems,
    ...menuInputItems,
    ...menuGroupItems,
    ...menuDynamicItems,
};
// Global menu open listeners
const menuOpenListeners = new Set();
// Add global menu open listener
export function onMenuOpen(listener) {
    menuOpenListeners.add(listener);
    // Return cleanup function
    return () => {
        menuOpenListeners.delete(listener);
    };
}
export class Menu {
    get enableSearch() {
        return true;
    }
    constructor(options) {
        this.options = options;
        this._cleanupFns = [];
        this._currentFocused$ = signal();
        this._subMenu$ = signal();
        this.closed = false;
        this.currentFocused$ = computed(() => this._currentFocused$.value);
        this.searchName$ = signal('');
        this.searchResult$ = computed(() => {
            return this.renderItems(this.options.items);
        });
        this.showSearch$ = computed(() => {
            return this.enableSearch && this.searchName$.value.length > 0;
        });
        this.menuElement = IS_MOBILE
            ? new MobileMenuComponent()
            : new MenuComponent();
        this.menuElement.menu = this;
        // Call global menu open listeners
        menuOpenListeners.forEach(listener => {
            const cleanup = listener(this);
            if (cleanup) {
                this._cleanupFns.push(cleanup);
            }
        });
    }
    close() {
        if (this.closed) {
            return;
        }
        this.closed = true;
        // Execute cleanup functions
        this._cleanupFns.forEach(cleanup => cleanup());
        this._cleanupFns = [];
        this.menuElement.remove();
        this.options.onClose?.();
    }
    closeSubMenu() {
        this._subMenu$.value?.close();
        this._subMenu$.value = undefined;
    }
    focusNext() {
        if (!this._currentFocused$.value) {
            const ele = this.menuElement.getFirstFocusableElement();
            if (ele instanceof MenuFocusable) {
                ele.focus();
            }
            return;
        }
        const list = this.menuElement
            .getFocusableElements()
            .filter(ele => ele instanceof MenuFocusable);
        const index = list.indexOf(this._currentFocused$.value);
        list[index + 1]?.focus();
    }
    focusPrev() {
        if (!this._currentFocused$.value) {
            return;
        }
        const list = this.menuElement
            .getFocusableElements()
            .filter(ele => ele instanceof MenuFocusable);
        const index = list.indexOf(this._currentFocused$.value);
        if (index === 0) {
            this._currentFocused$.value = undefined;
            return;
        }
        list[index - 1]?.focus();
    }
    focusTo(ele) {
        this.menuElement.focusTo(ele);
    }
    openSubMenu(menu) {
        this.closeSubMenu();
        this._subMenu$.value = menu;
    }
    pressEnter() {
        this._currentFocused$.value?.onPressEnter();
    }
    renderItems(items) {
        const result = [];
        for (let i = 0; i < items.length; i++) {
            const item = items[i];
            const template = item(this, result.length);
            if (template != null) {
                result.push(template);
            }
        }
        return result;
    }
    search(name) {
        return name.toLowerCase().includes(this.searchName$.value.toLowerCase());
    }
    setFocusOnly(ele) {
        this._currentFocused$.value = ele;
    }
}
//# sourceMappingURL=menu.js.map