var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
import { unsafeCSSVar, unsafeCSSVarV2 } from '@blocksuite/affine-shared/theme';
import { ShadowlessElement } from '@blocksuite/block-std';
import { IS_MOBILE } from '@blocksuite/global/env';
import { SignalWatcher, WithDisposable } from '@blocksuite/global/utils';
import { ArrowLeftBigIcon, ArrowLeftSmallIcon, CloseIcon, SearchIcon, } from '@blocksuite/icons/lit';
import { autoPlacement, autoUpdate, computePosition, offset, shift, } from '@floating-ui/dom';
import { css, html, nothing } from 'lit';
import { property } from 'lit/decorators.js';
import { createRef, ref } from 'lit/directives/ref.js';
import { styleMap } from 'lit/directives/style-map.js';
import { Menu } from './menu.js';
let MenuComponent = (() => {
    let _classSuper = SignalWatcher(WithDisposable(ShadowlessElement));
    let _menu_decorators;
    let _menu_initializers = [];
    let _menu_extraInitializers = [];
    return class MenuComponent extends _classSuper {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            _menu_decorators = [property({ attribute: false })];
            __esDecorate(this, null, _menu_decorators, { kind: "accessor", name: "menu", static: false, private: false, access: { has: obj => "menu" in obj, get: obj => obj.menu, set: (obj, value) => { obj.menu = value; } }, metadata: _metadata }, _menu_initializers, _menu_extraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        static { this.styles = css `
    affine-menu {
      font-family: var(--affine-font-family);
      display: flex;
      flex-direction: column;
      user-select: none;
      min-width: 276px;
      box-shadow: ${unsafeCSSVar('overlayPanelShadow')};
      border-radius: 4px;
      background-color: ${unsafeCSSVarV2('layer/background/overlayPanel')};
      padding: 8px;
      position: absolute;
      z-index: 999;
      gap: 8px;
      border: 0.5px solid ${unsafeCSSVarV2('layer/insideBorder/border')};
      color: ${unsafeCSSVarV2('text/primary')};
    }

    .affine-menu-search-container {
      border-radius: 4px;
      display: flex;
      align-items: center;
      padding: 4px 10px;
      gap: 8px;
      border: 1px solid ${unsafeCSSVarV2('input/border/default')};
    }

    .affine-menu-search {
      flex: 1;
      outline: none;
      font-size: 14px;
      line-height: 22px;
      border: none;
      background-color: transparent;
    }

    .affine-menu-body {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .no-results {
      font-size: 12px;
      line-height: 20px;
      color: var(--affine-text-secondary-color);
      display: flex;
      align-items: center;
      justify-content: center;
      margin-top: 8px;
    }
  `; }
        firstUpdated() {
            const input = this.searchRef.value;
            if (input) {
                requestAnimationFrame(() => {
                    this.focusInput();
                });
                const length = input.value.length;
                input.setSelectionRange(length, length);
                this.disposables.addFromEvent(input, 'keydown', e => {
                    e.stopPropagation();
                    if (e.key === 'Escape') {
                        this.menu.close();
                        return;
                    }
                    const onBack = this.menu.options.title?.onBack;
                    if (e.key === 'Backspace' && onBack && !this.menu.showSearch$.value) {
                        this.menu.close();
                        onBack(this.menu);
                        return;
                    }
                    if (e.key === 'Enter' && !e.isComposing) {
                        this.menu.pressEnter();
                        return;
                    }
                    if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        this.menu.focusPrev();
                        return;
                    }
                    if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        this.menu.focusNext();
                        return;
                    }
                });
                this.disposables.addFromEvent(input, 'copy', e => {
                    e.stopPropagation();
                });
                this.disposables.addFromEvent(input, 'cut', e => {
                    e.stopPropagation();
                });
                this.disposables.addFromEvent(this, 'click', this._clickContainer);
            }
        }
        focusInput() {
            this.searchRef.value?.focus();
        }
        focusTo(ele) {
            this.menu.setFocusOnly(ele);
            this.focusInput();
        }
        getFirstFocusableElement() {
            return this.querySelector('[data-focusable="true"]');
        }
        getFocusableElements() {
            return Array.from(this.querySelectorAll('[data-focusable="true"]'));
        }
        render() {
            const result = this.menu.renderItems(this.menu.options.items);
            return html `
      ${this.renderTitle()} ${this.renderSearch()}
      <div class="affine-menu-body">
        ${result.length === 0 && this.menu.enableSearch
                ? html ` <div class="no-results">No Results</div>`
                : ''}
        ${result}
      </div>
    `;
        }
        renderSearch() {
            const config = this.menu.options.search;
            const showSearch = this.menu.showSearch$.value || config?.placeholder;
            const searchStyle = styleMap({
                opacity: showSearch ? '1' : '0',
                height: showSearch ? undefined : '0',
                overflow: showSearch ? undefined : 'hidden',
                position: showSearch ? undefined : 'absolute',
                pointerEvents: showSearch ? undefined : 'none',
            });
            return html ` <div style=${searchStyle} class="affine-menu-search-container">
      <div
        style="font-size:20px;display:flex;align-items:center;color: var(--affine-text-secondary-color)"
      >
        ${SearchIcon()}
      </div>
      <input
        autocomplete="off"
        class="affine-menu-search"
        placeholder="${config?.placeholder ?? ''}"
        data-1p-ignore
        ${ref(this.searchRef)}
        type="text"
        value="${this.menu.searchName$.value}"
        @input="${(e) => (this.menu.searchName$.value = e.target.value)}"
      />
    </div>`;
        }
        renderTitle() {
            const title = this.menu.options.title;
            if (!title) {
                return;
            }
            return html `
      <div
        style="display:flex;align-items:center;gap: 4px;min-width: 300px;padding:3px 4px 3px 2px"
        @mouseenter="${() => this.menu.closeSubMenu()}"
      >
        ${title.onBack
                ? html ` <div
              @click="${() => {
                    title.onBack?.(this.menu);
                    this.menu.close();
                }}"
              class="dv-icon-20 dv-hover dv-pd-2 dv-round-4"
              style="display:flex;"
            >
              ${ArrowLeftBigIcon()}
            </div>`
                : nothing}
        <div
          style="flex:1;font-weight:500;font-size: 14px;line-height: 22px;color: var(--affine-text-primary-color)"
        >
          ${title.text}
        </div>
        ${title.postfix?.()}
        ${title.onClose
                ? html ` <div
              @click="${title.onClose}"
              class="dv-icon-20 dv-hover dv-pd-2 dv-round-4"
              style="display:flex;"
            >
              ${CloseIcon()}
            </div>`
                : nothing}
      </div>
    `;
        }
        #menu_accessor_storage;
        get menu() { return this.#menu_accessor_storage; }
        set menu(value) { this.#menu_accessor_storage = value; }
        constructor() {
            super(...arguments);
            this._clickContainer = (e) => {
                e.stopPropagation();
                this.focusInput();
                this.menu.closeSubMenu();
            };
            this.searchRef = createRef();
            this.#menu_accessor_storage = __runInitializers(this, _menu_initializers, void 0);
            __runInitializers(this, _menu_extraInitializers);
        }
    };
})();
export { MenuComponent };
let MobileMenuComponent = (() => {
    let _classSuper = SignalWatcher(WithDisposable(ShadowlessElement));
    let _menu_decorators;
    let _menu_initializers = [];
    let _menu_extraInitializers = [];
    return class MobileMenuComponent extends _classSuper {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            _menu_decorators = [property({ attribute: false })];
            __esDecorate(this, null, _menu_decorators, { kind: "accessor", name: "menu", static: false, private: false, access: { has: obj => "menu" in obj, get: obj => obj.menu, set: (obj, value) => { obj.menu = value; } }, metadata: _metadata }, _menu_initializers, _menu_extraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        static { this.styles = css `
    mobile-menu {
      height: 100%;
      font-family: var(--affine-font-family);
      display: flex;
      flex-direction: column;
      user-select: none;
      width: 100%;
      background-color: ${unsafeCSSVarV2('layer/background/secondary')};
      padding: calc(8px + env(safe-area-inset-top, 0px)) 8px
        calc(8px + env(safe-area-inset-bottom, 0px)) 8px;
      position: absolute;
      z-index: 999;
      color: ${unsafeCSSVarV2('text/primary')};
    }

    .mobile-menu-body {
      display: flex;
      flex-direction: column;
      padding: 24px 16px;
      gap: 16px;
      flex: 1;
      overflow-y: auto;
    }
  `; }
        focusTo(ele) {
            this.menu.setFocusOnly(ele);
        }
        getFirstFocusableElement() {
            return this.querySelector('[data-focusable="true"]');
        }
        getFocusableElements() {
            return Array.from(this.querySelectorAll('[data-focusable="true"]'));
        }
        render() {
            const result = this.menu.renderItems(this.menu.options.items);
            return html `
      ${this.renderTitle()}
      <div class="mobile-menu-body">${result}</div>
    `;
        }
        renderTitle() {
            const title = this.menu.options.title;
            return html `
      <div
        style="display:flex;align-items:center;height: 44px;"
        @mouseenter="${() => this.menu.closeSubMenu()}"
      >
        <div style="width: 50px;flex-shrink: 0;margin-left: 10px;">
          ${title?.onBack
                ? html ` <div
                @click="${() => {
                    title.onBack?.(this.menu);
                    this.menu.close();
                }}"
                style="
                display:flex;
                font-size: 24px;
                align-items:center;
"
              >
                ${ArrowLeftSmallIcon()}
              </div>`
                : nothing}
        </div>
        <div
          style="
          flex:1;
          font-size: 17px;
          font-style: normal;
          font-weight: 500;
          line-height: 22px;
          color: var(--affine-text-primary-color);
          display: flex;
          justify-content: center;
"
        >
          ${title?.text}
        </div>
        <div
          @click="${this.onClose}"
          style="
          display:flex;
          font-weight: 500;
          font-size: 17px;
          color: ${unsafeCSSVarV2('button/primary')};
          width: 50px;
          flex-shrink: 0;
          margin-right: 10px;
         "
        >
          Done
        </div>
      </div>
    `;
        }
        #menu_accessor_storage;
        get menu() { return this.#menu_accessor_storage; }
        set menu(value) { this.#menu_accessor_storage = value; }
        constructor() {
            super(...arguments);
            this.onClose = () => {
                const close = this.menu.options.title?.onClose;
                if (close) {
                    close();
                }
                else {
                    this.menu.close();
                }
            };
            this.#menu_accessor_storage = __runInitializers(this, _menu_initializers, void 0);
            __runInitializers(this, _menu_extraInitializers);
        }
    };
})();
export { MobileMenuComponent };
export const getDefaultModalRoot = (ele) => {
    const host = ele.closest('editor-host') ?? ele.closest('.data-view-popup-container');
    if (host) {
        return host;
    }
    return document.body;
};
export const createModal = (container = document.body) => {
    const div = document.createElement('div');
    div.style.pointerEvents = 'auto';
    div.style.position = 'absolute';
    div.style.left = '0';
    div.style.top = '0';
    div.style.width = '100%';
    div.style.height = '100%';
    div.style.zIndex = '1001';
    div.style.fontFamily = 'var(--affine-font-family)';
    container.append(div);
    return div;
};
export const popupTargetFromElement = (element) => {
    let rect = element.getBoundingClientRect();
    let count = 0;
    let isActive = false;
    return {
        targetRect: {
            getBoundingClientRect: () => {
                if (element.isConnected) {
                    return (rect = element.getBoundingClientRect());
                }
                return rect;
            },
        },
        root: getDefaultModalRoot(element),
        popupStart: () => {
            if (!count) {
                isActive = element.classList.contains('active');
                if (!isActive) {
                    element.classList.add('active');
                }
            }
            count++;
            return () => {
                count--;
                if (!count && !isActive) {
                    element.classList.remove('active');
                }
            };
        },
    };
};
export const createPopup = (target, content, options) => {
    const close = () => {
        modal.remove();
        options?.onClose?.();
    };
    const modal = createModal(target.root);
    autoUpdate(target.targetRect, content, () => {
        computePosition(target.targetRect, content, {
            middleware: options?.middleware ?? [shift({ crossAxis: true })],
        })
            .then(({ x, y }) => {
            Object.assign(content.style, {
                left: `${x}px`,
                top: `${y}px`,
            });
        })
            .catch(console.error);
    });
    modal.append(content);
    modal.onpointerdown = ev => {
        if (ev.target === modal) {
            close();
        }
    };
    modal.onmousedown = ev => {
        if (ev.target === modal) {
            close();
        }
    };
    modal.oncontextmenu = ev => {
        ev.preventDefault();
        if (ev.target === modal) {
            close();
        }
    };
    return close;
};
const popMobileMenu = (options) => {
    const model = createModal(document.body);
    const menu = new Menu({
        ...options,
        onClose: () => {
            closePopup();
        },
    });
    model.append(menu.menuElement);
    const closePopup = () => {
        model.remove();
        options.onClose?.();
    };
    return {
        close: () => {
            menu.close();
        },
        menu,
        reopen: () => {
            menu.close();
            popMobileMenu(options);
        },
    };
};
export const popMenu = (target, props) => {
    if (IS_MOBILE) {
        return popMobileMenu(props.options);
    }
    const popupEnd = target.popupStart();
    const onClose = () => {
        props.options.onClose?.();
        popupEnd();
        closePopup();
    };
    const menu = new Menu({
        ...props.options,
        onClose: onClose,
    });
    const closePopup = createPopup(target, menu.menuElement, {
        onClose: () => {
            menu.close();
        },
        middleware: props.middleware ?? [
            autoPlacement({
                allowedPlacements: [
                    'bottom-start',
                    'bottom-end',
                    'top-start',
                    'top-end',
                ],
            }),
            offset(4),
        ],
        container: props.container,
    });
    return {
        close: closePopup,
        menu,
        reopen: () => {
            popMenu(target, props);
        },
    };
};
export const popFilterableSimpleMenu = (target, options, onClose) => {
    popMenu(target, {
        options: {
            items: options,
            onClose,
        },
    });
};
//# sourceMappingURL=menu-renderer.js.map