{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../../src/rich-text/format/utils.ts"],"names":[],"mappings":"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","sourcesContent":["import type { AffineTextAttributes } from '@blocksuite/affine-shared/types';\nimport type { BlockModel } from '@blocksuite/store';\n\nimport {\n  BLOCK_ID_ATTR,\n  type BlockComponent,\n  type Chain,\n  type CommandKeyToData,\n  type EditorHost,\n  type InitCommandCtx,\n} from '@blocksuite/block-std';\nimport { assertExists } from '@blocksuite/global/utils';\nimport {\n  INLINE_ROOT_ATTR,\n  type InlineEditor,\n  type InlineRange,\n  type InlineRootElement,\n} from '@blocksuite/inline';\nimport { effect } from '@preact/signals-core';\n\nimport type { AffineInlineEditor } from '../inline/index.js';\n\nimport { getInlineEditorByModel } from '../dom.js';\nimport {\n  FORMAT_BLOCK_SUPPORT_FLAVOURS,\n  FORMAT_NATIVE_SUPPORT_FLAVOURS,\n  FORMAT_TEXT_SUPPORT_FLAVOURS,\n} from './consts.js';\n\nfunction getCombinedFormatFromInlineEditors(\n  inlineEditors: [AffineInlineEditor, InlineRange | null][]\n): AffineTextAttributes {\n  const formatArr: AffineTextAttributes[] = [];\n  inlineEditors.forEach(([inlineEditor, inlineRange]) => {\n    if (!inlineRange) return;\n\n    const format = inlineEditor.getFormat(inlineRange);\n    formatArr.push(format);\n  });\n\n  if (formatArr.length === 0) return {};\n\n  // format will be active only when all inline editors have the same format.\n  return formatArr.reduce((acc, cur) => {\n    const newFormat: AffineTextAttributes = {};\n    for (const key in acc) {\n      const typedKey = key as keyof AffineTextAttributes;\n      if (acc[typedKey] === cur[typedKey]) {\n        // This cast is secure because we have checked that the value of the key is the same.\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        newFormat[typedKey] = acc[typedKey] as any;\n      }\n    }\n    return newFormat;\n  });\n}\n\nfunction getSelectedInlineEditors(\n  blocks: BlockComponent[],\n  filter: (\n    inlineRoot: InlineRootElement<AffineTextAttributes>\n  ) => InlineEditor<AffineTextAttributes> | []\n) {\n  return blocks.flatMap(el => {\n    const inlineRoot = el.querySelector<\n      InlineRootElement<AffineTextAttributes>\n    >(`[${INLINE_ROOT_ATTR}]`);\n\n    if (inlineRoot) {\n      return filter(inlineRoot);\n    }\n    return [];\n  });\n}\n\nfunction handleCurrentSelection<\n  InlineOut extends BlockSuite.CommandDataName = never,\n>(\n  chain: Chain<InitCommandCtx>,\n  handler: (\n    type: 'text' | 'block' | 'native',\n    inlineEditors: InlineEditor<AffineTextAttributes>[]\n  ) => CommandKeyToData<InlineOut> | boolean | void\n) {\n  return chain.try<InlineOut>(chain => [\n    // text selection, corresponding to `formatText` command\n    chain\n      .getTextSelection()\n      .getSelectedBlocks({\n        types: ['text'],\n        filter: el => FORMAT_TEXT_SUPPORT_FLAVOURS.includes(el.model.flavour),\n      })\n      .inline<InlineOut>((ctx, next) => {\n        const { selectedBlocks } = ctx;\n        assertExists(selectedBlocks);\n\n        const selectedInlineEditors = getSelectedInlineEditors(\n          selectedBlocks,\n          inlineRoot => {\n            const inlineRange = inlineRoot.inlineEditor.getInlineRange();\n            if (!inlineRange) return [];\n            return inlineRoot.inlineEditor;\n          }\n        );\n\n        const result = handler('text', selectedInlineEditors);\n        if (!result) return false;\n        if (result === true) {\n          return next();\n        }\n        return next(result);\n      }),\n    // block selection, corresponding to `formatBlock` command\n    chain\n      .getBlockSelections()\n      .getSelectedBlocks({\n        types: ['block'],\n        filter: el => FORMAT_BLOCK_SUPPORT_FLAVOURS.includes(el.model.flavour),\n      })\n      .inline<InlineOut>((ctx, next) => {\n        const { selectedBlocks } = ctx;\n        assertExists(selectedBlocks);\n\n        const selectedInlineEditors = getSelectedInlineEditors(\n          selectedBlocks,\n          inlineRoot =>\n            inlineRoot.inlineEditor.yTextLength > 0\n              ? inlineRoot.inlineEditor\n              : []\n        );\n\n        const result = handler('block', selectedInlineEditors);\n        if (!result) return false;\n        if (result === true) {\n          return next();\n        }\n        return next(result);\n      }),\n    // native selection, corresponding to `formatNative` command\n    chain.inline<InlineOut>((ctx, next) => {\n      const selectedInlineEditors = Array.from<InlineRootElement>(\n        ctx.std.host.querySelectorAll(`[${INLINE_ROOT_ATTR}]`)\n      )\n        .filter(el => {\n          const selection = document.getSelection();\n          if (!selection || selection.rangeCount === 0) return false;\n          const range = selection.getRangeAt(0);\n\n          return range.intersectsNode(el);\n        })\n        .filter(el => {\n          const block = el.closest<BlockComponent>(`[${BLOCK_ID_ATTR}]`);\n          if (block) {\n            return FORMAT_NATIVE_SUPPORT_FLAVOURS.includes(block.model.flavour);\n          }\n          return false;\n        })\n        .map((el): AffineInlineEditor => el.inlineEditor);\n\n      const result = handler('native', selectedInlineEditors);\n      if (!result) return false;\n      if (result === true) {\n        return next();\n      }\n      return next(result);\n    }),\n  ]);\n}\n\nexport function getCombinedTextStyle(chain: Chain<InitCommandCtx>) {\n  return handleCurrentSelection<'textStyle'>(chain, (type, inlineEditors) => {\n    if (type === 'text') {\n      return {\n        textStyle: getCombinedFormatFromInlineEditors(\n          inlineEditors.map(e => [e, e.getInlineRange()])\n        ),\n      };\n    }\n    if (type === 'block') {\n      return {\n        textStyle: getCombinedFormatFromInlineEditors(\n          inlineEditors.map(e => [e, { index: 0, length: e.yTextLength }])\n        ),\n      };\n    }\n    if (type === 'native') {\n      return {\n        textStyle: getCombinedFormatFromInlineEditors(\n          inlineEditors.map(e => [e, e.getInlineRange()])\n        ),\n      };\n    }\n    return false;\n  });\n}\n\nexport function isFormatSupported(chain: Chain<InitCommandCtx>) {\n  return handleCurrentSelection(\n    chain,\n    (_type, inlineEditors) => inlineEditors.length > 0\n  );\n}\n\n// When the user selects a range, check if it matches the previous selection.\n// If it does, apply the marks from the previous selection.\n// If it does not, remove the marks from the previous selection.\nexport function clearMarksOnDiscontinuousInput(\n  inlineEditor: InlineEditor\n): void {\n  let inlineRange = inlineEditor.getInlineRange();\n  const dispose = effect(() => {\n    const r = inlineEditor.inlineRange$.value;\n    if (\n      inlineRange &&\n      r &&\n      (inlineRange.index === r.index || inlineRange.index === r.index + 1)\n    ) {\n      inlineRange = r;\n    } else {\n      inlineEditor.resetMarks();\n      dispose();\n    }\n  });\n}\n\nexport function insertContent(\n  editorHost: EditorHost,\n  model: BlockModel,\n  text: string,\n  attributes?: AffineTextAttributes\n) {\n  if (!model.text) {\n    console.error(\"Can't insert text! Text not found\");\n    return;\n  }\n  const inlineEditor = getInlineEditorByModel(editorHost, model);\n  if (!inlineEditor) {\n    console.error(\"Can't insert text! Inline editor not found\");\n    return;\n  }\n  const inlineRange = inlineEditor.getInlineRange();\n  const index = inlineRange ? inlineRange.index : model.text.length;\n  model.text.insert(text, index, attributes as Record<string, unknown>);\n  // Update the caret to the end of the inserted text\n  inlineEditor.setInlineRange({\n    index: index + text.length,\n    length: 0,\n  });\n}\n"]}