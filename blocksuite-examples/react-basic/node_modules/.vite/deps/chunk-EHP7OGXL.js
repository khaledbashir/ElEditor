import {
  external_exports
} from "./chunk-2EXQB7Q6.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-3WN6VOBL.js";

// node_modules/lodash.clonedeep/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.clonedeep/index.js"(exports, module) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_SAFE_INTEGER2 = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reFlags = /\w*$/;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    function addMapEntry(map3, pair) {
      map3.set(pair[0], pair[1]);
      return map3;
    }
    function addSetEntry(set2, value) {
      set2.add(value);
      return set2;
    }
    function arrayEach(array, iteratee) {
      var index = -1, length4 = array ? array.length : 0;
      while (++index < length4) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayPush(array, values) {
      var index = -1, length4 = values.length, offset = array.length;
      while (++index < length4) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length4 = array ? array.length : 0;
      if (initAccum && length4) {
        accumulator = array[++index];
      }
      while (++index < length4) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function baseTimes(n2, iteratee) {
      var index = -1, result = Array(n2);
      while (++index < n2) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e2) {
        }
      }
      return result;
    }
    function mapToArray(map3) {
      var index = -1, result = Array(map3.size);
      map3.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set2) {
      var index = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = (function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    })();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectCreate = Object.create;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView2 = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap2 = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView2);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index = -1, length4 = entries ? entries.length : 0;
      this.clear();
      while (++index < length4) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length4 = entries ? entries.length : 0;
      this.clear();
      while (++index < length4) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length4 = entries ? entries.length : 0;
      this.clear();
      while (++index < length4) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    function stackClear() {
      this.__data__ = new ListCache();
    }
    function stackDelete(key) {
      return this.__data__["delete"](key);
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs);
      }
      cache.set(key, value);
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray2(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length4 = result.length, skipIndexes = !!length4;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length4)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        object[key] = value;
      }
    }
    function assocIndexOf(array, key) {
      var length4 = array.length;
      while (length4--) {
        if (eq(array[length4][0], key)) {
          return length4;
        }
      }
      return -1;
    }
    function baseAssign(object, source) {
      return object && copyObject(source, keys4(source), object);
    }
    function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
      var result;
      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray2(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          if (isHostObject(value)) {
            return object ? value : {};
          }
          result = initCloneObject(isFunc ? {} : value);
          if (!isDeep) {
            return copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, baseClone, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (!isArr) {
        var props = isFull ? getAllKeys(value) : keys4(value);
      }
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result, key2, baseClone(subValue, isDeep, isFull, customizer, key2, value, stack));
      });
      return result;
    }
    function baseCreate(proto) {
      return isObject(proto) ? objectCreate(proto) : {};
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray2(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var result = new buffer.constructor(buffer.length);
      buffer.copy(result);
      return result;
    }
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    function cloneMap(map3, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(mapToArray(map3), true) : mapToArray(map3);
      return arrayReduce(array, addMapEntry, new map3.constructor());
    }
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    function cloneSet(set2, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(setToArray(set2), true) : setToArray(set2);
      return arrayReduce(array, addSetEntry, new set2.constructor());
    }
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    function copyArray(source, array) {
      var index = -1, length4 = source.length;
      array || (array = Array(length4));
      while (++index < length4) {
        array[index] = source[index];
      }
      return array;
    }
    function copyObject(source, props, object, customizer) {
      object || (object = {});
      var index = -1, length4 = props.length;
      while (++index < length4) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        assignValue(object, key, newValue === void 0 ? source[key] : newValue);
      }
      return object;
    }
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys4, getSymbols);
    }
    function getMapData(map3, key) {
      var data = map3.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function initCloneArray(array) {
      var length4 = array.length, result = array.constructor(length4);
      if (length4 && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function initCloneByTag(object, tag, cloneFunc, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
          return new Ctor(+object);
        case dataViewTag:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag:
          return cloneMap(object, isDeep, cloneFunc);
        case numberTag:
        case stringTag:
          return new Ctor(object);
        case regexpTag:
          return cloneRegExp(object);
        case setTag:
          return cloneSet(object, isDeep, cloneFunc);
        case symbolTag:
          return cloneSymbol(object);
      }
    }
    function isIndex(value, length4) {
      length4 = length4 == null ? MAX_SAFE_INTEGER2 : length4;
      return !!length4 && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length4);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e2) {
        }
        try {
          return func + "";
        } catch (e2) {
        }
      }
      return "";
    }
    function cloneDeep(value) {
      return baseClone(value, true, true);
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray2 = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function keys4(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module.exports = cloneDeep;
  }
});

// node_modules/lodash.merge/index.js
var require_lodash2 = __commonJS({
  "node_modules/lodash.merge/index.js"(exports, module) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var HOT_COUNT = 800;
    var HOT_SPAN = 16;
    var MAX_SAFE_INTEGER2 = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var asyncTag = "[object AsyncFunction]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var nullTag = "[object Null]";
    var objectTag = "[object Object]";
    var proxyTag = "[object Proxy]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var undefinedTag = "[object Undefined]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = (function() {
      try {
        var types2 = freeModule && freeModule.require && freeModule.require("util").types;
        if (types2) {
          return types2;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e2) {
      }
    })();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args2) {
      switch (args2.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args2[0]);
        case 2:
          return func.call(thisArg, args2[0], args2[1]);
        case 3:
          return func.call(thisArg, args2[0], args2[1], args2[2]);
      }
      return func.apply(thisArg, args2);
    }
    function baseTimes(n2, iteratee) {
      var index = -1, result = Array(n2);
      while (++index < n2) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var maskSrcKey = (function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    })();
    var nativeObjectToString = objectProto.toString;
    var objectCtorString = funcToString.call(Object);
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectCreate = Object.create;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    var defineProperty = (function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e2) {
      }
    })();
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var nativeMax = Math.max;
    var nativeNow = Date.now;
    var Map2 = getNative(root, "Map");
    var nativeCreate = getNative(Object, "create");
    var baseCreate = /* @__PURE__ */ (function() {
      function object() {
      }
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    })();
    function Hash(entries) {
      var index = -1, length4 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length4) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length4 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length4) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length4 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length4) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size2 = data.size;
      data.set(key, value);
      this.size += data.size == size2 ? 0 : 1;
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length4 = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length4)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assignMergeValue(object, key, value) {
      if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function assocIndexOf(array, key) {
      var length4 = array.length;
      while (length4--) {
        if (eq(array[length4][0], key)) {
          return length4;
        }
      }
      return -1;
    }
    function baseAssignValue(object, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key] = value;
      }
    }
    var baseFor = createBaseFor();
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack());
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        } else {
          var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray2(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          } else {
            newValue = [];
          }
        } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack["delete"](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + "");
    }
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string),
        "writable": true
      });
    };
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length4 = buffer.length, result = allocUnsafe ? allocUnsafe(length4) : new buffer.constructor(length4);
      buffer.copy(result);
      return result;
    }
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    function copyArray(source, array) {
      var index = -1, length4 = source.length;
      array || (array = Array(length4));
      while (++index < length4) {
        array[index] = source[index];
      }
      return array;
    }
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index = -1, length4 = props.length;
      while (++index < length4) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length4 = sources.length, customizer = length4 > 1 ? sources[length4 - 1] : void 0, guard = length4 > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length4--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length4 < 3 ? void 0 : customizer;
          length4 = 1;
        }
        object = Object(object);
        while (++index < length4) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length4 = props.length;
        while (length4--) {
          var key = props[fromRight ? length4 : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    function getMapData(map3, key) {
      var data = map3.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e2) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function isIndex(value, length4) {
      var type = typeof value;
      length4 = length4 == null ? MAX_SAFE_INTEGER2 : length4;
      return !!length4 && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length4);
    }
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    function overRest(func, start, transform) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args2 = arguments, index = -1, length4 = nativeMax(args2.length - start, 0), array = Array(length4);
        while (++index < length4) {
          array[index] = args2[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args2[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }
    function safeGet(object, key) {
      if (key === "constructor" && typeof object[key] === "function") {
        return;
      }
      if (key == "__proto__") {
        return;
      }
      return object[key];
    }
    var setToString = shortOut(baseSetToString);
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e2) {
        }
        try {
          return func + "";
        } catch (e2) {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArguments = baseIsArguments(/* @__PURE__ */ (function() {
      return arguments;
    })()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    var isArray2 = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
    }
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    var merge3 = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });
    function constant(value) {
      return function() {
        return value;
      };
    }
    function identity(value) {
      return value;
    }
    function stubFalse() {
      return false;
    }
    module.exports = merge3;
  }
});

// node_modules/lodash.ismatch/index.js
var require_lodash3 = __commonJS({
  "node_modules/lodash.ismatch/index.js"(exports, module) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var UNORDERED_COMPARE_FLAG = 1;
    var PARTIAL_COMPARE_FLAG = 2;
    var MAX_SAFE_INTEGER2 = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = (function() {
      try {
        return freeProcess && freeProcess.binding("util");
      } catch (e2) {
      }
    })();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function arraySome(array, predicate) {
      var index = -1, length4 = array ? array.length : 0;
      while (++index < length4) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    function baseTimes(n2, iteratee) {
      var index = -1, result = Array(n2);
      while (++index < n2) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e2) {
        }
      }
      return result;
    }
    function mapToArray(map3) {
      var index = -1, result = Array(map3.size);
      map3.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set2) {
      var index = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = (function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    })();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView2 = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap2 = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView2);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index = -1, length4 = entries ? entries.length : 0;
      this.clear();
      while (++index < length4) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length4 = entries ? entries.length : 0;
      this.clear();
      while (++index < length4) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length4 = entries ? entries.length : 0;
      this.clear();
      while (++index < length4) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length4 = values ? values.length : 0;
      this.__data__ = new MapCache();
      while (++index < length4) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    function stackClear() {
      this.__data__ = new ListCache();
    }
    function stackDelete(key) {
      return this.__data__["delete"](key);
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs);
      }
      cache.set(key, value);
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray2(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length4 = result.length, skipIndexes = !!length4;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length4)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array, key) {
      var length4 = array.length;
      while (length4--) {
        if (eq(array[length4][0], key)) {
          return length4;
        }
      }
      return -1;
    }
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    function baseIsEqual(value, other, customizer, bitmask, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
    }
    function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
      var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = arrayTag, othTag = arrayTag;
      if (!objIsArr) {
        objTag = getTag(object);
        objTag = objTag == argsTag ? objectTag : objTag;
      }
      if (!othIsArr) {
        othTag = getTag(other);
        othTag = othTag == argsTag ? objectTag : othTag;
      }
      var objIsObj = objTag == objectTag && !isHostObject(object), othIsObj = othTag == objectTag && !isHostObject(other), isSameTag = objTag == othTag;
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
      }
      if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
    }
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length, length4 = index, noCustomizer = !customizer;
      if (object == null) {
        return !length4;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }
      while (++index < length4) {
        data = matchData[index];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1, result = true, seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!seen.has(othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, customizer, bitmask, stack))) {
              return seen.add(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= UNORDERED_COMPARE_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys4(object), objLength = objProps.length, othProps = keys4(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    function getMapData(map3, key) {
      var data = map3.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getMatchData(object) {
      var result = keys4(object), length4 = result.length;
      while (length4--) {
        var key = result[length4], value = object[key];
        result[length4] = [key, value, isStrictComparable(value)];
      }
      return result;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function isIndex(value, length4) {
      length4 = length4 == null ? MAX_SAFE_INTEGER2 : length4;
      return !!length4 && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length4);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e2) {
        }
        try {
          return func + "";
        } catch (e2) {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray2 = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isMatch2(object, source) {
      return object === source || baseIsMatch(object, source, getMatchData(source));
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function keys4(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    module.exports = isMatch2;
  }
});

// node_modules/@blocksuite/global/dist/exceptions/code.js
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2[ErrorCode2["DefaultRuntimeError"] = 1] = "DefaultRuntimeError";
  ErrorCode2[ErrorCode2["ReactiveProxyError"] = 2] = "ReactiveProxyError";
  ErrorCode2[ErrorCode2["DocCollectionError"] = 3] = "DocCollectionError";
  ErrorCode2[ErrorCode2["ModelCRUDError"] = 4] = "ModelCRUDError";
  ErrorCode2[ErrorCode2["ValueNotExists"] = 5] = "ValueNotExists";
  ErrorCode2[ErrorCode2["ValueNotInstanceOf"] = 6] = "ValueNotInstanceOf";
  ErrorCode2[ErrorCode2["ValueNotEqual"] = 7] = "ValueNotEqual";
  ErrorCode2[ErrorCode2["MigrationError"] = 8] = "MigrationError";
  ErrorCode2[ErrorCode2["SchemaValidateError"] = 9] = "SchemaValidateError";
  ErrorCode2[ErrorCode2["TransformerError"] = 10] = "TransformerError";
  ErrorCode2[ErrorCode2["InlineEditorError"] = 11] = "InlineEditorError";
  ErrorCode2[ErrorCode2["TransformerNotImplementedError"] = 12] = "TransformerNotImplementedError";
  ErrorCode2[ErrorCode2["EdgelessExportError"] = 13] = "EdgelessExportError";
  ErrorCode2[ErrorCode2["CommandError"] = 14] = "CommandError";
  ErrorCode2[ErrorCode2["EventDispatcherError"] = 15] = "EventDispatcherError";
  ErrorCode2[ErrorCode2["SelectionError"] = 16] = "SelectionError";
  ErrorCode2[ErrorCode2["GfxBlockElementError"] = 17] = "GfxBlockElementError";
  ErrorCode2[ErrorCode2["MissingViewModelError"] = 18] = "MissingViewModelError";
  ErrorCode2[ErrorCode2["DatabaseBlockError"] = 19] = "DatabaseBlockError";
  ErrorCode2[ErrorCode2["ParsingError"] = 20] = "ParsingError";
  ErrorCode2[ErrorCode2["UserAbortError"] = 21] = "UserAbortError";
  ErrorCode2[ErrorCode2["ExecutionError"] = 22] = "ExecutionError";
  ErrorCode2[ErrorCode2["DefaultFatalError"] = 1e4] = "DefaultFatalError";
  ErrorCode2[ErrorCode2["NoRootModelError"] = 10001] = "NoRootModelError";
  ErrorCode2[ErrorCode2["NoSurfaceModelError"] = 10002] = "NoSurfaceModelError";
  ErrorCode2[ErrorCode2["NoneSupportedSSRError"] = 10003] = "NoneSupportedSSRError";
})(ErrorCode || (ErrorCode = {}));

// node_modules/@blocksuite/global/dist/exceptions/index.js
var BlockSuiteError = class extends Error {
  constructor(code, message, options) {
    super(message, options);
    this.name = "BlockSuiteError";
    this.code = code;
    this.isFatal = code >= 1e4;
  }
};
function handleError(error) {
  if (!(error instanceof BlockSuiteError)) {
    throw error;
  }
  if (error.isFatal) {
    throw new Error("A fatal error for BlockSuite occurs, please contact the team if you find this.", { cause: error });
  }
  console.error("A runtime error for BlockSuite occurs, you can ignore this error if it won't break the user experience.");
  console.error(error.stack);
}

// node_modules/@blocksuite/global/dist/utils/assert.js
function isPrimitive(a2) {
  return a2 !== Object(a2);
}
function assertType(_2) {
}
function assertExists(val, message = "val does not exist", errorCode = ErrorCode.ValueNotExists) {
  if (val === null || val === void 0) {
    if (message instanceof Error) {
      throw message;
    }
    throw new BlockSuiteError(errorCode, message);
  }
}
function isEqual(val, expected) {
  const a2 = isPrimitive(val);
  const b2 = isPrimitive(expected);
  if (a2 && b2) {
    if (!Object.is(val, expected)) {
      return false;
    }
  } else if (a2 !== b2) {
    return false;
  } else {
    if (Array.isArray(val) && Array.isArray(expected)) {
      if (val.length !== expected.length) {
        return false;
      }
      return val.every((x, i2) => isEqual(x, expected[i2]));
    } else if (typeof val === "object" && typeof expected === "object") {
      const obj1 = Object.entries(val);
      const obj2 = Object.entries(expected);
      if (obj1.length !== obj2.length) {
        return false;
      }
      return obj1.every((x, i2) => isEqual(x, obj2[i2]));
    }
  }
  return true;
}
function assertEquals(val, expected, message = "val is not same as expected", errorCode = ErrorCode.ValueNotEqual) {
  if (!isEqual(val, expected)) {
    throw new BlockSuiteError(errorCode, message);
  }
}
function assertInstanceOf(val, expected, message = "val is not instance of expected", errorCode = ErrorCode.ValueNotInstanceOf) {
  if (!(val instanceof expected)) {
    throw new BlockSuiteError(errorCode, message);
  }
}

// node_modules/@blocksuite/global/dist/utils/model/vec.js
var _Vec = class _Vec {
  static clamp(n2, min3, max2) {
    return Math.max(min3, max2 !== void 0 ? Math.min(n2, max2) : n2);
  }
  static clampV(A, min3, max2) {
    return A.map((n2) => max2 !== void 0 ? _Vec.clamp(n2, min3, max2) : _Vec.clamp(n2, min3));
  }
  /**
   * Cross (for point in polygon)
   *
   */
  static cross(x, y2, z) {
    return (y2[0] - x[0]) * (z[1] - x[1]) - (z[0] - x[0]) * (y2[1] - x[1]);
  }
  /**
   * Snap vector to nearest step.
   * @param A
   * @param step
   * @example
   * ```ts
   * Vec.snap([10.5, 28], 10) // [10, 30]
   * ```
   */
  static snap(a2, step = 1) {
    return [Math.round(a2[0] / step) * step, Math.round(a2[1] / step) * step];
  }
};
_Vec.abs = (A) => {
  return [Math.abs(A[0]), Math.abs(A[1])];
};
_Vec.add = (A, B) => {
  return [A[0] + B[0], A[1] + B[1]];
};
_Vec.addScalar = (A, n2) => {
  return [A[0] + n2, A[1] + n2];
};
_Vec.ang = (A, B) => {
  return Math.atan2(_Vec.cpr(A, B), _Vec.dpr(A, B));
};
_Vec.ang3 = (p1, pc, p2) => {
  const v1 = _Vec.vec(pc, p1);
  const v2 = _Vec.vec(pc, p2);
  return _Vec.ang(v1, v2);
};
_Vec.angle = (A, B) => {
  return Math.atan2(B[1] - A[1], B[0] - A[0]);
};
_Vec.clockwise = (p1, pc, p2) => {
  return _Vec.isLeft(p1, pc, p2) > 0;
};
_Vec.cpr = (A, B) => {
  return A[0] * B[1] - B[0] * A[1];
};
_Vec.dist = (A, B) => {
  return Math.hypot(A[1] - B[1], A[0] - B[0]);
};
_Vec.dist2 = (A, B) => {
  return _Vec.len2(_Vec.sub(A, B));
};
_Vec.distanceToBounds = (bounds, P) => {
  return _Vec.dist(P, _Vec.nearestPointOnBounds(bounds, P));
};
_Vec.distanceToLineSegment = (A, B, P, clamp2 = true) => {
  return _Vec.dist(P, _Vec.nearestPointOnLineSegment(A, B, P, clamp2));
};
_Vec.distanceToLineThroughPoint = (A, u2, P) => {
  return _Vec.dist(P, _Vec.nearestPointOnLineThroughPoint(A, u2, P));
};
_Vec.div = (A, n2) => {
  return [A[0] / n2, A[1] / n2];
};
_Vec.divV = (A, B) => {
  return [A[0] / B[0], A[1] / B[1]];
};
_Vec.dpr = (A, B) => {
  return A[0] * B[0] + A[1] * B[1];
};
_Vec.fastDist = (A, B) => {
  const V = [B[0] - A[0], B[1] - A[1]];
  const aV = [Math.abs(V[0]), Math.abs(V[1])];
  let r = 1 / Math.max(aV[0], aV[1]);
  r = r * (1.29289 - (aV[0] + aV[1]) * r * 0.29289);
  return [V[0] * r, V[1] * r];
};
_Vec.int = (A, B, from3, to, s2 = 1) => {
  const t2 = (_Vec.clamp(from3, to) - from3) / (to - from3);
  return _Vec.add(_Vec.mul(A, 1 - t2), _Vec.mul(B, s2));
};
_Vec.isEqual = (A, B) => {
  return A[0] === B[0] && A[1] === B[1];
};
_Vec.isLeft = (p1, pc, p2) => {
  return (pc[0] - p1[0]) * (p2[1] - p1[1]) - (p2[0] - p1[0]) * (pc[1] - p1[1]);
};
_Vec.len = (A) => {
  return Math.hypot(A[0], A[1]);
};
_Vec.len2 = (A) => {
  return A[0] * A[0] + A[1] * A[1];
};
_Vec.lrp = (A, B, t2) => {
  return _Vec.add(A, _Vec.mul(_Vec.sub(B, A), t2));
};
_Vec.max = (...v2) => {
  return [Math.max(...v2.map((a2) => a2[0])), Math.max(...v2.map((a2) => a2[1]))];
};
_Vec.med = (A, B) => {
  return _Vec.mul(_Vec.add(A, B), 0.5);
};
_Vec.min = (...v2) => {
  return [Math.min(...v2.map((a2) => a2[0])), Math.min(...v2.map((a2) => a2[1]))];
};
_Vec.mul = (A, n2) => {
  return [A[0] * n2, A[1] * n2];
};
_Vec.mulV = (A, B) => {
  return [A[0] * B[0], A[1] * B[1]];
};
_Vec.nearestPointOnBounds = (bounds, P) => {
  return [
    _Vec.clamp(P[0], bounds.minX, bounds.maxX),
    _Vec.clamp(P[1], bounds.minY, bounds.maxY)
  ];
};
_Vec.nearestPointOnLineSegment = (A, B, P, clamp2 = true) => {
  const u2 = _Vec.uni(_Vec.sub(B, A));
  const C = _Vec.add(A, _Vec.mul(u2, _Vec.pry(_Vec.sub(P, A), u2)));
  if (clamp2) {
    if (C[0] < Math.min(A[0], B[0]))
      return A[0] < B[0] ? A : B;
    if (C[0] > Math.max(A[0], B[0]))
      return A[0] > B[0] ? A : B;
    if (C[1] < Math.min(A[1], B[1]))
      return A[1] < B[1] ? A : B;
    if (C[1] > Math.max(A[1], B[1]))
      return A[1] > B[1] ? A : B;
  }
  return C;
};
_Vec.nearestPointOnLineThroughPoint = (A, u2, P) => {
  return _Vec.add(A, _Vec.mul(u2, _Vec.pry(_Vec.sub(P, A), u2)));
};
_Vec.neg = (A) => {
  return [-A[0], -A[1]];
};
_Vec.normalize = (A) => {
  return _Vec.uni(A);
};
_Vec.nudge = (A, B, d2) => {
  if (_Vec.isEqual(A, B))
    return A;
  return _Vec.add(A, _Vec.mul(_Vec.uni(_Vec.sub(B, A)), d2));
};
_Vec.nudgeAtAngle = (A, a2, d2) => {
  return [Math.cos(a2) * d2 + A[0], Math.sin(a2) * d2 + A[1]];
};
_Vec.per = (A) => {
  return [A[1], -A[0]];
};
_Vec.pointOffset = (A, B, offset) => {
  let u2 = _Vec.uni(_Vec.sub(B, A));
  if (_Vec.isEqual(A, B))
    u2 = A;
  return _Vec.add(A, _Vec.mul(u2, offset));
};
_Vec.pointsBetween = (A, B, steps = 6) => {
  return Array.from({ length: steps }).map((_2, i2) => {
    const t2 = i2 / (steps - 1);
    const k = Math.min(1, 0.5 + Math.abs(0.5 - t2));
    return [..._Vec.lrp(A, B, t2), k];
  });
};
_Vec.pry = (A, B) => {
  return _Vec.dpr(A, B) / _Vec.len(B);
};
_Vec.rescale = (a2, n2) => {
  const l2 = _Vec.len(a2);
  return [n2 * a2[0] / l2, n2 * a2[1] / l2];
};
_Vec.rot = (A, r = 0) => {
  return [
    A[0] * Math.cos(r) - A[1] * Math.sin(r),
    A[0] * Math.sin(r) + A[1] * Math.cos(r)
  ];
};
_Vec.rotWith = (A, C, r = 0) => {
  if (r === 0)
    return A;
  const s2 = Math.sin(r);
  const c2 = Math.cos(r);
  const px = A[0] - C[0];
  const py = A[1] - C[1];
  const nx = px * c2 - py * s2;
  const ny = px * s2 + py * c2;
  return [nx + C[0], ny + C[1]];
};
_Vec.slope = (A, B) => {
  if (A[0] === B[0])
    return NaN;
  return (A[1] - B[1]) / (A[0] - B[0]);
};
_Vec.sub = (A, B) => {
  return [A[0] - B[0], A[1] - B[1]];
};
_Vec.subScalar = (A, n2) => {
  return [A[0] - n2, A[1] - n2];
};
_Vec.tangent = (A, B) => {
  return _Vec.uni(_Vec.sub(A, B));
};
_Vec.toFixed = (a2) => {
  return a2.map((v2) => Math.round(v2 * 100) / 100);
};
_Vec.toPoint = (v2) => {
  return {
    x: v2[0],
    y: v2[1]
  };
};
_Vec.toPrecision = (a2, n2 = 4) => {
  return [+a2[0].toPrecision(n2), +a2[1].toPrecision(n2)];
};
_Vec.toVec = (v2) => [v2.x, v2.y];
_Vec.uni = (A) => {
  return _Vec.div(A, _Vec.len(A));
};
_Vec.vec = (A, B) => {
  return [B[0] - A[0], B[1] - A[1]];
};
var Vec = _Vec;

// node_modules/@blocksuite/global/dist/utils/model/point-location.js
var PointLocation = class _PointLocation extends Array {
  get absIn() {
    return Vec.add(this, this._in);
  }
  get absOut() {
    return Vec.add(this, this._out);
  }
  get in() {
    return this._in;
  }
  set in(value) {
    this._in = value;
  }
  get length() {
    return super.length;
  }
  get out() {
    return this._out;
  }
  set out(value) {
    this._out = value;
  }
  get tangent() {
    return this._tangent;
  }
  set tangent(value) {
    this._tangent = value;
  }
  constructor(point = [0, 0], tangent = [0, 0], inVec = [0, 0], outVec = [0, 0]) {
    super(2);
    this._in = [0, 0];
    this._out = [0, 0];
    this._tangent = [0, 0];
    this[0] = point[0];
    this[1] = point[1];
    this._tangent = tangent;
    this._in = inVec;
    this._out = outVec;
  }
  static fromVec(vec) {
    const point = new _PointLocation();
    point[0] = vec[0];
    point[1] = vec[1];
    return point;
  }
  clone() {
    return new _PointLocation(this, this._tangent, this._in, this._out);
  }
  setVec(vec) {
    this[0] = vec[0];
    this[1] = vec[1];
    return this;
  }
  toVec() {
    return [this[0], this[1]];
  }
};

// node_modules/@blocksuite/global/dist/utils/math.js
var EPSILON = 1e-12;
var MACHINE_EPSILON = 112e-18;
var PI2 = Math.PI * 2;
var CURVETIME_EPSILON = 1e-8;
function randomSeed() {
  return Math.floor(Math.random() * 2 ** 31);
}
function lineIntersects(sp, ep, sp2, ep2, infinite = false) {
  const v1 = Vec.sub(ep, sp);
  const v2 = Vec.sub(ep2, sp2);
  const cross = Vec.cpr(v1, v2);
  if (almostEqual(cross, 0, MACHINE_EPSILON))
    return null;
  const d2 = Vec.sub(sp, sp2);
  let u1 = Vec.cpr(v2, d2) / cross;
  const u2 = Vec.cpr(v1, d2) / cross, epsilon = (
    /*#=*/
    EPSILON
  ), uMin = -epsilon, uMax = 1 + epsilon;
  if (infinite || uMin < u1 && u1 < uMax && uMin < u2 && u2 < uMax) {
    if (!infinite) {
      u1 = clamp(u1, 0, 1);
    }
    return Vec.lrp(sp, ep, u1);
  }
  return null;
}
function polygonNearestPoint(points, point) {
  const len3 = points.length;
  let rst;
  let dis = Infinity;
  for (let i2 = 0; i2 < len3; i2++) {
    const p2 = points[i2];
    const p22 = points[(i2 + 1) % len3];
    const temp = Vec.nearestPointOnLineSegment(p2, p22, point, true);
    const curDis = Vec.dist(temp, point);
    if (curDis < dis) {
      dis = curDis;
      rst = temp;
    }
  }
  return rst;
}
function polygonPointDistance(points, point) {
  const nearest = polygonNearestPoint(points, point);
  return Vec.dist(nearest, point);
}
function rotatePoints(points, center, rotate) {
  const rad = toRadian(rotate);
  return points.map((p2) => Vec.rotWith(p2, center, rad));
}
function rotatePoint(point, center, rotate) {
  const rad = toRadian(rotate);
  return Vec.add(center, Vec.rot(Vec.sub(point, center), rad));
}
function toRadian(angle) {
  return angle * Math.PI / 180;
}
function isPointOnLineSegment(point, line) {
  const [sp, ep] = line;
  const v1 = Vec.sub(point, sp);
  const v2 = Vec.sub(point, ep);
  return almostEqual(Vec.cpr(v1, v2), 0, 0.01) && Vec.dpr(v1, v2) <= 0;
}
function polygonGetPointTangent(points, point) {
  const len3 = points.length;
  for (let i2 = 0; i2 < len3; i2++) {
    const p2 = points[i2];
    const p22 = points[(i2 + 1) % len3];
    if (isPointOnLineSegment(point, [p2, p22])) {
      return Vec.normalize(Vec.sub(p22, p2));
    }
  }
  return [0, 0];
}
function linePolygonIntersects(sp, ep, points) {
  const result = [];
  const len3 = points.length;
  for (let i2 = 0; i2 < len3; i2++) {
    const p2 = points[i2];
    const p22 = points[(i2 + 1) % len3];
    const rst = lineIntersects(sp, ep, p2, p22);
    if (rst) {
      const v2 = new PointLocation(rst);
      v2.tangent = Vec.normalize(Vec.sub(p22, p2));
      result.push(v2);
    }
  }
  return result.length ? result : null;
}
function linePolylineIntersects(sp, ep, points) {
  const result = [];
  const len3 = points.length;
  for (let i2 = 0; i2 < len3 - 1; i2++) {
    const p2 = points[i2];
    const p22 = points[i2 + 1];
    const rst = lineIntersects(sp, ep, p2, p22);
    if (rst) {
      result.push(new PointLocation(rst, Vec.normalize(Vec.sub(p22, p2))));
    }
  }
  return result.length ? result : null;
}
function polyLineNearestPoint(points, point) {
  const len3 = points.length;
  let rst;
  let dis = Infinity;
  for (let i2 = 0; i2 < len3 - 1; i2++) {
    const p2 = points[i2];
    const p22 = points[i2 + 1];
    const temp = Vec.nearestPointOnLineSegment(p2, p22, point, true);
    const curDis = Vec.dist(temp, point);
    if (curDis < dis) {
      dis = curDis;
      rst = temp;
    }
  }
  return rst;
}
function isPointOnlines(element2, points, rotate, hitPoint, threshold) {
  let x;
  let y2;
  if (rotate === 0) {
    x = hitPoint[0] - element2.x;
    y2 = hitPoint[1] - element2.y;
  } else {
    const { minX, minY, maxX, maxY } = element2;
    const rotatedPoint = rotatePoint(hitPoint, [minX + (maxX - minX) / 2, minY + (maxY - minY) / 2], -rotate);
    x = rotatedPoint[0] - element2.x;
    y2 = rotatedPoint[1] - element2.y;
  }
  let [A, B] = points;
  let P;
  if (distance2d(A[0], A[1], x, y2) < threshold || distance2d(B[0], B[1], x, y2) < threshold) {
    return true;
  }
  for (let i2 = 0; i2 < points.length; i2++) {
    const delta = [B[0] - A[0], B[1] - A[1]];
    const length4 = Math.hypot(delta[1], delta[0]);
    const U = [delta[0] / length4, delta[1] / length4];
    const C = [x - A[0], y2 - A[1]];
    const d2 = (C[0] * U[0] + C[1] * U[1]) / Math.hypot(U[1], U[0]);
    P = [A[0] + U[0] * d2, A[1] + U[1] * d2];
    const da = distance2d(P[0], P[1], A[0], A[1]);
    const db = distance2d(P[0], P[1], B[0], B[1]);
    P = db < da && da > length4 ? B : da < db && db > length4 ? A : P;
    if (Math.hypot(y2 - P[1], x - P[0]) < threshold) {
      return true;
    }
    A = B;
    B = points[i2 + 1];
  }
  return false;
}
var distance2d = (x1, y1, x2, y2) => {
  const xd = x2 - x1;
  const yd = y2 - y1;
  return Math.hypot(xd, yd);
};
function square(num) {
  return num * num;
}
function sumSqr(v2, w2) {
  return square(v2[0] - w2[0]) + square(v2[1] - w2[1]);
}
function distToSegmentSquared(p2, v2, w2) {
  const l2 = sumSqr(v2, w2);
  if (l2 == 0)
    return sumSqr(p2, v2);
  let t2 = ((p2[0] - v2[0]) * (w2[0] - v2[0]) + (p2[1] - v2[1]) * (w2[1] - v2[1])) / l2;
  t2 = Math.max(0, Math.min(1, t2));
  return sumSqr(p2, [v2[0] + t2 * (w2[0] - v2[0]), v2[1] + t2 * (w2[1] - v2[1])]);
}
function distToSegment(p2, v2, w2) {
  return Math.sqrt(distToSegmentSquared(p2, v2, w2));
}
function isPointIn(a2, x, y2) {
  return a2.x <= x && x <= a2.x + a2.w && a2.y <= y2 && y2 <= a2.y + a2.h;
}
function intersects(a2, b2) {
  return a2.x < b2.x + b2.w && a2.x + a2.w > b2.x && a2.y < b2.y + b2.h && a2.y + a2.h > b2.y;
}
function almostEqual(a2, b2, epsilon = 1e-4) {
  return Math.abs(a2 - b2) < epsilon;
}
function isVecZero(v2) {
  return v2.every((n2) => isZero(n2));
}
function isZero(x) {
  return x >= -EPSILON && x <= EPSILON;
}
function clamp(n2, min3, max2) {
  return Math.max(min3, max2 !== void 0 ? Math.min(n2, max2) : n2);
}
function pointInEllipse(A, C, rx, ry, rotation = 0) {
  const cos = Math.cos(rotation);
  const sin = Math.sin(rotation);
  const delta = Vec.sub(A, C);
  const tdx = cos * delta[0] + sin * delta[1];
  const tdy = sin * delta[0] - cos * delta[1];
  return tdx * tdx / (rx * rx) + tdy * tdy / (ry * ry) <= 1;
}
function pointInPolygon(p2, points) {
  let wn = 0;
  points.forEach((a2, i2) => {
    const b2 = points[(i2 + 1) % points.length];
    if (a2[1] <= p2[1]) {
      if (b2[1] > p2[1] && Vec.cross(a2, b2, p2) > 0) {
        wn += 1;
      }
    } else if (b2[1] <= p2[1] && Vec.cross(a2, b2, p2) < 0) {
      wn -= 1;
    }
  });
  return wn !== 0;
}
function pointOnPolygonStoke(p2, points, threshold) {
  for (let i2 = 0; i2 < points.length; ++i2) {
    const next = i2 + 1 === points.length ? 0 : i2 + 1;
    if (distToSegment(p2, points[i2], points[next]) <= threshold) {
      return true;
    }
  }
  return false;
}
function getPolygonPathFromPoints(points, closed = true) {
  const len3 = points.length;
  if (len3 < 2)
    return ``;
  const a2 = points[0];
  const b2 = points[1];
  let res = `M${a2[0].toFixed(2)},${a2[1].toFixed()}L${b2[0].toFixed(2)},${b2[1].toFixed()}`;
  for (let i2 = 2; i2 < len3; i2++) {
    const a3 = points[i2];
    res += `L${a3[0].toFixed(2)},${a3[1].toFixed()}`;
  }
  if (closed)
    res += "Z";
  return res;
}
function getSvgPathFromStroke(points, closed = true) {
  const len3 = points.length;
  if (len3 < 4) {
    return ``;
  }
  let a2 = points[0];
  let b2 = points[1];
  const c2 = points[2];
  let result = `M${a2[0].toFixed(2)},${a2[1].toFixed(2)} Q${b2[0].toFixed(2)},${b2[1].toFixed(2)} ${average(b2[0], c2[0]).toFixed(2)},${average(b2[1], c2[1]).toFixed(2)} T`;
  for (let i2 = 2, max2 = len3 - 1; i2 < max2; i2++) {
    a2 = points[i2];
    b2 = points[i2 + 1];
    result += `${average(a2[0], b2[0]).toFixed(2)},${average(a2[1], b2[1]).toFixed(2)} `;
  }
  if (closed) {
    result += "Z";
  }
  return result;
}
function average(a2, b2) {
  return (a2 + b2) / 2;
}
function lineEllipseIntersects(A, B, C, rx, ry, rad = 0) {
  A = Vec.rot(Vec.sub(A, C), -rad);
  B = Vec.rot(Vec.sub(B, C), -rad);
  rx *= rx;
  ry *= ry;
  const rst = [];
  const v2 = Vec.sub(B, A);
  const a2 = rx * v2[1] * v2[1] + ry * v2[0] * v2[0];
  const b2 = 2 * (rx * A[1] * v2[1] + ry * A[0] * v2[0]);
  const c2 = rx * A[1] * A[1] + ry * A[0] * A[0] - rx * ry;
  const D = b2 * b2 - 4 * a2 * c2;
  if (D >= 0) {
    const sqrtD = Math.sqrt(D);
    const t1 = (-b2 + sqrtD) / (2 * a2);
    const t2 = (-b2 - sqrtD) / (2 * a2);
    if (0 <= t1 && t1 <= 1)
      rst.push(Vec.add(Vec.rot(Vec.add(Vec.mul(v2, t1), A), rad), C));
    if (0 <= t2 && t2 <= 1 && Math.abs(t1 - t2) > 1e-16)
      rst.push(Vec.add(Vec.rot(Vec.add(Vec.mul(v2, t2), A), rad), C));
  }
  if (rst.length === 0)
    return null;
  return rst.map((v3) => {
    const pl = new PointLocation(v3);
    const normalVector = Vec.uni(Vec.divV(Vec.sub(v3, C), [rx * rx, ry * ry]));
    pl.tangent = [-normalVector[1], normalVector[0]];
    return pl;
  });
}
function sign(number) {
  return number > 0 ? 1 : -1;
}
function getPointFromBoundsWithRotation(bounds, point) {
  const { x, y: y2, w: w2, h: h2, rotate } = bounds;
  if (!rotate)
    return point;
  const cx = x + w2 / 2;
  const cy = y2 + h2 / 2;
  const m = new DOMMatrix().translateSelf(cx, cy).rotateSelf(rotate).translateSelf(-cx, -cy);
  const p2 = new DOMPoint(...point).matrixTransform(m);
  return [p2.x, p2.y];
}
function normalizeDegAngle(angle) {
  if (angle < 0)
    angle += 360;
  angle %= 360;
  return angle;
}
function toDegree(radian) {
  return radian * 180 / Math.PI;
}
function isOverlap(line1, line2, axis, strict = true) {
  const less = strict ? (a2, b2) => a2 < b2 : (a2, b2) => a2 <= b2;
  return !(less(Math.max(line1[0][axis], line1[1][axis]), Math.min(line2[0][axis], line2[1][axis])) || less(Math.max(line2[0][axis], line2[1][axis]), Math.min(line1[0][axis], line1[1][axis])));
}
function getCenterAreaBounds(bounds, ratio) {
  const { x, y: y2, w: w2, h: h2, rotate } = bounds;
  const cx = x + w2 / 2;
  const cy = y2 + h2 / 2;
  const nw = w2 * ratio;
  const nh = h2 * ratio;
  return {
    x: cx - nw / 2,
    y: cy - nh / 2,
    w: nw,
    h: nh,
    rotate
  };
}

// node_modules/@blocksuite/global/dist/utils/xywh.js
function serializeXYWH(x, y2, w2, h2) {
  return `[${x},${y2},${w2},${h2}]`;
}
function deserializeXYWH(xywh) {
  try {
    return JSON.parse(xywh);
  } catch (e2) {
    console.error("Failed to deserialize xywh", xywh);
    console.error(e2);
    return [0, 0, 0, 0];
  }
}

// node_modules/@blocksuite/global/dist/utils/model/bound.js
var Bound = class _Bound {
  get bl() {
    return [this.x, this.y + this.h];
  }
  get br() {
    return [this.x + this.w, this.y + this.h];
  }
  get center() {
    return [this.x + this.w / 2, this.y + this.h / 2];
  }
  set center([cx, cy]) {
    const [px, py] = this.center;
    this.x += cx - px;
    this.y += cy - py;
  }
  get horizontalLine() {
    return [
      [this.x, this.y + this.h / 2],
      [this.x + this.w, this.y + this.h / 2]
    ];
  }
  get leftLine() {
    return [
      [this.x, this.y],
      [this.x, this.y + this.h]
    ];
  }
  get lowerLine() {
    return [
      [this.x, this.y + this.h],
      [this.x + this.w, this.y + this.h]
    ];
  }
  get maxX() {
    return this.x + this.w;
  }
  get maxY() {
    return this.y + this.h;
  }
  get midPoints() {
    return [
      [this.x + this.w / 2, this.y],
      [this.x + this.w, this.y + this.h / 2],
      [this.x + this.w / 2, this.y + this.h],
      [this.x, this.y + this.h / 2]
    ];
  }
  get minX() {
    return this.x;
  }
  get minY() {
    return this.y;
  }
  get points() {
    return [
      [this.x, this.y],
      [this.x + this.w, this.y],
      [this.x + this.w, this.y + this.h],
      [this.x, this.y + this.h]
    ];
  }
  get rightLine() {
    return [
      [this.x + this.w, this.y],
      [this.x + this.w, this.y + this.h]
    ];
  }
  get tl() {
    return [this.x, this.y];
  }
  get tr() {
    return [this.x + this.w, this.y];
  }
  get upperLine() {
    return [
      [this.x, this.y],
      [this.x + this.w, this.y]
    ];
  }
  get verticalLine() {
    return [
      [this.x + this.w / 2, this.y],
      [this.x + this.w / 2, this.y + this.h]
    ];
  }
  constructor(x = 0, y2 = 0, w2 = 0, h2 = 0) {
    this.x = x;
    this.y = y2;
    this.w = w2;
    this.h = h2;
  }
  static deserialize(s2) {
    const [x, y2, w2, h2] = deserializeXYWH(s2);
    return new _Bound(x, y2, w2, h2);
  }
  static from(arg1) {
    return new _Bound(arg1.x, arg1.y, arg1.w, arg1.h);
  }
  static fromCenter(center, width, height) {
    const [x, y2] = center;
    return new _Bound(x - width / 2, y2 - height / 2, width, height);
  }
  static fromDOMRect({ left, top, width, height }) {
    return new _Bound(left, top, width, height);
  }
  static fromPoints(points) {
    return _Bound.from(getIBoundFromPoints(points));
  }
  static fromXYWH(xywh) {
    return new _Bound(xywh[0], xywh[1], xywh[2], xywh[3]);
  }
  static serialize(bound) {
    return serializeXYWH(bound.x, bound.y, bound.w, bound.h);
  }
  clone() {
    return new _Bound(this.x, this.y, this.w, this.h);
  }
  contains(bound) {
    return bound.x >= this.x && bound.y >= this.y && bound.maxX <= this.maxX && bound.maxY <= this.maxY;
  }
  containsPoint([x, y2]) {
    const { minX, minY, maxX, maxY } = this;
    return minX <= x && x <= maxX && minY <= y2 && y2 <= maxY;
  }
  expand(left, top, right, bottom) {
    if (Array.isArray(left)) {
      const [x, y2] = left;
      return new _Bound(this.x - x, this.y - y2, this.w + x * 2, this.h + y2 * 2);
    }
    top ??= left;
    right ??= left;
    bottom ??= top;
    return new _Bound(this.x - left, this.y - top, this.w + left + right, this.h + top + bottom);
  }
  getRelativePoint([x, y2]) {
    return [this.x + x * this.w, this.y + y2 * this.h];
  }
  getVerticesAndMidpoints() {
    return [...this.points, ...this.midPoints];
  }
  horizontalDistance(bound) {
    return Math.min(Math.abs(this.minX - bound.maxX), Math.abs(this.maxX - bound.minX));
  }
  include(point) {
    const x1 = Math.min(this.x, point[0]), y1 = Math.min(this.y, point[1]), x2 = Math.max(this.maxX, point[0]), y2 = Math.max(this.maxY, point[1]);
    return new _Bound(x1, y1, x2 - x1, y2 - y1);
  }
  intersectLine(sp, ep, infinite = false) {
    const rst = [];
    [
      [this.tl, this.tr],
      [this.tl, this.bl],
      [this.tr, this.br],
      [this.bl, this.br]
    ].forEach(([p1, p2]) => {
      const p3 = lineIntersects(sp, ep, p1, p2, infinite);
      if (p3)
        rst.push(p3);
    });
    return rst.length === 0 ? null : rst;
  }
  isHorizontalCross(bound) {
    return !(this.maxY < bound.minY || this.minY > bound.maxY);
  }
  isIntersectWithBound(bound, epsilon = EPSILON) {
    return bound.maxX > this.minX - epsilon && bound.maxY > this.minY - epsilon && bound.minX < this.maxX + epsilon && bound.minY < this.maxY + epsilon && !this.contains(bound) && !bound.contains(this);
  }
  isOverlapWithBound(bound, epsilon = EPSILON) {
    return bound.maxX > this.minX - epsilon && bound.maxY > this.minY - epsilon && bound.minX < this.maxX + epsilon && bound.minY < this.maxY + epsilon;
  }
  isPointInBound([x, y2], tolerance = 0.01) {
    return x > this.minX + tolerance && x < this.maxX - tolerance && y2 > this.minY + tolerance && y2 < this.maxY - tolerance;
  }
  isPointNearBound([x, y2], tolerance = 0.01) {
    return polygonPointDistance(this.points, [x, y2]) < tolerance;
  }
  isVerticalCross(bound) {
    return !(this.maxX < bound.minX || this.minX > bound.maxX);
  }
  moveDelta(dx, dy) {
    return new _Bound(this.x + dx, this.y + dy, this.w, this.h);
  }
  serialize() {
    return serializeXYWH(this.x, this.y, this.w, this.h);
  }
  toRelative([x, y2]) {
    return [(x - this.x) / this.w, (y2 - this.y) / this.h];
  }
  toXYWH() {
    return [this.x, this.y, this.w, this.h];
  }
  unite(bound) {
    const x1 = Math.min(this.x, bound.x), y1 = Math.min(this.y, bound.y), x2 = Math.max(this.maxX, bound.maxX), y2 = Math.max(this.maxY, bound.maxY);
    return new _Bound(x1, y1, x2 - x1, y2 - y1);
  }
  verticalDistance(bound) {
    return Math.min(Math.abs(this.minY - bound.maxY), Math.abs(this.maxY - bound.minY));
  }
};

// node_modules/@blocksuite/global/dist/utils/model/point.js
var Point = class _Point {
  constructor(x = 0, y2 = 0) {
    this.x = x;
    this.y = y2;
  }
  /**
   * Restrict a value to a certain interval.
   */
  static clamp(p2, min3, max2) {
    return new _Point(clamp(p2.x, min3.x, max2.x), clamp(p2.y, min3.y, max2.y));
  }
  static from(point, y2) {
    if (Array.isArray(point)) {
      return new _Point(point[0], point[1]);
    }
    if (typeof point === "number") {
      return new _Point(point, y2 ?? point);
    }
    return new _Point(point.x, point.y);
  }
  /**
   * Compares and returns the maximum of two points.
   */
  static max(a2, b2) {
    return new _Point(Math.max(a2.x, b2.x), Math.max(a2.y, b2.y));
  }
  /**
   * Compares and returns the minimum of two points.
   */
  static min(a2, b2) {
    return new _Point(Math.min(a2.x, b2.x), Math.min(a2.y, b2.y));
  }
  add(point) {
    return new _Point(this.x + point.x, this.y + point.y);
  }
  /**
   * Returns a copy of the point.
   */
  clone() {
    return new _Point(this.x, this.y);
  }
  cross(point) {
    return this.x * point.y - this.y * point.x;
  }
  equals({ x, y: y2 }) {
    return this.x === x && this.y === y2;
  }
  lerp(point, t2) {
    return new _Point(this.x + (point.x - this.x) * t2, this.y + (point.y - this.y) * t2);
  }
  scale(factor) {
    return new _Point(this.x * factor, this.y * factor);
  }
  set(x, y2) {
    this.x = x;
    this.y = y2;
  }
  subtract(point) {
    return new _Point(this.x - point.x, this.y - point.y);
  }
  toArray() {
    return [this.x, this.y];
  }
};
var Rect = class _Rect {
  get bottom() {
    return this.max.y;
  }
  set bottom(y2) {
    this.max.y = y2;
  }
  get height() {
    return this.max.y - this.min.y;
  }
  set height(h2) {
    this.max.y = this.min.y + h2;
  }
  get left() {
    return this.min.x;
  }
  set left(x) {
    this.min.x = x;
  }
  get right() {
    return this.max.x;
  }
  set right(x) {
    this.max.x = x;
  }
  get top() {
    return this.min.y;
  }
  set top(y2) {
    this.min.y = y2;
  }
  get width() {
    return this.max.x - this.min.x;
  }
  set width(w2) {
    this.max.x = this.min.x + w2;
  }
  constructor(left, top, right, bottom) {
    const [minX, maxX] = left <= right ? [left, right] : [right, left];
    const [minY, maxY] = top <= bottom ? [top, bottom] : [bottom, top];
    this.min = new Point(minX, minY);
    this.max = new Point(maxX, maxY);
  }
  static fromDOM(dom) {
    return _Rect.fromDOMRect(dom.getBoundingClientRect());
  }
  static fromDOMRect({ left, top, right, bottom }) {
    return _Rect.fromLTRB(left, top, right, bottom);
  }
  static fromLTRB(left, top, right, bottom) {
    return new _Rect(left, top, right, bottom);
  }
  static fromLWTH(left, width, top, height) {
    return new _Rect(left, top, left + width, top + height);
  }
  static fromPoint(point) {
    return _Rect.fromPoints(point.clone(), point);
  }
  static fromPoints(start, end) {
    const width = Math.abs(end.x - start.x);
    const height = Math.abs(end.y - start.y);
    const left = Math.min(end.x, start.x);
    const top = Math.min(end.y, start.y);
    return _Rect.fromLWTH(left, width, top, height);
  }
  static fromXY(x, y2) {
    return _Rect.fromPoint(new Point(x, y2));
  }
  center() {
    return new Point((this.left + this.right) / 2, (this.top + this.bottom) / 2);
  }
  clamp(p2) {
    return Point.clamp(p2, this.min, this.max);
  }
  clone() {
    const { left, top, right, bottom } = this;
    return new _Rect(left, top, right, bottom);
  }
  contains({ min: min3, max: max2 }) {
    return this.isPointIn(min3) && this.isPointIn(max2);
  }
  equals({ min: min3, max: max2 }) {
    return this.min.equals(min3) && this.max.equals(max2);
  }
  extend_with(point) {
    this.min = Point.min(this.min, point);
    this.max = Point.max(this.max, point);
  }
  extend_with_x(x) {
    this.min.x = Math.min(this.min.x, x);
    this.max.x = Math.max(this.max.x, x);
  }
  extend_with_y(y2) {
    this.min.y = Math.min(this.min.y, y2);
    this.max.y = Math.max(this.max.y, y2);
  }
  intersect(other) {
    return _Rect.fromPoints(Point.max(this.min, other.min), Point.min(this.max, other.max));
  }
  intersects({ left, top, right, bottom }) {
    return this.left <= right && left <= this.right && this.top <= bottom && top <= this.bottom;
  }
  isPointDown({ x, y: y2 }) {
    return this.bottom < y2 && this.left <= x && this.right >= x;
  }
  isPointIn({ x, y: y2 }) {
    return this.left <= x && x <= this.right && this.top <= y2 && y2 <= this.bottom;
  }
  isPointLeft({ x, y: y2 }) {
    return x < this.left && this.top <= y2 && this.bottom >= y2;
  }
  isPointRight({ x, y: y2 }) {
    return x > this.right && this.top <= y2 && this.bottom >= y2;
  }
  isPointUp({ x, y: y2 }) {
    return y2 < this.top && this.left <= x && this.right >= x;
  }
  toDOMRect() {
    const { left, top, width, height } = this;
    return new DOMRect(left, top, width, height);
  }
};

// node_modules/@blocksuite/global/dist/utils/bound.js
function getExpandedBound(a2, b2) {
  const minX = Math.min(a2.x, b2.x);
  const minY = Math.min(a2.y, b2.y);
  const maxX = Math.max(a2.x + a2.w, b2.x + b2.w);
  const maxY = Math.max(a2.y + a2.h, b2.y + b2.h);
  const width = Math.abs(maxX - minX);
  const height = Math.abs(maxY - minY);
  return {
    x: minX,
    y: minY,
    w: width,
    h: height
  };
}
function getPointsFromBoundWithRotation(bounds, getPoints = ({ x, y: y2, w: w2, h: h2 }) => [
  // left-top
  [x, y2],
  // right-top
  [x + w2, y2],
  // right-bottom
  [x + w2, y2 + h2],
  // left-bottom
  [x, y2 + h2]
], resPadding = [0, 0]) {
  const { rotate } = bounds;
  let points = getPoints({
    x: bounds.x - resPadding[1],
    y: bounds.y - resPadding[0],
    w: bounds.w + resPadding[1] * 2,
    h: bounds.h + resPadding[0] * 2
  });
  if (rotate) {
    const { x, y: y2, w: w2, h: h2 } = bounds;
    const cx = x + w2 / 2;
    const cy = y2 + h2 / 2;
    const m = new DOMMatrix().translateSelf(cx, cy).rotateSelf(rotate).translateSelf(-cx, -cy);
    points = points.map((point) => {
      const { x: x2, y: y3 } = new DOMPoint(...point).matrixTransform(m);
      return [x2, y3];
    });
  }
  return points;
}
function getQuadBoundWithRotation(bounds) {
  const { x, y: y2, w: w2, h: h2, rotate } = bounds;
  const rect = new DOMRect(x, y2, w2, h2);
  if (!rotate)
    return rect;
  return new DOMQuad(...getPointsFromBoundWithRotation(bounds).map((point) => new DOMPoint(...point))).getBounds();
}
function getBoundWithRotation(bound) {
  const { x, y: y2, width: w2, height: h2 } = getQuadBoundWithRotation(bound);
  return { x, y: y2, w: w2, h: h2 };
}
function getCommonBound(bounds) {
  if (!bounds.length) {
    return null;
  }
  if (bounds.length === 1) {
    const { x, y: y2, w: w2, h: h2 } = bounds[0];
    return new Bound(x, y2, w2, h2);
  }
  let result = bounds[0];
  for (let i2 = 1; i2 < bounds.length; i2++) {
    result = getExpandedBound(result, bounds[i2]);
  }
  return new Bound(result.x, result.y, result.w, result.h);
}
function getCommonBoundWithRotation(bounds) {
  if (bounds.length === 0) {
    return new Bound(0, 0, 0, 0);
  }
  return bounds.reduce((pre, bound) => {
    return pre.unite(bound instanceof Bound ? bound : Bound.from(getBoundWithRotation(bound)));
  }, Bound.from(getBoundWithRotation(bounds[0])));
}
function getIBoundFromPoints(points, rotation = 0) {
  let minX = Infinity;
  let minY = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  if (points.length < 1) {
    minX = 0;
    minY = 0;
    maxX = 1;
    maxY = 1;
  } else {
    for (const [x, y2] of points) {
      minX = Math.min(x, minX);
      minY = Math.min(y2, minY);
      maxX = Math.max(x, maxX);
      maxY = Math.max(y2, maxY);
    }
  }
  if (rotation !== 0) {
    return getIBoundFromPoints(points.map((pt) => Vec.rotWith(pt, [(minX + maxX) / 2, (minY + maxY) / 2], rotation)));
  }
  return {
    minX,
    minY,
    maxX,
    maxY,
    x: minX,
    y: minY,
    w: maxX - minX,
    h: maxY - minY
  };
}
function getBoundFromPoints(points) {
  return Bound.from(getIBoundFromPoints(points));
}
function inflateBound(bound, delta) {
  const half = delta / 2;
  const newBound = new Bound(bound.x - half, bound.y - half, bound.w + delta, bound.h + delta);
  if (newBound.w <= 0 || newBound.h <= 0) {
    throw new Error("Invalid delta range or bound size.");
  }
  return newBound;
}
function transformPointsToNewBound(points, oldBound, oldMargin, newBound, newMargin) {
  const wholeOldMargin = oldMargin * 2;
  const wholeNewMargin = newMargin * 2;
  const oldW = Math.max(oldBound.w - wholeOldMargin, 1);
  const oldH = Math.max(oldBound.h - wholeOldMargin, 1);
  const newW = Math.max(newBound.w - wholeNewMargin, 1);
  const newH = Math.max(newBound.h - wholeNewMargin, 1);
  const transformedPoints = points.map((p2) => {
    return {
      ...p2,
      x: newW * ((p2.x - oldMargin) / oldW) + newMargin,
      y: newH * ((p2.y - oldMargin) / oldH) + newMargin
    };
  });
  return {
    points: transformedPoints,
    bound: new Bound(newBound.x, newBound.y, newW + wholeNewMargin, newH + wholeNewMargin)
  };
}

// node_modules/lib0/set.js
var create = () => /* @__PURE__ */ new Set();

// node_modules/lib0/array.js
var last = (arr) => arr[arr.length - 1];
var appendTo = (dest, src) => {
  for (let i2 = 0; i2 < src.length; i2++) {
    dest.push(src[i2]);
  }
};
var from2 = Array.from;
var some = (arr, f2) => {
  for (let i2 = 0; i2 < arr.length; i2++) {
    if (f2(arr[i2], i2, arr)) {
      return true;
    }
  }
  return false;
};
var unfold = (len3, f2) => {
  const array = new Array(len3);
  for (let i2 = 0; i2 < len3; i2++) {
    array[i2] = f2(i2, array);
  }
  return array;
};
var isArray = Array.isArray;

// node_modules/lib0/string.js
var fromCharCode = String.fromCharCode;
var fromCodePoint = String.fromCodePoint;
var MAX_UTF16_CHARACTER = fromCharCode(65535);
var toLowerCase = (s2) => s2.toLowerCase();
var trimLeftRegex = /^\s*/g;
var trimLeft = (s2) => s2.replace(trimLeftRegex, "");
var fromCamelCaseRegex = /([A-Z])/g;
var fromCamelCase = (s2, separator) => trimLeft(s2.replace(fromCamelCaseRegex, (match2) => `${separator}${toLowerCase(match2)}`));
var _encodeUtf8Polyfill = (str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len3 = encodedString.length;
  const buf = new Uint8Array(len3);
  for (let i2 = 0; i2 < len3; i2++) {
    buf[i2] = /** @type {number} */
    encodedString.codePointAt(i2);
  }
  return buf;
};
var utf8TextEncoder = (
  /** @type {TextEncoder} */
  typeof TextEncoder !== "undefined" ? new TextEncoder() : null
);
var _encodeUtf8Native = (str) => utf8TextEncoder.encode(str);
var encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill;
var utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf-8", { fatal: true, ignoreBOM: true });
if (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {
  utf8TextDecoder = null;
}
var repeat = (source, n2) => unfold(n2, () => source).join("");

// node_modules/lib0/map.js
var create2 = () => /* @__PURE__ */ new Map();
var copy = (m) => {
  const r = create2();
  m.forEach((v2, k) => {
    r.set(k, v2);
  });
  return r;
};
var setIfUndefined = (map3, key, createT) => {
  let set2 = map3.get(key);
  if (set2 === void 0) {
    map3.set(key, set2 = createT());
  }
  return set2;
};
var map = (m, f2) => {
  const res = [];
  for (const [key, value] of m) {
    res.push(f2(value, key));
  }
  return res;
};
var any = (m, f2) => {
  for (const [key, value] of m) {
    if (f2(value, key)) {
      return true;
    }
  }
  return false;
};

// node_modules/lib0/conditions.js
var undefinedToNull = (v2) => v2 === void 0 ? null : v2;

// node_modules/lib0/storage.js
var VarStoragePolyfill = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {string} key
   * @param {any} newValue
   */
  setItem(key, newValue) {
    this.map.set(key, newValue);
  }
  /**
   * @param {string} key
   */
  getItem(key) {
    return this.map.get(key);
  }
};
var _localStorage = new VarStoragePolyfill();
var usePolyfill = true;
try {
  if (typeof localStorage !== "undefined" && localStorage) {
    _localStorage = localStorage;
    usePolyfill = false;
  }
} catch (e2) {
}
var varStorage = _localStorage;

// node_modules/lib0/object.js
var assign = Object.assign;
var keys = Object.keys;
var forEach = (obj, f2) => {
  for (const key in obj) {
    f2(obj[key], key);
  }
};
var length2 = (obj) => keys(obj).length;
var size = (obj) => keys(obj).length;
var isEmpty = (obj) => {
  for (const _k in obj) {
    return false;
  }
  return true;
};
var every = (obj, f2) => {
  for (const key in obj) {
    if (!f2(obj[key], key)) {
      return false;
    }
  }
  return true;
};
var hasProperty = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key);
var equalFlat = (a2, b2) => a2 === b2 || size(a2) === size(b2) && every(a2, (val, key) => (val !== void 0 || hasProperty(b2, key)) && b2[key] === val);
var freeze = Object.freeze;
var deepFreeze = (o2) => {
  for (const key in o2) {
    const c2 = o2[key];
    if (typeof c2 === "object" || typeof c2 === "function") {
      deepFreeze(o2[key]);
    }
  }
  return freeze(o2);
};

// node_modules/lib0/traits.js
var EqualityTraitSymbol = Symbol("Equality");

// node_modules/lib0/function.js
var callAll = (fs, args2, i2 = 0) => {
  try {
    for (; i2 < fs.length; i2++) {
      fs[i2](...args2);
    }
  } finally {
    if (i2 < fs.length) {
      callAll(fs, args2, i2 + 1);
    }
  }
};
var id = (a2) => a2;
var equalityDeep = (a2, b2) => {
  if (a2 === b2) {
    return true;
  }
  if (a2 == null || b2 == null || a2.constructor !== b2.constructor) {
    return false;
  }
  if (a2[EqualityTraitSymbol] != null) {
    return a2[EqualityTraitSymbol](b2);
  }
  switch (a2.constructor) {
    case ArrayBuffer:
      a2 = new Uint8Array(a2);
      b2 = new Uint8Array(b2);
    // eslint-disable-next-line no-fallthrough
    case Uint8Array: {
      if (a2.byteLength !== b2.byteLength) {
        return false;
      }
      for (let i2 = 0; i2 < a2.length; i2++) {
        if (a2[i2] !== b2[i2]) {
          return false;
        }
      }
      break;
    }
    case Set: {
      if (a2.size !== b2.size) {
        return false;
      }
      for (const value of a2) {
        if (!b2.has(value)) {
          return false;
        }
      }
      break;
    }
    case Map: {
      if (a2.size !== b2.size) {
        return false;
      }
      for (const key of a2.keys()) {
        if (!b2.has(key) || !equalityDeep(a2.get(key), b2.get(key))) {
          return false;
        }
      }
      break;
    }
    case Object:
      if (length2(a2) !== length2(b2)) {
        return false;
      }
      for (const key in a2) {
        if (!hasProperty(a2, key) || !equalityDeep(a2[key], b2[key])) {
          return false;
        }
      }
      break;
    case Array:
      if (a2.length !== b2.length) {
        return false;
      }
      for (let i2 = 0; i2 < a2.length; i2++) {
        if (!equalityDeep(a2[i2], b2[i2])) {
          return false;
        }
      }
      break;
    default:
      return false;
  }
  return true;
};
var isOneOf = (value, options) => options.includes(value);

// node_modules/lib0/environment.js
var isNode = typeof process !== "undefined" && process.release && /node|io\.js/.test(process.release.name) && Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]";
var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && !isNode;
var isMac = typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
var params;
var args = [];
var computeParams = () => {
  if (params === void 0) {
    if (isNode) {
      params = create2();
      const pargs = process.argv;
      let currParamName = null;
      for (let i2 = 0; i2 < pargs.length; i2++) {
        const parg = pargs[i2];
        if (parg[0] === "-") {
          if (currParamName !== null) {
            params.set(currParamName, "");
          }
          currParamName = parg;
        } else {
          if (currParamName !== null) {
            params.set(currParamName, parg);
            currParamName = null;
          } else {
            args.push(parg);
          }
        }
      }
      if (currParamName !== null) {
        params.set(currParamName, "");
      }
    } else if (typeof location === "object") {
      params = create2();
      (location.search || "?").slice(1).split("&").forEach((kv) => {
        if (kv.length !== 0) {
          const [key, value] = kv.split("=");
          params.set(`--${fromCamelCase(key, "-")}`, value);
          params.set(`-${fromCamelCase(key, "-")}`, value);
        }
      });
    } else {
      params = create2();
    }
  }
  return params;
};
var hasParam = (name) => computeParams().has(name);
var getVariable = (name) => isNode ? undefinedToNull(process.env[name.toUpperCase().replaceAll("-", "_")]) : undefinedToNull(varStorage.getItem(name));
var hasConf = (name) => hasParam("--" + name) || getVariable(name) !== null;
var production = hasConf("production");
var forceColor = isNode && isOneOf(process.env.FORCE_COLOR, ["true", "1", "2"]);
var supportsColor = forceColor || !hasParam("--no-colors") && // @todo deprecate --no-colors
!hasConf("no-color") && (!isNode || process.stdout.isTTY) && (!isNode || hasParam("--color") || getVariable("COLORTERM") !== null || (getVariable("TERM") || "").includes("color"));

// node_modules/lib0/math.js
var floor = Math.floor;
var abs = Math.abs;
var min = (a2, b2) => a2 < b2 ? a2 : b2;
var max = (a2, b2) => a2 > b2 ? a2 : b2;
var isNaN2 = Number.isNaN;
var isNegativeZero = (n2) => n2 !== 0 ? n2 < 0 : 1 / n2 < 0;

// node_modules/lib0/binary.js
var BIT1 = 1;
var BIT2 = 2;
var BIT3 = 4;
var BIT4 = 8;
var BIT6 = 32;
var BIT7 = 64;
var BIT8 = 128;
var BIT18 = 1 << 17;
var BIT19 = 1 << 18;
var BIT20 = 1 << 19;
var BIT21 = 1 << 20;
var BIT22 = 1 << 21;
var BIT23 = 1 << 22;
var BIT24 = 1 << 23;
var BIT25 = 1 << 24;
var BIT26 = 1 << 25;
var BIT27 = 1 << 26;
var BIT28 = 1 << 27;
var BIT29 = 1 << 28;
var BIT30 = 1 << 29;
var BIT31 = 1 << 30;
var BIT32 = 1 << 31;
var BITS5 = 31;
var BITS6 = 63;
var BITS7 = 127;
var BITS17 = BIT18 - 1;
var BITS18 = BIT19 - 1;
var BITS19 = BIT20 - 1;
var BITS20 = BIT21 - 1;
var BITS21 = BIT22 - 1;
var BITS22 = BIT23 - 1;
var BITS23 = BIT24 - 1;
var BITS24 = BIT25 - 1;
var BITS25 = BIT26 - 1;
var BITS26 = BIT27 - 1;
var BITS27 = BIT28 - 1;
var BITS28 = BIT29 - 1;
var BITS29 = BIT30 - 1;
var BITS30 = BIT31 - 1;
var BITS31 = 2147483647;

// node_modules/lib0/number.js
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;
var MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER;
var LOWEST_INT32 = 1 << 31;
var isInteger = Number.isInteger || ((num) => typeof num === "number" && isFinite(num) && floor(num) === num);
var isNaN3 = Number.isNaN;
var parseInt2 = Number.parseInt;

// node_modules/lib0/encoding.js
var Encoder = class {
  constructor() {
    this.cpos = 0;
    this.cbuf = new Uint8Array(100);
    this.bufs = [];
  }
};
var createEncoder = () => new Encoder();
var length3 = (encoder) => {
  let len3 = encoder.cpos;
  for (let i2 = 0; i2 < encoder.bufs.length; i2++) {
    len3 += encoder.bufs[i2].length;
  }
  return len3;
};
var toUint8Array = (encoder) => {
  const uint8arr = new Uint8Array(length3(encoder));
  let curPos = 0;
  for (let i2 = 0; i2 < encoder.bufs.length; i2++) {
    const d2 = encoder.bufs[i2];
    uint8arr.set(d2, curPos);
    curPos += d2.length;
  }
  uint8arr.set(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos), curPos);
  return uint8arr;
};
var verifyLen = (encoder, len3) => {
  const bufferLen = encoder.cbuf.length;
  if (bufferLen - encoder.cpos < len3) {
    encoder.bufs.push(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos));
    encoder.cbuf = new Uint8Array(max(bufferLen, len3) * 2);
    encoder.cpos = 0;
  }
};
var write = (encoder, num) => {
  const bufferLen = encoder.cbuf.length;
  if (encoder.cpos === bufferLen) {
    encoder.bufs.push(encoder.cbuf);
    encoder.cbuf = new Uint8Array(bufferLen * 2);
    encoder.cpos = 0;
  }
  encoder.cbuf[encoder.cpos++] = num;
};
var writeUint8 = write;
var writeVarUint = (encoder, num) => {
  while (num > BITS7) {
    write(encoder, BIT8 | BITS7 & num);
    num = floor(num / 128);
  }
  write(encoder, BITS7 & num);
};
var writeVarInt = (encoder, num) => {
  const isNegative = isNegativeZero(num);
  if (isNegative) {
    num = -num;
  }
  write(encoder, (num > BITS6 ? BIT8 : 0) | (isNegative ? BIT7 : 0) | BITS6 & num);
  num = floor(num / 64);
  while (num > 0) {
    write(encoder, (num > BITS7 ? BIT8 : 0) | BITS7 & num);
    num = floor(num / 128);
  }
};
var _strBuffer = new Uint8Array(3e4);
var _maxStrBSize = _strBuffer.length / 3;
var _writeVarStringNative = (encoder, str) => {
  if (str.length < _maxStrBSize) {
    const written = utf8TextEncoder.encodeInto(str, _strBuffer).written || 0;
    writeVarUint(encoder, written);
    for (let i2 = 0; i2 < written; i2++) {
      write(encoder, _strBuffer[i2]);
    }
  } else {
    writeVarUint8Array(encoder, encodeUtf8(str));
  }
};
var _writeVarStringPolyfill = (encoder, str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len3 = encodedString.length;
  writeVarUint(encoder, len3);
  for (let i2 = 0; i2 < len3; i2++) {
    write(
      encoder,
      /** @type {number} */
      encodedString.codePointAt(i2)
    );
  }
};
var writeVarString = utf8TextEncoder && /** @type {any} */
utf8TextEncoder.encodeInto ? _writeVarStringNative : _writeVarStringPolyfill;
var writeBinaryEncoder = (encoder, append2) => writeUint8Array(encoder, toUint8Array(append2));
var writeUint8Array = (encoder, uint8Array) => {
  const bufferLen = encoder.cbuf.length;
  const cpos = encoder.cpos;
  const leftCopyLen = min(bufferLen - cpos, uint8Array.length);
  const rightCopyLen = uint8Array.length - leftCopyLen;
  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);
  encoder.cpos += leftCopyLen;
  if (rightCopyLen > 0) {
    encoder.bufs.push(encoder.cbuf);
    encoder.cbuf = new Uint8Array(max(bufferLen * 2, rightCopyLen));
    encoder.cbuf.set(uint8Array.subarray(leftCopyLen));
    encoder.cpos = rightCopyLen;
  }
};
var writeVarUint8Array = (encoder, uint8Array) => {
  writeVarUint(encoder, uint8Array.byteLength);
  writeUint8Array(encoder, uint8Array);
};
var writeOnDataView = (encoder, len3) => {
  verifyLen(encoder, len3);
  const dview = new DataView(encoder.cbuf.buffer, encoder.cpos, len3);
  encoder.cpos += len3;
  return dview;
};
var writeFloat32 = (encoder, num) => writeOnDataView(encoder, 4).setFloat32(0, num, false);
var writeFloat64 = (encoder, num) => writeOnDataView(encoder, 8).setFloat64(0, num, false);
var writeBigInt64 = (encoder, num) => (
  /** @type {any} */
  writeOnDataView(encoder, 8).setBigInt64(0, num, false)
);
var floatTestBed = new DataView(new ArrayBuffer(4));
var isFloat32 = (num) => {
  floatTestBed.setFloat32(0, num);
  return floatTestBed.getFloat32(0) === num;
};
var writeAny = (encoder, data) => {
  switch (typeof data) {
    case "string":
      write(encoder, 119);
      writeVarString(encoder, data);
      break;
    case "number":
      if (isInteger(data) && abs(data) <= BITS31) {
        write(encoder, 125);
        writeVarInt(encoder, data);
      } else if (isFloat32(data)) {
        write(encoder, 124);
        writeFloat32(encoder, data);
      } else {
        write(encoder, 123);
        writeFloat64(encoder, data);
      }
      break;
    case "bigint":
      write(encoder, 122);
      writeBigInt64(encoder, data);
      break;
    case "object":
      if (data === null) {
        write(encoder, 126);
      } else if (isArray(data)) {
        write(encoder, 117);
        writeVarUint(encoder, data.length);
        for (let i2 = 0; i2 < data.length; i2++) {
          writeAny(encoder, data[i2]);
        }
      } else if (data instanceof Uint8Array) {
        write(encoder, 116);
        writeVarUint8Array(encoder, data);
      } else {
        write(encoder, 118);
        const keys4 = Object.keys(data);
        writeVarUint(encoder, keys4.length);
        for (let i2 = 0; i2 < keys4.length; i2++) {
          const key = keys4[i2];
          writeVarString(encoder, key);
          writeAny(encoder, data[key]);
        }
      }
      break;
    case "boolean":
      write(encoder, data ? 120 : 121);
      break;
    default:
      write(encoder, 127);
  }
};
var RleEncoder = class extends Encoder {
  /**
   * @param {function(Encoder, T):void} writer
   */
  constructor(writer) {
    super();
    this.w = writer;
    this.s = null;
    this.count = 0;
  }
  /**
   * @param {T} v
   */
  write(v2) {
    if (this.s === v2) {
      this.count++;
    } else {
      if (this.count > 0) {
        writeVarUint(this, this.count - 1);
      }
      this.count = 1;
      this.w(this, v2);
      this.s = v2;
    }
  }
};
var flushUintOptRleEncoder = (encoder) => {
  if (encoder.count > 0) {
    writeVarInt(encoder.encoder, encoder.count === 1 ? encoder.s : -encoder.s);
    if (encoder.count > 1) {
      writeVarUint(encoder.encoder, encoder.count - 2);
    }
  }
};
var UintOptRleEncoder = class {
  constructor() {
    this.encoder = new Encoder();
    this.s = 0;
    this.count = 0;
  }
  /**
   * @param {number} v
   */
  write(v2) {
    if (this.s === v2) {
      this.count++;
    } else {
      flushUintOptRleEncoder(this);
      this.count = 1;
      this.s = v2;
    }
  }
  /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */
  toUint8Array() {
    flushUintOptRleEncoder(this);
    return toUint8Array(this.encoder);
  }
};
var flushIntDiffOptRleEncoder = (encoder) => {
  if (encoder.count > 0) {
    const encodedDiff = encoder.diff * 2 + (encoder.count === 1 ? 0 : 1);
    writeVarInt(encoder.encoder, encodedDiff);
    if (encoder.count > 1) {
      writeVarUint(encoder.encoder, encoder.count - 2);
    }
  }
};
var IntDiffOptRleEncoder = class {
  constructor() {
    this.encoder = new Encoder();
    this.s = 0;
    this.count = 0;
    this.diff = 0;
  }
  /**
   * @param {number} v
   */
  write(v2) {
    if (this.diff === v2 - this.s) {
      this.s = v2;
      this.count++;
    } else {
      flushIntDiffOptRleEncoder(this);
      this.count = 1;
      this.diff = v2 - this.s;
      this.s = v2;
    }
  }
  /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */
  toUint8Array() {
    flushIntDiffOptRleEncoder(this);
    return toUint8Array(this.encoder);
  }
};
var StringEncoder = class {
  constructor() {
    this.sarr = [];
    this.s = "";
    this.lensE = new UintOptRleEncoder();
  }
  /**
   * @param {string} string
   */
  write(string) {
    this.s += string;
    if (this.s.length > 19) {
      this.sarr.push(this.s);
      this.s = "";
    }
    this.lensE.write(string.length);
  }
  toUint8Array() {
    const encoder = new Encoder();
    this.sarr.push(this.s);
    this.s = "";
    writeVarString(encoder, this.sarr.join(""));
    writeUint8Array(encoder, this.lensE.toUint8Array());
    return toUint8Array(encoder);
  }
};

// node_modules/lib0/error.js
var create3 = (s2) => new Error(s2);
var methodUnimplemented = () => {
  throw create3("Method unimplemented");
};
var unexpectedCase = () => {
  throw create3("Unexpected case");
};

// node_modules/lib0/decoding.js
var errorUnexpectedEndOfArray = create3("Unexpected end of array");
var errorIntegerOutOfRange = create3("Integer out of Range");
var Decoder = class {
  /**
   * @param {Uint8Array} uint8Array Binary data to decode
   */
  constructor(uint8Array) {
    this.arr = uint8Array;
    this.pos = 0;
  }
};
var createDecoder = (uint8Array) => new Decoder(uint8Array);
var hasContent = (decoder) => decoder.pos !== decoder.arr.length;
var readUint8Array = (decoder, len3) => {
  const view = new Uint8Array(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len3);
  decoder.pos += len3;
  return view;
};
var readVarUint8Array = (decoder) => readUint8Array(decoder, readVarUint(decoder));
var readUint8 = (decoder) => decoder.arr[decoder.pos++];
var readVarUint = (decoder) => {
  let num = 0;
  let mult = 1;
  const len3 = decoder.arr.length;
  while (decoder.pos < len3) {
    const r = decoder.arr[decoder.pos++];
    num = num + (r & BITS7) * mult;
    mult *= 128;
    if (r < BIT8) {
      return num;
    }
    if (num > MAX_SAFE_INTEGER) {
      throw errorIntegerOutOfRange;
    }
  }
  throw errorUnexpectedEndOfArray;
};
var readVarInt = (decoder) => {
  let r = decoder.arr[decoder.pos++];
  let num = r & BITS6;
  let mult = 64;
  const sign2 = (r & BIT7) > 0 ? -1 : 1;
  if ((r & BIT8) === 0) {
    return sign2 * num;
  }
  const len3 = decoder.arr.length;
  while (decoder.pos < len3) {
    r = decoder.arr[decoder.pos++];
    num = num + (r & BITS7) * mult;
    mult *= 128;
    if (r < BIT8) {
      return sign2 * num;
    }
    if (num > MAX_SAFE_INTEGER) {
      throw errorIntegerOutOfRange;
    }
  }
  throw errorUnexpectedEndOfArray;
};
var _readVarStringPolyfill = (decoder) => {
  let remainingLen = readVarUint(decoder);
  if (remainingLen === 0) {
    return "";
  } else {
    let encodedString = String.fromCodePoint(readUint8(decoder));
    if (--remainingLen < 100) {
      while (remainingLen--) {
        encodedString += String.fromCodePoint(readUint8(decoder));
      }
    } else {
      while (remainingLen > 0) {
        const nextLen = remainingLen < 1e4 ? remainingLen : 1e4;
        const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen);
        decoder.pos += nextLen;
        encodedString += String.fromCodePoint.apply(
          null,
          /** @type {any} */
          bytes
        );
        remainingLen -= nextLen;
      }
    }
    return decodeURIComponent(escape(encodedString));
  }
};
var _readVarStringNative = (decoder) => (
  /** @type any */
  utf8TextDecoder.decode(readVarUint8Array(decoder))
);
var readVarString = utf8TextDecoder ? _readVarStringNative : _readVarStringPolyfill;
var readFromDataView = (decoder, len3) => {
  const dv = new DataView(decoder.arr.buffer, decoder.arr.byteOffset + decoder.pos, len3);
  decoder.pos += len3;
  return dv;
};
var readFloat32 = (decoder) => readFromDataView(decoder, 4).getFloat32(0, false);
var readFloat64 = (decoder) => readFromDataView(decoder, 8).getFloat64(0, false);
var readBigInt64 = (decoder) => (
  /** @type {any} */
  readFromDataView(decoder, 8).getBigInt64(0, false)
);
var readAnyLookupTable = [
  (decoder) => void 0,
  // CASE 127: undefined
  (decoder) => null,
  // CASE 126: null
  readVarInt,
  // CASE 125: integer
  readFloat32,
  // CASE 124: float32
  readFloat64,
  // CASE 123: float64
  readBigInt64,
  // CASE 122: bigint
  (decoder) => false,
  // CASE 121: boolean (false)
  (decoder) => true,
  // CASE 120: boolean (true)
  readVarString,
  // CASE 119: string
  (decoder) => {
    const len3 = readVarUint(decoder);
    const obj = {};
    for (let i2 = 0; i2 < len3; i2++) {
      const key = readVarString(decoder);
      obj[key] = readAny(decoder);
    }
    return obj;
  },
  (decoder) => {
    const len3 = readVarUint(decoder);
    const arr = [];
    for (let i2 = 0; i2 < len3; i2++) {
      arr.push(readAny(decoder));
    }
    return arr;
  },
  readVarUint8Array
  // CASE 116: Uint8Array
];
var readAny = (decoder) => readAnyLookupTable[127 - readUint8(decoder)](decoder);
var RleDecoder = class extends Decoder {
  /**
   * @param {Uint8Array} uint8Array
   * @param {function(Decoder):T} reader
   */
  constructor(uint8Array, reader) {
    super(uint8Array);
    this.reader = reader;
    this.s = null;
    this.count = 0;
  }
  read() {
    if (this.count === 0) {
      this.s = this.reader(this);
      if (hasContent(this)) {
        this.count = readVarUint(this) + 1;
      } else {
        this.count = -1;
      }
    }
    this.count--;
    return (
      /** @type {T} */
      this.s
    );
  }
};
var UintOptRleDecoder = class extends Decoder {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(uint8Array) {
    super(uint8Array);
    this.s = 0;
    this.count = 0;
  }
  read() {
    if (this.count === 0) {
      this.s = readVarInt(this);
      const isNegative = isNegativeZero(this.s);
      this.count = 1;
      if (isNegative) {
        this.s = -this.s;
        this.count = readVarUint(this) + 2;
      }
    }
    this.count--;
    return (
      /** @type {number} */
      this.s
    );
  }
};
var IntDiffOptRleDecoder = class extends Decoder {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(uint8Array) {
    super(uint8Array);
    this.s = 0;
    this.count = 0;
    this.diff = 0;
  }
  /**
   * @return {number}
   */
  read() {
    if (this.count === 0) {
      const diff = readVarInt(this);
      const hasCount = diff & 1;
      this.diff = floor(diff / 2);
      this.count = 1;
      if (hasCount) {
        this.count = readVarUint(this) + 2;
      }
    }
    this.s += this.diff;
    this.count--;
    return this.s;
  }
};
var StringDecoder = class {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(uint8Array) {
    this.decoder = new UintOptRleDecoder(uint8Array);
    this.str = readVarString(this.decoder);
    this.spos = 0;
  }
  /**
   * @return {string}
   */
  read() {
    const end = this.spos + this.decoder.read();
    const res = this.str.slice(this.spos, end);
    this.spos = end;
    return res;
  }
};

// node_modules/lib0/buffer.js
var createUint8ArrayFromLen = (len3) => new Uint8Array(len3);
var toBase64Browser = (bytes) => {
  let s2 = "";
  for (let i2 = 0; i2 < bytes.byteLength; i2++) {
    s2 += fromCharCode(bytes[i2]);
  }
  return btoa(s2);
};
var toBase64Node = (bytes) => Buffer.from(bytes.buffer, bytes.byteOffset, bytes.byteLength).toString("base64");
var toBase64 = isBrowser ? toBase64Browser : toBase64Node;
var copyUint8Array = (uint8Array) => {
  const newBuf = createUint8ArrayFromLen(uint8Array.byteLength);
  newBuf.set(uint8Array);
  return newBuf;
};

// node_modules/lib0/hash/sha256.js
var rotr = (w2, shift) => w2 >>> shift | w2 << 32 - shift;
var sum0to256 = (x) => rotr(x, 2) ^ rotr(x, 13) ^ rotr(x, 22);
var sum1to256 = (x) => rotr(x, 6) ^ rotr(x, 11) ^ rotr(x, 25);
var sigma0to256 = (x) => rotr(x, 7) ^ rotr(x, 18) ^ x >>> 3;
var sigma1to256 = (x) => rotr(x, 17) ^ rotr(x, 19) ^ x >>> 10;
var K = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var HINIT = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var Hasher = class {
  constructor() {
    const buf = new ArrayBuffer(64 + 64 * 4);
    this._H = new Uint32Array(buf, 0, 8);
    this._H.set(HINIT);
    this._W = new Uint32Array(buf, 64, 64);
  }
  _updateHash() {
    const H = this._H;
    const W = this._W;
    for (let t2 = 16; t2 < 64; t2++) {
      W[t2] = sigma1to256(W[t2 - 2]) + W[t2 - 7] + sigma0to256(W[t2 - 15]) + W[t2 - 16];
    }
    let a2 = H[0];
    let b2 = H[1];
    let c2 = H[2];
    let d2 = H[3];
    let e2 = H[4];
    let f2 = H[5];
    let g2 = H[6];
    let h2 = H[7];
    for (let tt = 0, T1, T2; tt < 64; tt++) {
      T1 = h2 + sum1to256(e2) + (e2 & f2 ^ ~e2 & g2) + K[tt] + W[tt] >>> 0;
      T2 = sum0to256(a2) + (a2 & b2 ^ a2 & c2 ^ b2 & c2) >>> 0;
      h2 = g2;
      g2 = f2;
      f2 = e2;
      e2 = d2 + T1 >>> 0;
      d2 = c2;
      c2 = b2;
      b2 = a2;
      a2 = T1 + T2 >>> 0;
    }
    H[0] += a2;
    H[1] += b2;
    H[2] += c2;
    H[3] += d2;
    H[4] += e2;
    H[5] += f2;
    H[6] += g2;
    H[7] += h2;
  }
  /**
   * Returns a 32-byte hash.
   *
   * @param {Uint8Array} data
   */
  digest(data) {
    let i2 = 0;
    for (; i2 + 56 <= data.length; ) {
      let j2 = 0;
      for (; j2 < 16 && i2 + 3 < data.length; j2++) {
        this._W[j2] = data[i2++] << 24 | data[i2++] << 16 | data[i2++] << 8 | data[i2++];
      }
      if (i2 % 64 !== 0) {
        this._W.fill(0, j2, 16);
        while (i2 < data.length) {
          this._W[j2] |= data[i2] << (3 - i2 % 4) * 8;
          i2++;
        }
        this._W[j2] |= BIT8 << (3 - i2 % 4) * 8;
      }
      this._updateHash();
    }
    const isPaddedWith1 = i2 % 64 !== 0;
    this._W.fill(0, 0, 16);
    let j = 0;
    for (; i2 < data.length; j++) {
      for (let ci = 3; ci >= 0 && i2 < data.length; ci--) {
        this._W[j] |= data[i2++] << ci * 8;
      }
    }
    if (!isPaddedWith1) {
      this._W[j - (i2 % 4 === 0 ? 0 : 1)] |= BIT8 << (3 - i2 % 4) * 8;
    }
    this._W[14] = data.byteLength / BIT30;
    this._W[15] = data.byteLength * 8;
    this._updateHash();
    const dv = new Uint8Array(32);
    for (let i3 = 0; i3 < this._H.length; i3++) {
      for (let ci = 0; ci < 4; ci++) {
        dv[i3 * 4 + ci] = this._H[i3] >>> (3 - ci) * 8;
      }
    }
    return dv;
  }
};
var digest = (data) => new Hasher().digest(data);

// node_modules/@blocksuite/global/dist/utils/crypto.js
async function sha(input) {
  const hash2 = crypto.subtle === void 0 ? digest(new Uint8Array(input)) : await crypto.subtle.digest("SHA-256", input);
  return toBase64(new Uint8Array(hash2)).replace(/\+/g, "-").replace(/\//g, "_");
}

// node_modules/@blocksuite/global/dist/utils/curve.js
function evaluate(v2, t2, type, normalized) {
  if (t2 == null || t2 < 0 || t2 > 1)
    return null;
  const x0 = v2[0][0], y0 = v2[0][1], x3 = v2[3][0], y3 = v2[3][1];
  let x1 = v2[1][0], y1 = v2[1][1], x2 = v2[2][0], y2 = v2[2][1];
  if (isZero(x1 - x0) && isZero(y1 - y0)) {
    x1 = x0;
    y1 = y0;
  }
  if (isZero(x2 - x3) && isZero(y2 - y3)) {
    x2 = x3;
    y2 = y3;
  }
  const cx = 3 * (x1 - x0), bx = 3 * (x2 - x1) - cx, ax = x3 - x0 - cx - bx, cy = 3 * (y1 - y0), by = 3 * (y2 - y1) - cy, ay = y3 - y0 - cy - by;
  let x, y4;
  if (type === 0) {
    x = t2 === 0 ? x0 : t2 === 1 ? x3 : ((ax * t2 + bx) * t2 + cx) * t2 + x0;
    y4 = t2 === 0 ? y0 : t2 === 1 ? y3 : ((ay * t2 + by) * t2 + cy) * t2 + y0;
  } else {
    const tMin = CURVETIME_EPSILON, tMax = 1 - tMin;
    if (t2 < tMin) {
      x = cx;
      y4 = cy;
    } else if (t2 > tMax) {
      x = 3 * (x3 - x2);
      y4 = 3 * (y3 - y2);
    } else {
      x = (3 * ax * t2 + 2 * bx) * t2 + cx;
      y4 = (3 * ay * t2 + 2 * by) * t2 + cy;
    }
    if (normalized) {
      if (x === 0 && y4 === 0 && (t2 < tMin || t2 > tMax)) {
        x = x2 - x1;
        y4 = y2 - y1;
      }
      const len3 = Math.sqrt(x * x + y4 * y4);
      if (len3) {
        x /= len3;
        y4 /= len3;
      }
    }
    if (type === 3) {
      const x22 = 6 * ax * t2 + 2 * bx, y22 = 6 * ay * t2 + 2 * by, d2 = Math.pow(x * x + y4 * y4, 3 / 2);
      x = d2 !== 0 ? (x * y22 - y4 * x22) / d2 : 0;
      y4 = 0;
    }
  }
  return type === 2 ? [y4, -x] : [x, y4];
}
function getBezierPoint(values, t2) {
  return evaluate(values, t2, 0, false);
}
function getBezierTangent(values, t2) {
  return evaluate(values, t2, 1, true);
}
function getBezierNearestTime(values, point) {
  const count = 100;
  let minDist = Infinity, minT = 0;
  function refine(t2) {
    if (t2 >= 0 && t2 <= 1) {
      const tmpPoint = getBezierPoint(values, t2);
      assertExists(tmpPoint);
      const dist3 = Vec.dist2(point, tmpPoint);
      if (dist3 < minDist) {
        minDist = dist3;
        minT = t2;
        return true;
      }
    }
    return false;
  }
  for (let i2 = 0; i2 <= count; i2++)
    refine(i2 / count);
  let step = 1 / (count * 2);
  while (step > CURVETIME_EPSILON) {
    if (!refine(minT - step) && !refine(minT + step))
      step /= 2;
  }
  return minT;
}
function getBezierNearestPoint(values, point) {
  const t2 = getBezierNearestTime(values, point);
  const pointOnCurve = getBezierPoint(values, t2);
  assertExists(pointOnCurve);
  return pointOnCurve;
}
function getBezierParameters(points) {
  if (points.length === 1) {
    const point = points[0];
    return [point, point, point, point];
  }
  return [points[0], points[0].absOut, points[1].absIn, points[1]];
}
function getBezierCurveBoundingBox(values) {
  const [start, controlPoint1, controlPoint2, end] = values;
  const [x0, y0] = start;
  const [x1, y1] = controlPoint1;
  const [x2, y2] = controlPoint2;
  const [x3, y3] = end;
  const points = [];
  const tvalues = [];
  const bounds = [[], []];
  let a2;
  let b2;
  let c2;
  let t2;
  let t1;
  let t22;
  let b2ac;
  let sqrtb2ac;
  for (let i2 = 0; i2 < 2; i2 += 1) {
    if (i2 === 0) {
      b2 = 6 * x0 - 12 * x1 + 6 * x2;
      a2 = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
      c2 = 3 * x1 - 3 * x0;
    } else {
      b2 = 6 * y0 - 12 * y1 + 6 * y2;
      a2 = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
      c2 = 3 * y1 - 3 * y0;
    }
    if (Math.abs(a2) < 1e-12) {
      if (Math.abs(b2) < 1e-12) {
        continue;
      }
      t2 = -c2 / b2;
      if (t2 > 0 && t2 < 1)
        tvalues.push(t2);
      continue;
    }
    b2ac = b2 * b2 - 4 * c2 * a2;
    sqrtb2ac = Math.sqrt(b2ac);
    if (b2ac < 0)
      continue;
    t1 = (-b2 + sqrtb2ac) / (2 * a2);
    if (t1 > 0 && t1 < 1)
      tvalues.push(t1);
    t22 = (-b2 - sqrtb2ac) / (2 * a2);
    if (t22 > 0 && t22 < 1)
      tvalues.push(t22);
  }
  let x;
  let y4;
  let mt;
  let j = tvalues.length;
  const jlen = j;
  while (j) {
    j -= 1;
    t2 = tvalues[j];
    mt = 1 - t2;
    x = mt * mt * mt * x0 + 3 * mt * mt * t2 * x1 + 3 * mt * t2 * t2 * x2 + t2 * t2 * t2 * x3;
    bounds[0][j] = x;
    y4 = mt * mt * mt * y0 + 3 * mt * mt * t2 * y1 + 3 * mt * t2 * t2 * y2 + t2 * t2 * t2 * y3;
    bounds[1][j] = y4;
    points[j] = { X: x, Y: y4 };
  }
  tvalues[jlen] = 0;
  tvalues[jlen + 1] = 1;
  points[jlen] = { X: x0, Y: y0 };
  points[jlen + 1] = { X: x3, Y: y3 };
  bounds[0][jlen] = x0;
  bounds[1][jlen] = y0;
  bounds[0][jlen + 1] = x3;
  bounds[1][jlen + 1] = y3;
  tvalues.length = jlen + 2;
  bounds[0].length = jlen + 2;
  bounds[1].length = jlen + 2;
  points.length = jlen + 2;
  const left = Math.min.apply(null, bounds[0]);
  const top = Math.min.apply(null, bounds[1]);
  const right = Math.max.apply(null, bounds[0]);
  const bottom = Math.max.apply(null, bounds[1]);
  return new Bound(left, top, right - left, bottom - top);
}
function crt(v2) {
  return v2 < 0 ? -Math.pow(-v2, 1 / 3) : Math.pow(v2, 1 / 3);
}
function align(points, [start, end]) {
  const tx = start[0], ty = start[1], a2 = -Math.atan2(end[1] - ty, end[0] - tx), d2 = function([x, y2]) {
    return [
      (x - tx) * Math.cos(a2) - (y2 - ty) * Math.sin(a2),
      (x - tx) * Math.sin(a2) + (y2 - ty) * Math.cos(a2)
    ];
  };
  return points.map(d2);
}
function between(v2, min3, max2) {
  return min3 <= v2 && v2 <= max2 || approximately(v2, min3) || approximately(v2, max2);
}
function approximately(a2, b2, precision, epsilon = 1e-6) {
  return Math.abs(a2 - b2) <= (precision || epsilon);
}
function roots(points, line) {
  const order = points.length - 1;
  const aligned = align(points, line);
  const reduce = function(t2) {
    return 0 <= t2 && t2 <= 1;
  };
  if (order === 2) {
    const a3 = aligned[0][1], b3 = aligned[1][1], c3 = aligned[2][1], d3 = a3 - 2 * b3 + c3;
    if (d3 !== 0) {
      const m1 = -Math.sqrt(b3 * b3 - a3 * c3), m2 = -a3 + b3, v12 = -(m1 + m2) / d3, v2 = -(-m1 + m2) / d3;
      return [v12, v2].filter(reduce);
    } else if (b3 !== c3 && d3 === 0) {
      return [(2 * b3 - c3) / (2 * b3 - 2 * c3)].filter(reduce);
    }
    return [];
  }
  const pa = aligned[0][1], pb = aligned[1][1], pc = aligned[2][1], pd = aligned[3][1];
  const d2 = -pa + 3 * pb - 3 * pc + pd;
  let a2 = 3 * pa - 6 * pb + 3 * pc, b2 = -3 * pa + 3 * pb, c2 = pa;
  if (approximately(d2, 0)) {
    if (approximately(a2, 0)) {
      if (approximately(b2, 0)) {
        return [];
      }
      return [-c2 / b2].filter(reduce);
    }
    const q3 = Math.sqrt(b2 * b2 - 4 * a2 * c2), a22 = 2 * a2;
    return [(q3 - b2) / a22, (-b2 - q3) / a22].filter(reduce);
  }
  a2 /= d2;
  b2 /= d2;
  c2 /= d2;
  const p2 = (3 * b2 - a2 * a2) / 3, p3 = p2 / 3, q = (2 * a2 * a2 * a2 - 9 * a2 * b2 + 27 * c2) / 27, q2 = q / 2, discriminant = q2 * q2 + p3 * p3 * p3;
  let u1, v1, x1, x2, x3;
  if (discriminant < 0) {
    const mp3 = -p2 / 3, mp33 = mp3 * mp3 * mp3, r = Math.sqrt(mp33), t2 = -q / (2 * r), cosphi = t2 < -1 ? -1 : t2 > 1 ? 1 : t2, phi = Math.acos(cosphi), crtr = crt(r), t1 = 2 * crtr;
    x1 = t1 * Math.cos(phi / 3) - a2 / 3;
    x2 = t1 * Math.cos((phi + Math.PI * 2) / 3) - a2 / 3;
    x3 = t1 * Math.cos((phi + 2 * Math.PI * 2) / 3) - a2 / 3;
    return [x1, x2, x3].filter(reduce);
  } else if (discriminant === 0) {
    u1 = q2 < 0 ? crt(-q2) : -crt(q2);
    x1 = 2 * u1 - a2 / 3;
    x2 = -u1 - a2 / 3;
    return [x1, x2].filter(reduce);
  } else {
    const sd = Math.sqrt(discriminant);
    u1 = crt(-q2 + sd);
    v1 = crt(q2 + sd);
    return [u1 - v1 - a2 / 3].filter(reduce);
  }
}
function curveIntersects(path2, line) {
  const { minX, maxX, minY, maxY } = Bound.fromPoints(line);
  const points = getBezierParameters(path2);
  const intersectedPoints = roots(points, line).map((t2) => getBezierPoint(points, t2)).filter((point) => point ? between(point[0], minX, maxX) && between(point[1], minY, maxY) : false).map((point) => new PointLocation(point));
  return intersectedPoints.length > 0 ? intersectedPoints : null;
}

// node_modules/@blocksuite/global/dist/utils/disposable.js
var DisposableGroup = class {
  constructor() {
    this._disposables = [];
    this._disposed = false;
  }
  get disposed() {
    return this._disposed;
  }
  /**
   * Add to group to be disposed with others.
   * This will be immediately disposed if this group has already been disposed.
   */
  add(d2) {
    if (typeof d2 === "function") {
      if (this._disposed)
        d2();
      else
        this._disposables.push({ dispose: d2 });
    } else {
      if (this._disposed)
        d2.dispose();
      else
        this._disposables.push(d2);
    }
  }
  addFromEvent(target, type, handler, eventOptions) {
    this.add({
      dispose: () => {
        target.removeEventListener(type, handler, eventOptions);
      }
    });
    target.addEventListener(type, handler, eventOptions);
  }
  dispose() {
    disposeAll(this._disposables);
    this._disposables = [];
    this._disposed = true;
  }
};
function flattenDisposables(disposables) {
  return {
    dispose: () => disposeAll(disposables)
  };
}
function disposeAll(disposables) {
  for (const disposable of disposables) {
    try {
      disposable.dispose();
    } catch (err) {
      console.error(err);
    }
  }
}

// node_modules/@blocksuite/global/dist/utils/function.js
async function sleep(ms, signal) {
  return new Promise((resolve) => {
    if (signal?.aborted) {
      resolve();
      return;
    }
    let resolved = false;
    signal?.addEventListener("abort", () => {
      if (!resolved) {
        clearTimeout(timeId);
        resolve();
      }
    });
    const timeId = setTimeout(() => {
      resolved = true;
      resolve();
    }, ms);
  });
}
function noop(_2) {
  return;
}
function throttle(fn, limit, { leading = true, trailing = true } = {}) {
  let timer = null;
  let lastArgs = null;
  const setTimer = () => {
    if (lastArgs && trailing) {
      fn(...lastArgs);
      lastArgs = null;
      timer = setTimeout(setTimer, limit);
    } else {
      timer = null;
    }
  };
  return function(...args2) {
    if (timer) {
      lastArgs = args2;
      return;
    }
    if (leading) {
      fn.apply(this, args2);
    }
    timer = setTimeout(setTimer, limit);
  };
}
var debounce = (fn, limit, { leading = true, trailing = true } = {}) => {
  let timer = null;
  let lastArgs = null;
  const setTimer = () => {
    if (lastArgs && trailing) {
      fn(...lastArgs);
      lastArgs = null;
      timer = setTimeout(setTimer, limit);
    } else {
      timer = null;
    }
  };
  return function(...args2) {
    if (timer) {
      lastArgs = args2;
      clearTimeout(timer);
    }
    if (leading && !timer) {
      fn(...args2);
    }
    timer = setTimeout(setTimer, limit);
  };
};
async function nextTick() {
  if ("scheduler" in window && "yield" in window.scheduler) {
    return window.scheduler.yield();
  } else if (typeof requestIdleCallback !== "undefined") {
    return new Promise((resolve) => requestIdleCallback(resolve));
  } else {
    return new Promise((resolve) => setTimeout(resolve, 0));
  }
}

// node_modules/@blocksuite/global/dist/utils/iterable.js
function countBy(items, key) {
  const count = {};
  items.forEach((item) => {
    const k = key(item);
    if (k === null)
      return;
    if (!count[k]) {
      count[k] = 0;
    }
    count[k] += 1;
  });
  return count;
}
function maxBy(items, value) {
  if (!items.length) {
    return null;
  }
  let maxItem = items[0];
  let max2 = value(maxItem);
  for (let i2 = 1; i2 < items.length; i2++) {
    const item = items[i2];
    const v2 = value(item);
    if (v2 > max2) {
      max2 = v2;
      maxItem = item;
    }
  }
  return maxItem;
}
function atLeastNMatches(arr, matchFn, n2) {
  let count = 0;
  for (let i2 = 0; i2 < arr.length; i2++) {
    if (matchFn(arr[i2])) {
      count++;
      if (count >= n2) {
        return true;
      }
    }
  }
  return false;
}
function groupBy(arr, key) {
  const result = {};
  for (const item of arr) {
    const groupKey = (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      typeof key === "function" ? key(item) : item[key]
    );
    if (!result[groupKey]) {
      result[groupKey] = [];
    }
    result[groupKey].push(item);
  }
  return result;
}
function pick(target, keys4) {
  return keys4.reduce((pre, key) => {
    pre[key] = target[key];
    return pre;
  }, {});
}
function pickValues(target, keys4) {
  return keys4.reduce((pre, key) => {
    pre.push(target[key]);
    return pre;
  }, []);
}
function keys2(obj) {
  return Object.keys(obj);
}
function last2(iterable) {
  if (Array.isArray(iterable)) {
    return iterable[iterable.length - 1];
  }
  let last3;
  for (const item of iterable) {
    last3 = item;
  }
  return last3;
}
function nToLast(iterable, n2) {
  if (Array.isArray(iterable)) {
    return iterable[iterable.length - n2];
  }
  const arr = [...iterable];
  return arr[arr.length - n2];
}

// node_modules/@blocksuite/global/dist/utils/logger.js
var NoopLogger = class {
  debug() {
  }
  error() {
  }
  info() {
  }
  warn() {
  }
};

// node_modules/@blocksuite/global/dist/utils/perfect-freehand/getStrokeRadius.js
function getStrokeRadius(size2, thinning, pressure, easing = (t2) => t2) {
  return size2 * easing(0.5 - thinning * (0.5 - pressure));
}

// node_modules/@blocksuite/global/dist/utils/perfect-freehand/vec.js
function neg(A) {
  return [-A[0], -A[1]];
}
function add(A, B) {
  return [A[0] + B[0], A[1] + B[1]];
}
function sub(A, B) {
  return [A[0] - B[0], A[1] - B[1]];
}
function mul(A, n2) {
  return [A[0] * n2, A[1] * n2];
}
function div(A, n2) {
  return [A[0] / n2, A[1] / n2];
}
function per(A) {
  return [A[1], -A[0]];
}
function dpr(A, B) {
  return A[0] * B[0] + A[1] * B[1];
}
function isEqual2(A, B) {
  return A[0] === B[0] && A[1] === B[1];
}
function len(A) {
  return Math.hypot(A[0], A[1]);
}
function len2(A) {
  return A[0] * A[0] + A[1] * A[1];
}
function dist2(A, B) {
  return len2(sub(A, B));
}
function uni(A) {
  return div(A, len(A));
}
function dist(A, B) {
  return Math.hypot(A[1] - B[1], A[0] - B[0]);
}
function rotAround(A, C, r) {
  const s2 = Math.sin(r);
  const c2 = Math.cos(r);
  const px = A[0] - C[0];
  const py = A[1] - C[1];
  const nx = px * c2 - py * s2;
  const ny = px * s2 + py * c2;
  return [nx + C[0], ny + C[1]];
}
function lrp(A, B, t2) {
  return add(A, mul(sub(B, A), t2));
}
function prj(A, B, c2) {
  return add(A, mul(B, c2));
}

// node_modules/@blocksuite/global/dist/utils/perfect-freehand/getStrokeOutlinePoints.js
var { min: min2, PI } = Math;
var RATE_OF_PRESSURE_CHANGE = 0.275;
var FIXED_PI = PI + 1e-4;
function getStrokeOutlinePoints(points, options = {}) {
  const { size: size2 = 16, smoothing = 0.5, thinning = 0.5, simulatePressure = true, easing = (t2) => t2, start = {}, end = {}, last: isComplete = false } = options;
  const { cap: capStart = true, easing: taperStartEase = (t2) => t2 * (2 - t2) } = start;
  const { cap: capEnd = true, easing: taperEndEase = (t2) => --t2 * t2 * t2 + 1 } = end;
  if (points.length === 0 || size2 <= 0) {
    return [];
  }
  const totalLength = points[points.length - 1].runningLength;
  const taperStart = start.taper === false ? 0 : start.taper === true ? Math.max(size2, totalLength) : start.taper;
  const taperEnd = end.taper === false ? 0 : end.taper === true ? Math.max(size2, totalLength) : end.taper;
  const minDistance = Math.pow(size2 * smoothing, 2);
  const leftPts = [];
  const rightPts = [];
  let prevPressure = points.slice(0, 10).reduce((acc, curr) => {
    let pressure = curr.pressure;
    if (simulatePressure) {
      const sp = min2(1, curr.distance / size2);
      const rp = min2(1, 1 - sp);
      pressure = min2(1, acc + (rp - acc) * (sp * RATE_OF_PRESSURE_CHANGE));
    }
    return (acc + pressure) / 2;
  }, points[0].pressure);
  let radius = getStrokeRadius(size2, thinning, points[points.length - 1].pressure, easing);
  let firstRadius = void 0;
  let prevVector = points[0].vector;
  let pl = points[0].point;
  let pr = pl;
  let tl = pl;
  let tr = pr;
  let isPrevPointSharpCorner = false;
  for (let i2 = 0; i2 < points.length; i2++) {
    let { pressure } = points[i2];
    const { point, vector, distance, runningLength } = points[i2];
    if (i2 < points.length - 1 && totalLength - runningLength < 3) {
      continue;
    }
    if (thinning) {
      if (simulatePressure) {
        const sp = min2(1, distance / size2);
        const rp = min2(1, 1 - sp);
        pressure = min2(1, prevPressure + (rp - prevPressure) * (sp * RATE_OF_PRESSURE_CHANGE));
      }
      radius = getStrokeRadius(size2, thinning, pressure, easing);
    } else {
      radius = size2 / 2;
    }
    if (firstRadius === void 0) {
      firstRadius = radius;
    }
    const ts = runningLength < taperStart ? taperStartEase(runningLength / taperStart) : 1;
    const te = totalLength - runningLength < taperEnd ? taperEndEase((totalLength - runningLength) / taperEnd) : 1;
    radius = Math.max(0.01, radius * Math.min(ts, te));
    const nextVector = (i2 < points.length - 1 ? points[i2 + 1] : points[i2]).vector;
    const nextDpr = i2 < points.length - 1 ? dpr(vector, nextVector) : 1;
    const prevDpr = dpr(vector, prevVector);
    const isPointSharpCorner = prevDpr < 0 && !isPrevPointSharpCorner;
    const isNextPointSharpCorner = nextDpr !== null && nextDpr < 0;
    if (isPointSharpCorner || isNextPointSharpCorner) {
      const offset2 = mul(per(prevVector), radius);
      for (let step = 1 / 13, t2 = 0; t2 <= 1; t2 += step) {
        tl = rotAround(sub(point, offset2), point, FIXED_PI * t2);
        leftPts.push(tl);
        tr = rotAround(add(point, offset2), point, FIXED_PI * -t2);
        rightPts.push(tr);
      }
      pl = tl;
      pr = tr;
      if (isNextPointSharpCorner) {
        isPrevPointSharpCorner = true;
      }
      continue;
    }
    isPrevPointSharpCorner = false;
    if (i2 === points.length - 1) {
      const offset2 = mul(per(vector), radius);
      leftPts.push(sub(point, offset2));
      rightPts.push(add(point, offset2));
      continue;
    }
    const offset = mul(per(lrp(nextVector, vector, nextDpr)), radius);
    tl = sub(point, offset);
    if (i2 <= 1 || dist2(pl, tl) > minDistance) {
      leftPts.push(tl);
      pl = tl;
    }
    tr = add(point, offset);
    if (i2 <= 1 || dist2(pr, tr) > minDistance) {
      rightPts.push(tr);
      pr = tr;
    }
    prevPressure = pressure;
    prevVector = vector;
  }
  const firstPoint = points[0].point.slice(0, 2);
  const lastPoint = points.length > 1 ? points[points.length - 1].point.slice(0, 2) : add(points[0].point, [1, 1]);
  const startCap = [];
  const endCap = [];
  if (points.length === 1) {
    if (!(taperStart || taperEnd) || isComplete) {
      const start2 = prj(firstPoint, uni(per(sub(firstPoint, lastPoint))), -(firstRadius || radius));
      const dotPts = [];
      for (let step = 1 / 13, t2 = step; t2 <= 1; t2 += step) {
        dotPts.push(rotAround(start2, firstPoint, FIXED_PI * 2 * t2));
      }
      return dotPts;
    }
  } else {
    if (taperStart || taperEnd && points.length === 1) {
    } else if (capStart) {
      for (let step = 1 / 13, t2 = step; t2 <= 1; t2 += step) {
        const pt = rotAround(rightPts[0], firstPoint, FIXED_PI * t2);
        startCap.push(pt);
      }
    } else {
      const cornersVector = sub(leftPts[0], rightPts[0]);
      const offsetA = mul(cornersVector, 0.5);
      const offsetB = mul(cornersVector, 0.51);
      startCap.push(sub(firstPoint, offsetA), sub(firstPoint, offsetB), add(firstPoint, offsetB), add(firstPoint, offsetA));
    }
    const direction = per(neg(points[points.length - 1].vector));
    if (taperEnd || taperStart && points.length === 1) {
      endCap.push(lastPoint);
    } else if (capEnd) {
      const start2 = prj(lastPoint, direction, radius);
      for (let step = 1 / 29, t2 = step; t2 < 1; t2 += step) {
        endCap.push(rotAround(start2, lastPoint, FIXED_PI * 3 * t2));
      }
    } else {
      endCap.push(add(lastPoint, mul(direction, radius)), add(lastPoint, mul(direction, radius * 0.99)), sub(lastPoint, mul(direction, radius * 0.99)), sub(lastPoint, mul(direction, radius)));
    }
  }
  return leftPts.concat(endCap, rightPts.reverse(), startCap);
}

// node_modules/@blocksuite/global/dist/utils/perfect-freehand/getStrokePoints.js
function getStrokePoints(points, options = {}) {
  const { streamline = 0.5, size: size2 = 16, last: isComplete = false } = options;
  if (points.length === 0)
    return [];
  const t2 = 0.15 + (1 - streamline) * 0.85;
  let pts = Array.isArray(points[0]) ? points : points.map(({ x, y: y2, pressure = 0.5 }) => [x, y2, pressure]);
  if (pts.length === 2) {
    const last3 = pts[1];
    pts = pts.slice(0, -1);
    for (let i2 = 1; i2 < 5; i2++) {
      pts.push(lrp(pts[0], last3, i2 / 4));
    }
  }
  if (pts.length === 1) {
    pts = [
      ...pts,
      [...add(pts[0], [1, 1]), ...pts[0].slice(2)]
    ];
  }
  const strokePoints = [
    {
      point: [pts[0][0], pts[0][1]],
      pressure: (pts[0][2] ?? -1) >= 0 ? pts[0][2] : 0.25,
      vector: [1, 1],
      distance: 0,
      runningLength: 0
    }
  ];
  let hasReachedMinimumLength = false;
  let runningLength = 0;
  let prev = strokePoints[0];
  const max2 = pts.length - 1;
  for (let i2 = 1; i2 < pts.length; i2++) {
    const point = isComplete && i2 === max2 ? (
      // If we're at the last point, and `options.last` is true,
      // then add the actual input point.
      pts[i2].slice(0, 2)
    ) : (
      // Otherwise, using the t calculated from the streamline
      // option, interpolate a new point between the previous
      // point the current point.
      lrp(prev.point, pts[i2], t2)
    );
    if (isEqual2(prev.point, point))
      continue;
    const distance = dist(point, prev.point);
    runningLength += distance;
    if (i2 < max2 && !hasReachedMinimumLength) {
      if (runningLength < size2)
        continue;
      hasReachedMinimumLength = true;
    }
    prev = {
      // The adjusted point
      point,
      // The input pressure (or .5 if not specified)
      pressure: (pts[i2][2] ?? -1) >= 0 ? pts[i2][2] : 0.5,
      // The vector from the current point to the previous point
      vector: uni(sub(prev.point, point)),
      // The distance between the current point and the previous point
      distance,
      // The total distance so far
      runningLength
    };
    strokePoints.push(prev);
  }
  strokePoints[0].vector = strokePoints[1]?.vector || [0, 0];
  return strokePoints;
}

// node_modules/@blocksuite/global/dist/utils/perfect-freehand/getStroke.js
function getStroke(points, options = {}) {
  return getStrokeOutlinePoints(getStrokePoints(points, options), options);
}

// node_modules/@blocksuite/global/dist/utils/perfect-freehand/getSolidStrokePoints.js
function getSolidStrokePoints(points, lineWidth) {
  return getStroke(points, {
    size: lineWidth,
    thinning: 0.6,
    streamline: 0.5,
    smoothing: 0.5,
    easing: (t2) => Math.sin(t2 * Math.PI / 2),
    simulatePressure: points[0]?.length === 2
  });
}

// node_modules/@blocksuite/global/dist/utils/polyline.js
var Polyline = class _Polyline {
  static len(points) {
    const n2 = points.length;
    if (n2 < 2) {
      return 0;
    }
    let i2 = 0;
    let len3 = 0;
    let curr;
    let prev = points[0];
    while (++i2 < n2) {
      curr = points[i2];
      len3 += Vec.dist(prev, curr);
      prev = curr;
    }
    return len3;
  }
  static lenAtPoint(points, point) {
    const n2 = points.length;
    let len3 = n2;
    for (let i2 = 0; i2 < n2 - 1; i2++) {
      const a2 = points[i2];
      const b2 = points[i2 + 1];
      if (a2[0] === point[0] && a2[1] === point[1]) {
        return len3;
      }
      const aa = Vec.angle(a2, point);
      const ba = Vec.angle(b2, point);
      if ((aa + ba) % Math.PI === 0) {
        len3 += Vec.dist(a2, point);
        return len3;
      }
      len3 += Vec.dist(a2, b2);
      if (b2[0] === point[0] && b2[1] === point[1]) {
        return len3;
      }
    }
    return len3;
  }
  static nearestPoint(points, point) {
    const n2 = points.length;
    const r = [0, 0];
    let len3 = Infinity;
    for (let i2 = 0; i2 < n2 - 1; i2++) {
      const a2 = points[i2];
      const b2 = points[i2 + 1];
      const p2 = Vec.nearestPointOnLineSegment(a2, b2, point, true);
      const d2 = Vec.dist(p2, point);
      if (d2 < len3) {
        len3 = d2;
        r[0] = p2[0];
        r[1] = p2[1];
      }
    }
    return r;
  }
  static pointAt(points, ratio) {
    const n2 = points.length;
    if (n2 === 0) {
      return null;
    }
    if (n2 === 1) {
      return points[0];
    }
    if (ratio <= 0) {
      return points[0];
    }
    if (ratio >= 1) {
      return points[n2 - 1];
    }
    const total = _Polyline.len(points);
    const len3 = total * ratio;
    return _Polyline.pointAtLen(points, len3);
  }
  static pointAtLen(points, len3) {
    const n2 = points.length;
    if (n2 === 0) {
      return null;
    }
    if (n2 === 1) {
      return points[0];
    }
    let fromStart = true;
    if (len3 < 0) {
      fromStart = false;
      len3 = -len3;
    }
    let tmp = 0;
    for (let j = 0, k = n2 - 1; j < k; j++) {
      const i2 = fromStart ? j : k - 1 - j;
      const a2 = points[i2];
      const b2 = points[i2 + 1];
      const d2 = Vec.dist(a2, b2);
      if (len3 <= tmp + d2) {
        const t2 = (fromStart ? 1 : -1) * (len3 - tmp) / d2;
        return Vec.lrp(a2, b2, t2);
      }
      tmp += d2;
    }
    const lastPoint = fromStart ? points[n2 - 1] : points[0];
    return lastPoint;
  }
};

// node_modules/@preact/signals-core/dist/signals-core.module.js
var i = Symbol.for("preact-signals");
function t() {
  if (!(s > 1)) {
    var i2, t2 = false;
    while (void 0 !== h) {
      var r = h;
      h = void 0;
      f++;
      while (void 0 !== r) {
        var o2 = r.o;
        r.o = void 0;
        r.f &= -3;
        if (!(8 & r.f) && c(r)) try {
          r.c();
        } catch (r2) {
          if (!t2) {
            i2 = r2;
            t2 = true;
          }
        }
        r = o2;
      }
    }
    f = 0;
    s--;
    if (t2) throw i2;
  } else s--;
}
var o = void 0;
function n(i2) {
  var t2 = o;
  o = void 0;
  try {
    return i2();
  } finally {
    o = t2;
  }
}
var h = void 0;
var s = 0;
var f = 0;
var v = 0;
function e(i2) {
  if (void 0 !== o) {
    var t2 = i2.n;
    if (void 0 === t2 || t2.t !== o) {
      t2 = { i: 0, S: i2, p: o.s, n: void 0, t: o, e: void 0, x: void 0, r: t2 };
      if (void 0 !== o.s) o.s.n = t2;
      o.s = t2;
      i2.n = t2;
      if (32 & o.f) i2.S(t2);
      return t2;
    } else if (-1 === t2.i) {
      t2.i = 0;
      if (void 0 !== t2.n) {
        t2.n.p = t2.p;
        if (void 0 !== t2.p) t2.p.n = t2.n;
        t2.p = o.s;
        t2.n = void 0;
        o.s.n = t2;
        o.s = t2;
      }
      return t2;
    }
  }
}
function u(i2, t2) {
  this.v = i2;
  this.i = 0;
  this.n = void 0;
  this.t = void 0;
  this.W = null == t2 ? void 0 : t2.watched;
  this.Z = null == t2 ? void 0 : t2.unwatched;
  this.name = null == t2 ? void 0 : t2.name;
}
u.prototype.brand = i;
u.prototype.h = function() {
  return true;
};
u.prototype.S = function(i2) {
  var t2 = this, r = this.t;
  if (r !== i2 && void 0 === i2.e) {
    i2.x = r;
    this.t = i2;
    if (void 0 !== r) r.e = i2;
    else n(function() {
      var i3;
      null == (i3 = t2.W) || i3.call(t2);
    });
  }
};
u.prototype.U = function(i2) {
  var t2 = this;
  if (void 0 !== this.t) {
    var r = i2.e, o2 = i2.x;
    if (void 0 !== r) {
      r.x = o2;
      i2.e = void 0;
    }
    if (void 0 !== o2) {
      o2.e = r;
      i2.x = void 0;
    }
    if (i2 === this.t) {
      this.t = o2;
      if (void 0 === o2) n(function() {
        var i3;
        null == (i3 = t2.Z) || i3.call(t2);
      });
    }
  }
};
u.prototype.subscribe = function(i2) {
  var t2 = this;
  return E(function() {
    var r = t2.value, n2 = o;
    o = void 0;
    try {
      i2(r);
    } finally {
      o = n2;
    }
  }, { name: "sub" });
};
u.prototype.valueOf = function() {
  return this.value;
};
u.prototype.toString = function() {
  return this.value + "";
};
u.prototype.toJSON = function() {
  return this.value;
};
u.prototype.peek = function() {
  var i2 = o;
  o = void 0;
  try {
    return this.value;
  } finally {
    o = i2;
  }
};
Object.defineProperty(u.prototype, "value", { get: function() {
  var i2 = e(this);
  if (void 0 !== i2) i2.i = this.i;
  return this.v;
}, set: function(i2) {
  if (i2 !== this.v) {
    if (f > 100) throw new Error("Cycle detected");
    this.v = i2;
    this.i++;
    v++;
    s++;
    try {
      for (var r = this.t; void 0 !== r; r = r.x) r.t.N();
    } finally {
      t();
    }
  }
} });
function d(i2, t2) {
  return new u(i2, t2);
}
function c(i2) {
  for (var t2 = i2.s; void 0 !== t2; t2 = t2.n) if (t2.S.i !== t2.i || !t2.S.h() || t2.S.i !== t2.i) return true;
  return false;
}
function a(i2) {
  for (var t2 = i2.s; void 0 !== t2; t2 = t2.n) {
    var r = t2.S.n;
    if (void 0 !== r) t2.r = r;
    t2.S.n = t2;
    t2.i = -1;
    if (void 0 === t2.n) {
      i2.s = t2;
      break;
    }
  }
}
function l(i2) {
  var t2 = i2.s, r = void 0;
  while (void 0 !== t2) {
    var o2 = t2.p;
    if (-1 === t2.i) {
      t2.S.U(t2);
      if (void 0 !== o2) o2.n = t2.n;
      if (void 0 !== t2.n) t2.n.p = o2;
    } else r = t2;
    t2.S.n = t2.r;
    if (void 0 !== t2.r) t2.r = void 0;
    t2 = o2;
  }
  i2.s = r;
}
function y(i2, t2) {
  u.call(this, void 0);
  this.x = i2;
  this.s = void 0;
  this.g = v - 1;
  this.f = 4;
  this.W = null == t2 ? void 0 : t2.watched;
  this.Z = null == t2 ? void 0 : t2.unwatched;
  this.name = null == t2 ? void 0 : t2.name;
}
y.prototype = new u();
y.prototype.h = function() {
  this.f &= -3;
  if (1 & this.f) return false;
  if (32 == (36 & this.f)) return true;
  this.f &= -5;
  if (this.g === v) return true;
  this.g = v;
  this.f |= 1;
  if (this.i > 0 && !c(this)) {
    this.f &= -2;
    return true;
  }
  var i2 = o;
  try {
    a(this);
    o = this;
    var t2 = this.x();
    if (16 & this.f || this.v !== t2 || 0 === this.i) {
      this.v = t2;
      this.f &= -17;
      this.i++;
    }
  } catch (i3) {
    this.v = i3;
    this.f |= 16;
    this.i++;
  }
  o = i2;
  l(this);
  this.f &= -2;
  return true;
};
y.prototype.S = function(i2) {
  if (void 0 === this.t) {
    this.f |= 36;
    for (var t2 = this.s; void 0 !== t2; t2 = t2.n) t2.S.S(t2);
  }
  u.prototype.S.call(this, i2);
};
y.prototype.U = function(i2) {
  if (void 0 !== this.t) {
    u.prototype.U.call(this, i2);
    if (void 0 === this.t) {
      this.f &= -33;
      for (var t2 = this.s; void 0 !== t2; t2 = t2.n) t2.S.U(t2);
    }
  }
};
y.prototype.N = function() {
  if (!(2 & this.f)) {
    this.f |= 6;
    for (var i2 = this.t; void 0 !== i2; i2 = i2.x) i2.t.N();
  }
};
Object.defineProperty(y.prototype, "value", { get: function() {
  if (1 & this.f) throw new Error("Cycle detected");
  var i2 = e(this);
  this.h();
  if (void 0 !== i2) i2.i = this.i;
  if (16 & this.f) throw this.v;
  return this.v;
} });
function w(i2, t2) {
  return new y(i2, t2);
}
function _(i2) {
  var r = i2.u;
  i2.u = void 0;
  if ("function" == typeof r) {
    s++;
    var n2 = o;
    o = void 0;
    try {
      r();
    } catch (t2) {
      i2.f &= -2;
      i2.f |= 8;
      b(i2);
      throw t2;
    } finally {
      o = n2;
      t();
    }
  }
}
function b(i2) {
  for (var t2 = i2.s; void 0 !== t2; t2 = t2.n) t2.S.U(t2);
  i2.x = void 0;
  i2.s = void 0;
  _(i2);
}
function g(i2) {
  if (o !== this) throw new Error("Out-of-order effect");
  l(this);
  o = i2;
  this.f &= -2;
  if (8 & this.f) b(this);
  t();
}
function p(i2, t2) {
  this.x = i2;
  this.u = void 0;
  this.s = void 0;
  this.o = void 0;
  this.f = 32;
  this.name = null == t2 ? void 0 : t2.name;
}
p.prototype.c = function() {
  var i2 = this.S();
  try {
    if (8 & this.f) return;
    if (void 0 === this.x) return;
    var t2 = this.x();
    if ("function" == typeof t2) this.u = t2;
  } finally {
    i2();
  }
};
p.prototype.S = function() {
  if (1 & this.f) throw new Error("Cycle detected");
  this.f |= 1;
  this.f &= -9;
  _(this);
  a(this);
  s++;
  var i2 = o;
  o = this;
  return g.bind(this, i2);
};
p.prototype.N = function() {
  if (!(2 & this.f)) {
    this.f |= 2;
    this.o = h;
    h = this;
  }
};
p.prototype.d = function() {
  this.f |= 8;
  if (!(1 & this.f)) b(this);
};
p.prototype.dispose = function() {
  this.d();
};
function E(i2, t2) {
  var r = new p(i2, t2);
  try {
    r.c();
  } catch (i3) {
    r.d();
    throw i3;
  }
  var o2 = r.d.bind(r);
  o2[Symbol.dispose] = o2;
  return o2;
}

// node_modules/@blocksuite/global/dist/utils/signal-watcher.js
function SignalWatcher(Base) {
  class SignalWatcher2 extends Base {
    connectedCallback() {
      super.connectedCallback();
      this.requestUpdate();
    }
    disconnectedCallback() {
      super.disconnectedCallback();
      this.__dispose?.();
    }
    performUpdate() {
      if (this.isUpdatePending === false || this.isConnected === false) {
        return;
      }
      this.__dispose?.();
      let updateFromLit = true;
      this.__dispose = E(() => {
        if (updateFromLit) {
          updateFromLit = false;
          super.performUpdate();
        } else {
          this.requestUpdate();
        }
      });
    }
  }
  return SignalWatcher2;
}

// node_modules/@blocksuite/global/dist/utils/slot.js
var Slot = class _Slot {
  constructor() {
    this._callbacks = [];
    this._disposables = [];
    this._emitting = false;
    this.subscribe = (selector, callback, config) => {
      let prevState;
      const { filter: filter2, equalityFn = Object.is } = config ?? {};
      return this.on((state) => {
        if (filter2 && !filter2(state)) {
          return;
        }
        const nextState = selector(state);
        if (prevState === void 0 || !equalityFn(prevState, nextState)) {
          callback(nextState);
          prevState = nextState;
        }
      });
    };
  }
  dispose() {
    flattenDisposables(this._disposables).dispose();
    this._callbacks = [];
    this._disposables = [];
  }
  emit(v2) {
    const prevEmitting = this._emitting;
    this._emitting = true;
    this._callbacks.forEach((f2) => {
      try {
        f2(v2);
      } catch (err) {
        console.error(err);
      }
    });
    this._emitting = prevEmitting;
  }
  filter(testFun) {
    const result = new _Slot();
    this._disposables.push({
      dispose: () => result.dispose()
    });
    this.on((v2) => {
      if (testFun(v2)) {
        result.emit(v2);
      }
    });
    return result;
  }
  flatMap(mapper) {
    const result = new _Slot();
    this._disposables.push({
      dispose: () => result.dispose()
    });
    this.on((v2) => {
      const data = mapper(v2);
      if (Array.isArray(data)) {
        data.forEach((v3) => result.emit(v3));
      } else {
        result.emit(data);
      }
    });
    return result;
  }
  on(callback) {
    if (this._emitting) {
      const newCallback = [...this._callbacks, callback];
      this._callbacks = newCallback;
    } else {
      this._callbacks.push(callback);
    }
    return {
      dispose: () => {
        if (this._emitting) {
          this._callbacks = this._callbacks.filter((v2) => v2 !== callback);
        } else {
          const index = this._callbacks.indexOf(callback);
          if (index > -1) {
            this._callbacks.splice(index, 1);
          }
        }
      }
    };
  }
  once(callback) {
    let dispose = void 0;
    const handler = (v2) => {
      callback(v2);
      if (dispose) {
        dispose();
      }
    };
    const disposable = this.on(handler);
    dispose = disposable.dispose;
    return disposable;
  }
  pipe(that) {
    this._callbacks.push((v2) => that.emit(v2));
    return this;
  }
  toDispose(disposables) {
    disposables.push(this);
    return this;
  }
  unshift(callback) {
    if (this._emitting) {
      const newCallback = [callback, ...this._callbacks];
      this._callbacks = newCallback;
    } else {
      this._callbacks.unshift(callback);
    }
    return {
      dispose: () => {
        if (this._emitting) {
          this._callbacks = this._callbacks.filter((v2) => v2 !== callback);
        } else {
          const index = this._callbacks.indexOf(callback);
          if (index > -1) {
            this._callbacks.splice(index, 1);
          }
        }
      }
    };
  }
};

// node_modules/@blocksuite/global/dist/utils/with-disposable.js
function WithDisposable(SuperClass) {
  class DerivedClass extends SuperClass {
    constructor() {
      super(...arguments);
      this._disposables = new DisposableGroup();
    }
    get disposables() {
      return this._disposables;
    }
    connectedCallback() {
      super.connectedCallback();
      if (this._disposables.disposed) {
        this._disposables = new DisposableGroup();
      }
    }
    disconnectedCallback() {
      super.disconnectedCallback();
      this._disposables.dispose();
    }
  }
  return DerivedClass;
}

// node_modules/@blocksuite/store/dist/adapter/assets.js
var MemoryBlobCRUD = class {
  constructor() {
    this._map = /* @__PURE__ */ new Map();
  }
  delete(key) {
    this._map.delete(key);
  }
  get(key) {
    return this._map.get(key) ?? null;
  }
  list() {
    return Array.from(this._map.keys());
  }
  async set(valueOrKey, _value) {
    const key = typeof valueOrKey === "string" ? valueOrKey : await sha(await valueOrKey.arrayBuffer());
    const value = typeof valueOrKey === "string" ? _value : valueOrKey;
    if (!value) {
      throw new BlockSuiteError(ErrorCode.TransformerError, "value is required");
    }
    this._map.set(key, value);
    return key;
  }
};
var mimeExtMap = /* @__PURE__ */ new Map([
  ["application/epub+zip", "epub"],
  ["application/gzip", "gz"],
  ["application/java-archive", "jar"],
  ["application/json", "json"],
  ["application/ld+json", "jsonld"],
  ["application/msword", "doc"],
  ["application/octet-stream", "bin"],
  ["application/ogg", "ogx"],
  ["application/pdf", "pdf"],
  ["application/rtf", "rtf"],
  ["application/vnd.amazon.ebook", "azw"],
  ["application/vnd.apple.installer+xml", "mpkg"],
  ["application/vnd.mozilla.xul+xml", "xul"],
  ["application/vnd.ms-excel", "xls"],
  ["application/vnd.ms-fontobject", "eot"],
  ["application/vnd.ms-powerpoint", "ppt"],
  ["application/vnd.oasis.opendocument.presentation", "odp"],
  ["application/vnd.oasis.opendocument.spreadsheet", "ods"],
  ["application/vnd.oasis.opendocument.text", "odt"],
  [
    "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    "pptx"
  ],
  ["application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", "xlsx"],
  [
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    "docx"
  ],
  ["application/vnd.rar", "rar"],
  ["application/vnd.visio", "vsd"],
  ["application/x-7z-compressed", "7z"],
  ["application/x-abiword", "abw"],
  ["application/x-bzip", "bz"],
  ["application/x-bzip2", "bz2"],
  ["application/x-cdf", "cda"],
  ["application/x-csh", "csh"],
  ["application/x-freearc", "arc"],
  ["application/x-httpd-php", "php"],
  ["application/x-sh", "sh"],
  ["application/x-tar", "tar"],
  ["application/xhtml+xml", "xhtml"],
  ["application/xml", "xml"],
  ["application/zip", "zip"],
  ["application/zstd", "zst"],
  ["audio/3gpp", "3gp"],
  ["audio/3gpp2", "3g2"],
  ["audio/aac", "aac"],
  ["audio/midi", "mid"],
  ["audio/mpeg", "mp3"],
  ["audio/ogg", "oga"],
  ["audio/opus", "opus"],
  ["audio/wav", "wav"],
  ["audio/webm", "weba"],
  ["audio/x-midi", "midi"],
  ["font/otf", "otf"],
  ["font/ttf", "ttf"],
  ["font/woff", "woff"],
  ["font/woff2", "woff2"],
  ["image/apng", "apng"],
  ["image/avif", "avif"],
  ["image/bmp", "bmp"],
  ["image/gif", "gif"],
  ["image/jpeg", "jpeg"],
  ["image/png", "png"],
  ["image/svg+xml", "svg"],
  ["image/tiff", "tiff"],
  ["image/vnd.microsoft.icon", "ico"],
  ["image/webp", "webp"],
  ["text/calendar", "ics"],
  ["text/css", "css"],
  ["text/csv", "csv"],
  ["text/html", "html"],
  ["text/javascript", "js"],
  ["text/plain", "txt"],
  ["text/xml", "xml"],
  ["video/3gpp", "3gp"],
  ["video/3gpp2", "3g2"],
  ["video/mp2t", "ts"],
  ["video/mp4", "mp4"],
  ["video/mpeg", "mpeg"],
  ["video/ogg", "ogv"],
  ["video/webm", "webm"],
  ["video/x-msvideo", "avi"]
]);
var extMimeMap = new Map(Array.from(mimeExtMap.entries()).map(([mime, ext2]) => [ext2, mime]));
var getExt = (type) => {
  if (type === "")
    return "blob";
  const ext2 = mimeExtMap.get(type);
  if (ext2)
    return ext2;
  const guessExt = type.split("/");
  return guessExt.at(-1) ?? "blob";
};
function getAssetName(assets, blobId) {
  const blob = assets.get(blobId);
  if (!blob) {
    throw new BlockSuiteError(ErrorCode.TransformerError, `blob not found for blobId: ${blobId}`);
  }
  const name = "name" in blob && typeof blob.name === "string" ? blob.name : void 0;
  if (name) {
    if (name.includes("."))
      return name;
    return `${name}.${getExt(blob.type)}`;
  }
  return `${blobId}.${getExt(blob.type)}`;
}

// node_modules/@blocksuite/store/dist/adapter/context.js
var ASTWalkerContext = class {
  constructor() {
    this._defaultProp = "children";
    this._globalContext = /* @__PURE__ */ Object.create(null);
    this._stack = [];
    this._skip = false;
    this._skipChildrenNum = 0;
    this.setDefaultProp = (parentProp) => {
      this._defaultProp = parentProp;
    };
  }
  get stack() {
    return this._stack;
  }
  current() {
    return this._stack[this._stack.length - 1];
  }
  cleanGlobalContextStack(key) {
    if (this._globalContext[key] instanceof Array) {
      this._globalContext[key] = [];
    }
  }
  closeNode() {
    const ele = this._stack.pop();
    if (!ele)
      return this;
    const parent = this._stack.pop();
    if (!parent) {
      this._stack.push(ele);
      return this;
    }
    if (parent.node[ele.prop] instanceof Array) {
      parent.node[ele.prop].push(ele.node);
    }
    this._stack.push(parent);
    return this;
  }
  currentNode() {
    return this.current()?.node;
  }
  getGlobalContext(key) {
    return this._globalContext[key];
  }
  getGlobalContextStack(key) {
    const stack = this._globalContext[key];
    if (stack instanceof Array) {
      return stack;
    } else {
      return [];
    }
  }
  getNodeContext(key) {
    return this.current().context[key];
  }
  getPreviousNodeContext(key) {
    return this._stack[this._stack.length - 2]?.context[key];
  }
  openNode(node, parentProp) {
    this._stack.push({
      node,
      prop: parentProp ?? this._defaultProp,
      context: /* @__PURE__ */ Object.create(null)
    });
    return this;
  }
  previousNode() {
    return this._stack[this._stack.length - 2]?.node;
  }
  pushGlobalContextStack(key, value) {
    const stack = this._globalContext[key];
    if (stack instanceof Array) {
      stack.push(value);
    } else {
      this._globalContext[key] = [value];
    }
  }
  setGlobalContext(key, value) {
    this._globalContext[key] = value;
    return this;
  }
  setGlobalContextStack(key, value) {
    this._globalContext[key] = value;
  }
  setNodeContext(key, value) {
    this._stack[this._stack.length - 1].context[key] = value;
    return this;
  }
  skipAllChildren() {
    this._skip = true;
  }
  skipChildren(num = 1) {
    this._skipChildrenNum = num;
  }
};

// node_modules/@blocksuite/store/dist/adapter/base.js
function wrapFakeNote(snapshot2) {
  if (snapshot2.content[0]?.flavour !== "affine:note") {
    snapshot2.content = [
      {
        type: "block",
        id: "",
        flavour: "affine:note",
        props: {},
        children: snapshot2.content
      }
    ];
  }
}
var BaseAdapter = class {
  get configs() {
    return this.job.adapterConfigs;
  }
  constructor(job) {
    this.job = job;
  }
  async fromBlock(model) {
    try {
      const blockSnapshot = this.job.blockToSnapshot(model);
      if (!blockSnapshot)
        return;
      return await this.fromBlockSnapshot({
        snapshot: blockSnapshot,
        assets: this.job.assetsManager
      });
    } catch (error) {
      console.error("Cannot convert block to snapshot");
      console.error(error);
      return;
    }
  }
  async fromDoc(doc2) {
    try {
      const docSnapshot = this.job.docToSnapshot(doc2);
      if (!docSnapshot)
        return;
      return await this.fromDocSnapshot({
        snapshot: docSnapshot,
        assets: this.job.assetsManager
      });
    } catch (error) {
      console.error("Cannot convert doc to snapshot");
      console.error(error);
      return;
    }
  }
  async fromSlice(slice) {
    try {
      const sliceSnapshot = this.job.sliceToSnapshot(slice);
      if (!sliceSnapshot)
        return;
      wrapFakeNote(sliceSnapshot);
      return await this.fromSliceSnapshot({
        snapshot: sliceSnapshot,
        assets: this.job.assetsManager
      });
    } catch (error) {
      console.error("Cannot convert slice to snapshot");
      console.error(error);
      return;
    }
  }
  async toBlock(payload, doc2, parent, index) {
    try {
      const snapshot2 = await this.toBlockSnapshot(payload);
      if (!snapshot2)
        return;
      return await this.job.snapshotToBlock(snapshot2, doc2, parent, index);
    } catch (error) {
      console.error("Cannot convert block snapshot to block");
      console.error(error);
      return;
    }
  }
  async toDoc(payload) {
    try {
      const snapshot2 = await this.toDocSnapshot(payload);
      if (!snapshot2)
        return;
      return await this.job.snapshotToDoc(snapshot2);
    } catch (error) {
      console.error("Cannot convert doc snapshot to doc");
      console.error(error);
      return;
    }
  }
  async toSlice(payload, doc2, parent, index) {
    try {
      const snapshot2 = await this.toSliceSnapshot(payload);
      if (!snapshot2)
        return;
      return await this.job.snapshotToSlice(snapshot2, doc2, parent, index);
    } catch (error) {
      console.error("Cannot convert slice snapshot to slice");
      console.error(error);
      return;
    }
  }
};
var ASTWalker = class {
  constructor() {
    this._visit = async (o2) => {
      if (!o2.node)
        return;
      this.context._skipChildrenNum = 0;
      this.context._skip = false;
      if (this._enter) {
        await this._enter(o2, this.context);
      }
      if (this.context._skip) {
        return;
      }
      for (const key in o2.node) {
        const value = o2.node[key];
        if (value && typeof value === "object") {
          if (Array.isArray(value)) {
            for (let i2 = this.context._skipChildrenNum; i2 < value.length; i2 += 1) {
              const item = value[i2];
              if (item !== null && typeof item === "object" && this._isONode(item)) {
                const nextItem = value[i2 + 1] ?? null;
                await this._visit({
                  node: item,
                  next: nextItem,
                  parent: o2,
                  prop: key,
                  index: i2
                });
              }
            }
          } else if (this.context._skipChildrenNum === 0 && this._isONode(value)) {
            await this._visit({
              node: value,
              next: null,
              parent: o2,
              prop: key,
              index: null
            });
          }
        }
      }
      if (this._leave) {
        await this._leave(o2, this.context);
      }
    };
    this.setEnter = (fn) => {
      this._enter = fn;
    };
    this.setLeave = (fn) => {
      this._leave = fn;
    };
    this.setONodeTypeGuard = (fn) => {
      this._isONode = fn;
    };
    this.walk = async (oNode, tNode) => {
      this.context.openNode(tNode);
      await this._visit({ node: oNode, parent: null, prop: null, index: null });
      if (this.context.stack.length !== 1) {
        throw new BlockSuiteError(1, "There are unclosed nodes");
      }
      return this.context.currentNode();
    };
    this.walkONode = async (oNode) => {
      await this._visit({ node: oNode, parent: null, prop: null, index: null });
    };
    this.context = new ASTWalkerContext();
  }
};

// node_modules/yjs/dist/yjs.mjs
var yjs_exports = {};
__export(yjs_exports, {
  AbsolutePosition: () => AbsolutePosition,
  AbstractConnector: () => AbstractConnector,
  AbstractStruct: () => AbstractStruct,
  AbstractType: () => AbstractType,
  Array: () => YArray,
  ContentAny: () => ContentAny,
  ContentBinary: () => ContentBinary,
  ContentDeleted: () => ContentDeleted,
  ContentDoc: () => ContentDoc,
  ContentEmbed: () => ContentEmbed,
  ContentFormat: () => ContentFormat,
  ContentJSON: () => ContentJSON,
  ContentString: () => ContentString,
  ContentType: () => ContentType,
  Doc: () => Doc,
  GC: () => GC,
  ID: () => ID,
  Item: () => Item,
  Map: () => YMap,
  PermanentUserData: () => PermanentUserData,
  RelativePosition: () => RelativePosition,
  Skip: () => Skip,
  Snapshot: () => Snapshot,
  Text: () => YText,
  Transaction: () => Transaction,
  UndoManager: () => UndoManager,
  UpdateDecoderV1: () => UpdateDecoderV1,
  UpdateDecoderV2: () => UpdateDecoderV2,
  UpdateEncoderV1: () => UpdateEncoderV1,
  UpdateEncoderV2: () => UpdateEncoderV2,
  XmlElement: () => YXmlElement,
  XmlFragment: () => YXmlFragment,
  XmlHook: () => YXmlHook,
  XmlText: () => YXmlText,
  YArrayEvent: () => YArrayEvent,
  YEvent: () => YEvent,
  YMapEvent: () => YMapEvent,
  YTextEvent: () => YTextEvent,
  YXmlEvent: () => YXmlEvent,
  applyUpdate: () => applyUpdate,
  applyUpdateV2: () => applyUpdateV2,
  cleanupYTextFormatting: () => cleanupYTextFormatting,
  compareIDs: () => compareIDs,
  compareRelativePositions: () => compareRelativePositions,
  convertUpdateFormatV1ToV2: () => convertUpdateFormatV1ToV2,
  convertUpdateFormatV2ToV1: () => convertUpdateFormatV2ToV1,
  createAbsolutePositionFromRelativePosition: () => createAbsolutePositionFromRelativePosition,
  createDeleteSet: () => createDeleteSet,
  createDeleteSetFromStructStore: () => createDeleteSetFromStructStore,
  createDocFromSnapshot: () => createDocFromSnapshot,
  createID: () => createID,
  createRelativePositionFromJSON: () => createRelativePositionFromJSON,
  createRelativePositionFromTypeIndex: () => createRelativePositionFromTypeIndex,
  createSnapshot: () => createSnapshot,
  decodeRelativePosition: () => decodeRelativePosition,
  decodeSnapshot: () => decodeSnapshot,
  decodeSnapshotV2: () => decodeSnapshotV2,
  decodeStateVector: () => decodeStateVector,
  decodeUpdate: () => decodeUpdate,
  decodeUpdateV2: () => decodeUpdateV2,
  diffUpdate: () => diffUpdate,
  diffUpdateV2: () => diffUpdateV2,
  emptySnapshot: () => emptySnapshot,
  encodeRelativePosition: () => encodeRelativePosition,
  encodeSnapshot: () => encodeSnapshot,
  encodeSnapshotV2: () => encodeSnapshotV2,
  encodeStateAsUpdate: () => encodeStateAsUpdate,
  encodeStateAsUpdateV2: () => encodeStateAsUpdateV2,
  encodeStateVector: () => encodeStateVector,
  encodeStateVectorFromUpdate: () => encodeStateVectorFromUpdate,
  encodeStateVectorFromUpdateV2: () => encodeStateVectorFromUpdateV2,
  equalDeleteSets: () => equalDeleteSets,
  equalSnapshots: () => equalSnapshots,
  findIndexSS: () => findIndexSS,
  findRootTypeKey: () => findRootTypeKey,
  getItem: () => getItem,
  getItemCleanEnd: () => getItemCleanEnd,
  getItemCleanStart: () => getItemCleanStart,
  getState: () => getState,
  getTypeChildren: () => getTypeChildren,
  isDeleted: () => isDeleted,
  isParentOf: () => isParentOf,
  iterateDeletedStructs: () => iterateDeletedStructs,
  logType: () => logType,
  logUpdate: () => logUpdate,
  logUpdateV2: () => logUpdateV2,
  mergeDeleteSets: () => mergeDeleteSets,
  mergeUpdates: () => mergeUpdates,
  mergeUpdatesV2: () => mergeUpdatesV2,
  obfuscateUpdate: () => obfuscateUpdate,
  obfuscateUpdateV2: () => obfuscateUpdateV2,
  parseUpdateMeta: () => parseUpdateMeta,
  parseUpdateMetaV2: () => parseUpdateMetaV2,
  readUpdate: () => readUpdate,
  readUpdateV2: () => readUpdateV2,
  relativePositionToJSON: () => relativePositionToJSON,
  snapshot: () => snapshot,
  snapshotContainsUpdate: () => snapshotContainsUpdate,
  transact: () => transact,
  tryGc: () => tryGc,
  typeListToArraySnapshot: () => typeListToArraySnapshot,
  typeMapGetAllSnapshot: () => typeMapGetAllSnapshot,
  typeMapGetSnapshot: () => typeMapGetSnapshot
});

// node_modules/lib0/observable.js
var ObservableV2 = class {
  constructor() {
    this._observers = create2();
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  on(name, f2) {
    setIfUndefined(
      this._observers,
      /** @type {string} */
      name,
      create
    ).add(f2);
    return f2;
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  once(name, f2) {
    const _f = (...args2) => {
      this.off(
        name,
        /** @type {any} */
        _f
      );
      f2(...args2);
    };
    this.on(
      name,
      /** @type {any} */
      _f
    );
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  off(name, f2) {
    const observers = this._observers.get(name);
    if (observers !== void 0) {
      observers.delete(f2);
      if (observers.size === 0) {
        this._observers.delete(name);
      }
    }
  }
  /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name The event name.
   * @param {Parameters<EVENTS[NAME]>} args The arguments that are applied to the event listener.
   */
  emit(name, args2) {
    return from2((this._observers.get(name) || create2()).values()).forEach((f2) => f2(...args2));
  }
  destroy() {
    this._observers = create2();
  }
};
var Observable = class {
  constructor() {
    this._observers = create2();
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  on(name, f2) {
    setIfUndefined(this._observers, name, create).add(f2);
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  once(name, f2) {
    const _f = (...args2) => {
      this.off(name, _f);
      f2(...args2);
    };
    this.on(name, _f);
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  off(name, f2) {
    const observers = this._observers.get(name);
    if (observers !== void 0) {
      observers.delete(f2);
      if (observers.size === 0) {
        this._observers.delete(name);
      }
    }
  }
  /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @param {N} name The event name.
   * @param {Array<any>} args The arguments that are applied to the event listener.
   */
  emit(name, args2) {
    return from2((this._observers.get(name) || create2()).values()).forEach((f2) => f2(...args2));
  }
  destroy() {
    this._observers = create2();
  }
};

// node_modules/lib0/webcrypto.js
var subtle = crypto.subtle;
var getRandomValues = crypto.getRandomValues.bind(crypto);

// node_modules/lib0/random.js
var uint32 = () => getRandomValues(new Uint32Array(1))[0];
var uuidv4Template = "10000000-1000-4000-8000" + -1e11;
var uuidv4 = () => uuidv4Template.replace(
  /[018]/g,
  /** @param {number} c */
  (c2) => (c2 ^ uint32() & 15 >> c2 / 4).toString(16)
);

// node_modules/lib0/time.js
var getUnixTime = Date.now;

// node_modules/lib0/promise.js
var create4 = (f2) => (
  /** @type {Promise<T>} */
  new Promise(f2)
);
var all = Promise.all.bind(Promise);

// node_modules/lib0/pair.js
var Pair = class {
  /**
   * @param {L} left
   * @param {R} right
   */
  constructor(left, right) {
    this.left = left;
    this.right = right;
  }
};
var create5 = (left, right) => new Pair(left, right);

// node_modules/lib0/dom.js
var doc = (
  /** @type {Document} */
  typeof document !== "undefined" ? document : {}
);
var domParser = (
  /** @type {DOMParser} */
  typeof DOMParser !== "undefined" ? new DOMParser() : null
);
var mapToStyleString = (m) => map(m, (value, key) => `${key}:${value};`).join("");
var ELEMENT_NODE = doc.ELEMENT_NODE;
var TEXT_NODE = doc.TEXT_NODE;
var CDATA_SECTION_NODE = doc.CDATA_SECTION_NODE;
var COMMENT_NODE = doc.COMMENT_NODE;
var DOCUMENT_NODE = doc.DOCUMENT_NODE;
var DOCUMENT_TYPE_NODE = doc.DOCUMENT_TYPE_NODE;
var DOCUMENT_FRAGMENT_NODE = doc.DOCUMENT_FRAGMENT_NODE;

// node_modules/lib0/eventloop.js
var createTimeoutClass = (clearFunction) => class TT {
  /**
   * @param {number} timeoutId
   */
  constructor(timeoutId) {
    this._ = timeoutId;
  }
  destroy() {
    clearFunction(this._);
  }
};
var Timeout = createTimeoutClass(clearTimeout);
var Interval = createTimeoutClass(clearInterval);
var Animation = createTimeoutClass((arg) => typeof requestAnimationFrame !== "undefined" && cancelAnimationFrame(arg));
var Idle = createTimeoutClass((arg) => typeof cancelIdleCallback !== "undefined" && cancelIdleCallback(arg));

// node_modules/lib0/symbol.js
var create6 = Symbol;

// node_modules/lib0/logging.common.js
var BOLD = create6();
var UNBOLD = create6();
var BLUE = create6();
var GREY = create6();
var GREEN = create6();
var RED = create6();
var PURPLE = create6();
var ORANGE = create6();
var UNCOLOR = create6();
var computeNoColorLoggingArgs = (args2) => {
  if (args2.length === 1 && args2[0]?.constructor === Function) {
    args2 = /** @type {Array<string|Symbol|Object|number>} */
    /** @type {[function]} */
    args2[0]();
  }
  const strBuilder = [];
  const logArgs = [];
  let i2 = 0;
  for (; i2 < args2.length; i2++) {
    const arg = args2[i2];
    if (arg === void 0) {
      break;
    } else if (arg.constructor === String || arg.constructor === Number) {
      strBuilder.push(arg);
    } else if (arg.constructor === Object) {
      break;
    }
  }
  if (i2 > 0) {
    logArgs.push(strBuilder.join(""));
  }
  for (; i2 < args2.length; i2++) {
    const arg = args2[i2];
    if (!(arg instanceof Symbol)) {
      logArgs.push(arg);
    }
  }
  return logArgs;
};
var lastLoggingTime = getUnixTime();

// node_modules/lib0/logging.js
var _browserStyleMap = {
  [BOLD]: create5("font-weight", "bold"),
  [UNBOLD]: create5("font-weight", "normal"),
  [BLUE]: create5("color", "blue"),
  [GREEN]: create5("color", "green"),
  [GREY]: create5("color", "grey"),
  [RED]: create5("color", "red"),
  [PURPLE]: create5("color", "purple"),
  [ORANGE]: create5("color", "orange"),
  // not well supported in chrome when debugging node with inspector - TODO: deprecate
  [UNCOLOR]: create5("color", "black")
};
var computeBrowserLoggingArgs = (args2) => {
  if (args2.length === 1 && args2[0]?.constructor === Function) {
    args2 = /** @type {Array<string|Symbol|Object|number>} */
    /** @type {[function]} */
    args2[0]();
  }
  const strBuilder = [];
  const styles = [];
  const currentStyle = create2();
  let logArgs = [];
  let i2 = 0;
  for (; i2 < args2.length; i2++) {
    const arg = args2[i2];
    const style = _browserStyleMap[arg];
    if (style !== void 0) {
      currentStyle.set(style.left, style.right);
    } else {
      if (arg === void 0) {
        break;
      }
      if (arg.constructor === String || arg.constructor === Number) {
        const style2 = mapToStyleString(currentStyle);
        if (i2 > 0 || style2.length > 0) {
          strBuilder.push("%c" + arg);
          styles.push(style2);
        } else {
          strBuilder.push(arg);
        }
      } else {
        break;
      }
    }
  }
  if (i2 > 0) {
    logArgs = styles;
    logArgs.unshift(strBuilder.join(""));
  }
  for (; i2 < args2.length; i2++) {
    const arg = args2[i2];
    if (!(arg instanceof Symbol)) {
      logArgs.push(arg);
    }
  }
  return logArgs;
};
var computeLoggingArgs = supportsColor ? computeBrowserLoggingArgs : computeNoColorLoggingArgs;
var print = (...args2) => {
  console.log(...computeLoggingArgs(args2));
  vconsoles.forEach((vc) => vc.print(args2));
};
var warn = (...args2) => {
  console.warn(...computeLoggingArgs(args2));
  args2.unshift(ORANGE);
  vconsoles.forEach((vc) => vc.print(args2));
};
var vconsoles = create();

// node_modules/lib0/iterator.js
var createIterator = (next) => ({
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return this;
  },
  // @ts-ignore
  next
});
var iteratorFilter = (iterator, filter2) => createIterator(() => {
  let res;
  do {
    res = iterator.next();
  } while (!res.done && !filter2(res.value));
  return res;
});
var iteratorMap = (iterator, fmap) => createIterator(() => {
  const { done, value } = iterator.next();
  return { done, value: done ? void 0 : fmap(value) };
});

// node_modules/yjs/dist/yjs.mjs
var AbstractConnector = class extends ObservableV2 {
  /**
   * @param {Doc} ydoc
   * @param {any} awareness
   */
  constructor(ydoc, awareness) {
    super();
    this.doc = ydoc;
    this.awareness = awareness;
  }
};
var DeleteItem = class {
  /**
   * @param {number} clock
   * @param {number} len
   */
  constructor(clock, len3) {
    this.clock = clock;
    this.len = len3;
  }
};
var DeleteSet = class {
  constructor() {
    this.clients = /* @__PURE__ */ new Map();
  }
};
var iterateDeletedStructs = (transaction, ds, f2) => ds.clients.forEach((deletes, clientid) => {
  const structs = (
    /** @type {Array<GC|Item>} */
    transaction.doc.store.clients.get(clientid)
  );
  if (structs != null) {
    const lastStruct = structs[structs.length - 1];
    const clockState = lastStruct.id.clock + lastStruct.length;
    for (let i2 = 0, del2 = deletes[i2]; i2 < deletes.length && del2.clock < clockState; del2 = deletes[++i2]) {
      iterateStructs(transaction, structs, del2.clock, del2.len, f2);
    }
  }
});
var findIndexDS = (dis, clock) => {
  let left = 0;
  let right = dis.length - 1;
  while (left <= right) {
    const midindex = floor((left + right) / 2);
    const mid = dis[midindex];
    const midclock = mid.clock;
    if (midclock <= clock) {
      if (clock < midclock + mid.len) {
        return midindex;
      }
      left = midindex + 1;
    } else {
      right = midindex - 1;
    }
  }
  return null;
};
var isDeleted = (ds, id2) => {
  const dis = ds.clients.get(id2.client);
  return dis !== void 0 && findIndexDS(dis, id2.clock) !== null;
};
var sortAndMergeDeleteSet = (ds) => {
  ds.clients.forEach((dels) => {
    dels.sort((a2, b2) => a2.clock - b2.clock);
    let i2, j;
    for (i2 = 1, j = 1; i2 < dels.length; i2++) {
      const left = dels[j - 1];
      const right = dels[i2];
      if (left.clock + left.len >= right.clock) {
        left.len = max(left.len, right.clock + right.len - left.clock);
      } else {
        if (j < i2) {
          dels[j] = right;
        }
        j++;
      }
    }
    dels.length = j;
  });
};
var mergeDeleteSets = (dss) => {
  const merged = new DeleteSet();
  for (let dssI = 0; dssI < dss.length; dssI++) {
    dss[dssI].clients.forEach((delsLeft, client) => {
      if (!merged.clients.has(client)) {
        const dels = delsLeft.slice();
        for (let i2 = dssI + 1; i2 < dss.length; i2++) {
          appendTo(dels, dss[i2].clients.get(client) || []);
        }
        merged.clients.set(client, dels);
      }
    });
  }
  sortAndMergeDeleteSet(merged);
  return merged;
};
var addToDeleteSet = (ds, client, clock, length4) => {
  setIfUndefined(ds.clients, client, () => (
    /** @type {Array<DeleteItem>} */
    []
  )).push(new DeleteItem(clock, length4));
};
var createDeleteSet = () => new DeleteSet();
var createDeleteSetFromStructStore = (ss) => {
  const ds = createDeleteSet();
  ss.clients.forEach((structs, client) => {
    const dsitems = [];
    for (let i2 = 0; i2 < structs.length; i2++) {
      const struct = structs[i2];
      if (struct.deleted) {
        const clock = struct.id.clock;
        let len3 = struct.length;
        if (i2 + 1 < structs.length) {
          for (let next = structs[i2 + 1]; i2 + 1 < structs.length && next.deleted; next = structs[++i2 + 1]) {
            len3 += next.length;
          }
        }
        dsitems.push(new DeleteItem(clock, len3));
      }
    }
    if (dsitems.length > 0) {
      ds.clients.set(client, dsitems);
    }
  });
  return ds;
};
var writeDeleteSet = (encoder, ds) => {
  writeVarUint(encoder.restEncoder, ds.clients.size);
  from2(ds.clients.entries()).sort((a2, b2) => b2[0] - a2[0]).forEach(([client, dsitems]) => {
    encoder.resetDsCurVal();
    writeVarUint(encoder.restEncoder, client);
    const len3 = dsitems.length;
    writeVarUint(encoder.restEncoder, len3);
    for (let i2 = 0; i2 < len3; i2++) {
      const item = dsitems[i2];
      encoder.writeDsClock(item.clock);
      encoder.writeDsLen(item.len);
    }
  });
};
var readDeleteSet = (decoder) => {
  const ds = new DeleteSet();
  const numClients = readVarUint(decoder.restDecoder);
  for (let i2 = 0; i2 < numClients; i2++) {
    decoder.resetDsCurVal();
    const client = readVarUint(decoder.restDecoder);
    const numberOfDeletes = readVarUint(decoder.restDecoder);
    if (numberOfDeletes > 0) {
      const dsField = setIfUndefined(ds.clients, client, () => (
        /** @type {Array<DeleteItem>} */
        []
      ));
      for (let i3 = 0; i3 < numberOfDeletes; i3++) {
        dsField.push(new DeleteItem(decoder.readDsClock(), decoder.readDsLen()));
      }
    }
  }
  return ds;
};
var readAndApplyDeleteSet = (decoder, transaction, store) => {
  const unappliedDS = new DeleteSet();
  const numClients = readVarUint(decoder.restDecoder);
  for (let i2 = 0; i2 < numClients; i2++) {
    decoder.resetDsCurVal();
    const client = readVarUint(decoder.restDecoder);
    const numberOfDeletes = readVarUint(decoder.restDecoder);
    const structs = store.clients.get(client) || [];
    const state = getState(store, client);
    for (let i3 = 0; i3 < numberOfDeletes; i3++) {
      const clock = decoder.readDsClock();
      const clockEnd = clock + decoder.readDsLen();
      if (clock < state) {
        if (state < clockEnd) {
          addToDeleteSet(unappliedDS, client, state, clockEnd - state);
        }
        let index = findIndexSS(structs, clock);
        let struct = structs[index];
        if (!struct.deleted && struct.id.clock < clock) {
          structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));
          index++;
        }
        while (index < structs.length) {
          struct = structs[index++];
          if (struct.id.clock < clockEnd) {
            if (!struct.deleted) {
              if (clockEnd < struct.id.clock + struct.length) {
                structs.splice(index, 0, splitItem(transaction, struct, clockEnd - struct.id.clock));
              }
              struct.delete(transaction);
            }
          } else {
            break;
          }
        }
      } else {
        addToDeleteSet(unappliedDS, client, clock, clockEnd - clock);
      }
    }
  }
  if (unappliedDS.clients.size > 0) {
    const ds = new UpdateEncoderV2();
    writeVarUint(ds.restEncoder, 0);
    writeDeleteSet(ds, unappliedDS);
    return ds.toUint8Array();
  }
  return null;
};
var equalDeleteSets = (ds1, ds2) => {
  if (ds1.clients.size !== ds2.clients.size) return false;
  for (const [client, deleteItems1] of ds1.clients.entries()) {
    const deleteItems2 = (
      /** @type {Array<import('../internals.js').DeleteItem>} */
      ds2.clients.get(client)
    );
    if (deleteItems2 === void 0 || deleteItems1.length !== deleteItems2.length) return false;
    for (let i2 = 0; i2 < deleteItems1.length; i2++) {
      const di1 = deleteItems1[i2];
      const di2 = deleteItems2[i2];
      if (di1.clock !== di2.clock || di1.len !== di2.len) {
        return false;
      }
    }
  }
  return true;
};
var generateNewClientId = uint32;
var Doc = class _Doc extends ObservableV2 {
  /**
   * @param {DocOpts} opts configuration
   */
  constructor({ guid = uuidv4(), collectionid = null, gc = true, gcFilter = () => true, meta = null, autoLoad = false, shouldLoad = true } = {}) {
    super();
    this.gc = gc;
    this.gcFilter = gcFilter;
    this.clientID = generateNewClientId();
    this.guid = guid;
    this.collectionid = collectionid;
    this.share = /* @__PURE__ */ new Map();
    this.store = new StructStore();
    this._transaction = null;
    this._transactionCleanups = [];
    this.subdocs = /* @__PURE__ */ new Set();
    this._item = null;
    this.shouldLoad = shouldLoad;
    this.autoLoad = autoLoad;
    this.meta = meta;
    this.isLoaded = false;
    this.isSynced = false;
    this.isDestroyed = false;
    this.whenLoaded = create4((resolve) => {
      this.on("load", () => {
        this.isLoaded = true;
        resolve(this);
      });
    });
    const provideSyncedPromise = () => create4((resolve) => {
      const eventHandler = (isSynced) => {
        if (isSynced === void 0 || isSynced === true) {
          this.off("sync", eventHandler);
          resolve();
        }
      };
      this.on("sync", eventHandler);
    });
    this.on("sync", (isSynced) => {
      if (isSynced === false && this.isSynced) {
        this.whenSynced = provideSyncedPromise();
      }
      this.isSynced = isSynced === void 0 || isSynced === true;
      if (this.isSynced && !this.isLoaded) {
        this.emit("load", [this]);
      }
    });
    this.whenSynced = provideSyncedPromise();
  }
  /**
   * Notify the parent document that you request to load data into this subdocument (if it is a subdocument).
   *
   * `load()` might be used in the future to request any provider to load the most current data.
   *
   * It is safe to call `load()` multiple times.
   */
  load() {
    const item = this._item;
    if (item !== null && !this.shouldLoad) {
      transact(
        /** @type {any} */
        item.parent.doc,
        (transaction) => {
          transaction.subdocsLoaded.add(this);
        },
        null,
        true
      );
    }
    this.shouldLoad = true;
  }
  getSubdocs() {
    return this.subdocs;
  }
  getSubdocGuids() {
    return new Set(from2(this.subdocs).map((doc2) => doc2.guid));
  }
  /**
   * Changes that happen inside of a transaction are bundled. This means that
   * the observer fires _after_ the transaction is finished and that all changes
   * that happened inside of the transaction are sent as one message to the
   * other peers.
   *
   * @template T
   * @param {function(Transaction):T} f The function that should be executed as a transaction
   * @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin
   * @return T
   *
   * @public
   */
  transact(f2, origin = null) {
    return transact(this, f2, origin);
  }
  /**
   * Define a shared data type.
   *
   * Multiple calls of `ydoc.get(name, TypeConstructor)` yield the same result
   * and do not overwrite each other. I.e.
   * `ydoc.get(name, Y.Array) === ydoc.get(name, Y.Array)`
   *
   * After this method is called, the type is also available on `ydoc.share.get(name)`.
   *
   * *Best Practices:*
   * Define all types right after the Y.Doc instance is created and store them in a separate object.
   * Also use the typed methods `getText(name)`, `getArray(name)`, ..
   *
   * @template {typeof AbstractType<any>} Type
   * @example
   *   const ydoc = new Y.Doc(..)
   *   const appState = {
   *     document: ydoc.getText('document')
   *     comments: ydoc.getArray('comments')
   *   }
   *
   * @param {string} name
   * @param {Type} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...
   * @return {InstanceType<Type>} The created type. Constructed with TypeConstructor
   *
   * @public
   */
  get(name, TypeConstructor = (
    /** @type {any} */
    AbstractType
  )) {
    const type = setIfUndefined(this.share, name, () => {
      const t2 = new TypeConstructor();
      t2._integrate(this, null);
      return t2;
    });
    const Constr = type.constructor;
    if (TypeConstructor !== AbstractType && Constr !== TypeConstructor) {
      if (Constr === AbstractType) {
        const t2 = new TypeConstructor();
        t2._map = type._map;
        type._map.forEach(
          /** @param {Item?} n */
          (n2) => {
            for (; n2 !== null; n2 = n2.left) {
              n2.parent = t2;
            }
          }
        );
        t2._start = type._start;
        for (let n2 = t2._start; n2 !== null; n2 = n2.right) {
          n2.parent = t2;
        }
        t2._length = type._length;
        this.share.set(name, t2);
        t2._integrate(this, null);
        return (
          /** @type {InstanceType<Type>} */
          t2
        );
      } else {
        throw new Error(`Type with the name ${name} has already been defined with a different constructor`);
      }
    }
    return (
      /** @type {InstanceType<Type>} */
      type
    );
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YArray<T>}
   *
   * @public
   */
  getArray(name = "") {
    return (
      /** @type {YArray<T>} */
      this.get(name, YArray)
    );
  }
  /**
   * @param {string} [name]
   * @return {YText}
   *
   * @public
   */
  getText(name = "") {
    return this.get(name, YText);
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YMap<T>}
   *
   * @public
   */
  getMap(name = "") {
    return (
      /** @type {YMap<T>} */
      this.get(name, YMap)
    );
  }
  /**
   * @param {string} [name]
   * @return {YXmlElement}
   *
   * @public
   */
  getXmlElement(name = "") {
    return (
      /** @type {YXmlElement<{[key:string]:string}>} */
      this.get(name, YXmlElement)
    );
  }
  /**
   * @param {string} [name]
   * @return {YXmlFragment}
   *
   * @public
   */
  getXmlFragment(name = "") {
    return this.get(name, YXmlFragment);
  }
  /**
   * Converts the entire document into a js object, recursively traversing each yjs type
   * Doesn't log types that have not been defined (using ydoc.getType(..)).
   *
   * @deprecated Do not use this method and rather call toJSON directly on the shared types.
   *
   * @return {Object<string, any>}
   */
  toJSON() {
    const doc2 = {};
    this.share.forEach((value, key) => {
      doc2[key] = value.toJSON();
    });
    return doc2;
  }
  /**
   * Emit `destroy` event and unregister all event handlers.
   */
  destroy() {
    this.isDestroyed = true;
    from2(this.subdocs).forEach((subdoc) => subdoc.destroy());
    const item = this._item;
    if (item !== null) {
      this._item = null;
      const content = (
        /** @type {ContentDoc} */
        item.content
      );
      content.doc = new _Doc({ guid: this.guid, ...content.opts, shouldLoad: false });
      content.doc._item = item;
      transact(
        /** @type {any} */
        item.parent.doc,
        (transaction) => {
          const doc2 = content.doc;
          if (!item.deleted) {
            transaction.subdocsAdded.add(doc2);
          }
          transaction.subdocsRemoved.add(this);
        },
        null,
        true
      );
    }
    this.emit("destroyed", [true]);
    this.emit("destroy", [this]);
    super.destroy();
  }
};
var DSDecoderV1 = class {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(decoder) {
    this.restDecoder = decoder;
  }
  resetDsCurVal() {
  }
  /**
   * @return {number}
   */
  readDsClock() {
    return readVarUint(this.restDecoder);
  }
  /**
   * @return {number}
   */
  readDsLen() {
    return readVarUint(this.restDecoder);
  }
};
var UpdateDecoderV1 = class extends DSDecoderV1 {
  /**
   * @return {ID}
   */
  readLeftID() {
    return createID(readVarUint(this.restDecoder), readVarUint(this.restDecoder));
  }
  /**
   * @return {ID}
   */
  readRightID() {
    return createID(readVarUint(this.restDecoder), readVarUint(this.restDecoder));
  }
  /**
   * Read the next client id.
   * Use this in favor of readID whenever possible to reduce the number of objects created.
   */
  readClient() {
    return readVarUint(this.restDecoder);
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readInfo() {
    return readUint8(this.restDecoder);
  }
  /**
   * @return {string}
   */
  readString() {
    return readVarString(this.restDecoder);
  }
  /**
   * @return {boolean} isKey
   */
  readParentInfo() {
    return readVarUint(this.restDecoder) === 1;
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readTypeRef() {
    return readVarUint(this.restDecoder);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @return {number} len
   */
  readLen() {
    return readVarUint(this.restDecoder);
  }
  /**
   * @return {any}
   */
  readAny() {
    return readAny(this.restDecoder);
  }
  /**
   * @return {Uint8Array}
   */
  readBuf() {
    return copyUint8Array(readVarUint8Array(this.restDecoder));
  }
  /**
   * Legacy implementation uses JSON parse. We use any-decoding in v2.
   *
   * @return {any}
   */
  readJSON() {
    return JSON.parse(readVarString(this.restDecoder));
  }
  /**
   * @return {string}
   */
  readKey() {
    return readVarString(this.restDecoder);
  }
};
var DSDecoderV2 = class {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(decoder) {
    this.dsCurrVal = 0;
    this.restDecoder = decoder;
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  /**
   * @return {number}
   */
  readDsClock() {
    this.dsCurrVal += readVarUint(this.restDecoder);
    return this.dsCurrVal;
  }
  /**
   * @return {number}
   */
  readDsLen() {
    const diff = readVarUint(this.restDecoder) + 1;
    this.dsCurrVal += diff;
    return diff;
  }
};
var UpdateDecoderV2 = class extends DSDecoderV2 {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(decoder) {
    super(decoder);
    this.keys = [];
    readVarUint(decoder);
    this.keyClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));
    this.clientDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));
    this.leftClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));
    this.rightClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));
    this.infoDecoder = new RleDecoder(readVarUint8Array(decoder), readUint8);
    this.stringDecoder = new StringDecoder(readVarUint8Array(decoder));
    this.parentInfoDecoder = new RleDecoder(readVarUint8Array(decoder), readUint8);
    this.typeRefDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));
    this.lenDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));
  }
  /**
   * @return {ID}
   */
  readLeftID() {
    return new ID(this.clientDecoder.read(), this.leftClockDecoder.read());
  }
  /**
   * @return {ID}
   */
  readRightID() {
    return new ID(this.clientDecoder.read(), this.rightClockDecoder.read());
  }
  /**
   * Read the next client id.
   * Use this in favor of readID whenever possible to reduce the number of objects created.
   */
  readClient() {
    return this.clientDecoder.read();
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readInfo() {
    return (
      /** @type {number} */
      this.infoDecoder.read()
    );
  }
  /**
   * @return {string}
   */
  readString() {
    return this.stringDecoder.read();
  }
  /**
   * @return {boolean}
   */
  readParentInfo() {
    return this.parentInfoDecoder.read() === 1;
  }
  /**
   * @return {number} An unsigned 8-bit integer
   */
  readTypeRef() {
    return this.typeRefDecoder.read();
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @return {number}
   */
  readLen() {
    return this.lenDecoder.read();
  }
  /**
   * @return {any}
   */
  readAny() {
    return readAny(this.restDecoder);
  }
  /**
   * @return {Uint8Array}
   */
  readBuf() {
    return readVarUint8Array(this.restDecoder);
  }
  /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @return {any}
   */
  readJSON() {
    return readAny(this.restDecoder);
  }
  /**
   * @return {string}
   */
  readKey() {
    const keyClock = this.keyClockDecoder.read();
    if (keyClock < this.keys.length) {
      return this.keys[keyClock];
    } else {
      const key = this.stringDecoder.read();
      this.keys.push(key);
      return key;
    }
  }
};
var DSEncoderV1 = class {
  constructor() {
    this.restEncoder = createEncoder();
  }
  toUint8Array() {
    return toUint8Array(this.restEncoder);
  }
  resetDsCurVal() {
  }
  /**
   * @param {number} clock
   */
  writeDsClock(clock) {
    writeVarUint(this.restEncoder, clock);
  }
  /**
   * @param {number} len
   */
  writeDsLen(len3) {
    writeVarUint(this.restEncoder, len3);
  }
};
var UpdateEncoderV1 = class extends DSEncoderV1 {
  /**
   * @param {ID} id
   */
  writeLeftID(id2) {
    writeVarUint(this.restEncoder, id2.client);
    writeVarUint(this.restEncoder, id2.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(id2) {
    writeVarUint(this.restEncoder, id2.client);
    writeVarUint(this.restEncoder, id2.clock);
  }
  /**
   * Use writeClient and writeClock instead of writeID if possible.
   * @param {number} client
   */
  writeClient(client) {
    writeVarUint(this.restEncoder, client);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(info) {
    writeUint8(this.restEncoder, info);
  }
  /**
   * @param {string} s
   */
  writeString(s2) {
    writeVarString(this.restEncoder, s2);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(isYKey) {
    writeVarUint(this.restEncoder, isYKey ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(info) {
    writeVarUint(this.restEncoder, info);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(len3) {
    writeVarUint(this.restEncoder, len3);
  }
  /**
   * @param {any} any
   */
  writeAny(any2) {
    writeAny(this.restEncoder, any2);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(buf) {
    writeVarUint8Array(this.restEncoder, buf);
  }
  /**
   * @param {any} embed
   */
  writeJSON(embed) {
    writeVarString(this.restEncoder, JSON.stringify(embed));
  }
  /**
   * @param {string} key
   */
  writeKey(key) {
    writeVarString(this.restEncoder, key);
  }
};
var DSEncoderV2 = class {
  constructor() {
    this.restEncoder = createEncoder();
    this.dsCurrVal = 0;
  }
  toUint8Array() {
    return toUint8Array(this.restEncoder);
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  /**
   * @param {number} clock
   */
  writeDsClock(clock) {
    const diff = clock - this.dsCurrVal;
    this.dsCurrVal = clock;
    writeVarUint(this.restEncoder, diff);
  }
  /**
   * @param {number} len
   */
  writeDsLen(len3) {
    if (len3 === 0) {
      unexpectedCase();
    }
    writeVarUint(this.restEncoder, len3 - 1);
    this.dsCurrVal += len3;
  }
};
var UpdateEncoderV2 = class extends DSEncoderV2 {
  constructor() {
    super();
    this.keyMap = /* @__PURE__ */ new Map();
    this.keyClock = 0;
    this.keyClockEncoder = new IntDiffOptRleEncoder();
    this.clientEncoder = new UintOptRleEncoder();
    this.leftClockEncoder = new IntDiffOptRleEncoder();
    this.rightClockEncoder = new IntDiffOptRleEncoder();
    this.infoEncoder = new RleEncoder(writeUint8);
    this.stringEncoder = new StringEncoder();
    this.parentInfoEncoder = new RleEncoder(writeUint8);
    this.typeRefEncoder = new UintOptRleEncoder();
    this.lenEncoder = new UintOptRleEncoder();
  }
  toUint8Array() {
    const encoder = createEncoder();
    writeVarUint(encoder, 0);
    writeVarUint8Array(encoder, this.keyClockEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.clientEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.leftClockEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.rightClockEncoder.toUint8Array());
    writeVarUint8Array(encoder, toUint8Array(this.infoEncoder));
    writeVarUint8Array(encoder, this.stringEncoder.toUint8Array());
    writeVarUint8Array(encoder, toUint8Array(this.parentInfoEncoder));
    writeVarUint8Array(encoder, this.typeRefEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.lenEncoder.toUint8Array());
    writeUint8Array(encoder, toUint8Array(this.restEncoder));
    return toUint8Array(encoder);
  }
  /**
   * @param {ID} id
   */
  writeLeftID(id2) {
    this.clientEncoder.write(id2.client);
    this.leftClockEncoder.write(id2.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(id2) {
    this.clientEncoder.write(id2.client);
    this.rightClockEncoder.write(id2.clock);
  }
  /**
   * @param {number} client
   */
  writeClient(client) {
    this.clientEncoder.write(client);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(info) {
    this.infoEncoder.write(info);
  }
  /**
   * @param {string} s
   */
  writeString(s2) {
    this.stringEncoder.write(s2);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(isYKey) {
    this.parentInfoEncoder.write(isYKey ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(info) {
    this.typeRefEncoder.write(info);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(len3) {
    this.lenEncoder.write(len3);
  }
  /**
   * @param {any} any
   */
  writeAny(any2) {
    writeAny(this.restEncoder, any2);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(buf) {
    writeVarUint8Array(this.restEncoder, buf);
  }
  /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @param {any} embed
   */
  writeJSON(embed) {
    writeAny(this.restEncoder, embed);
  }
  /**
   * Property keys are often reused. For example, in y-prosemirror the key `bold` might
   * occur very often. For a 3d application, the key `position` might occur very often.
   *
   * We cache these keys in a Map and refer to them via a unique number.
   *
   * @param {string} key
   */
  writeKey(key) {
    const clock = this.keyMap.get(key);
    if (clock === void 0) {
      this.keyClockEncoder.write(this.keyClock++);
      this.stringEncoder.write(key);
    } else {
      this.keyClockEncoder.write(clock);
    }
  }
};
var writeStructs = (encoder, structs, client, clock) => {
  clock = max(clock, structs[0].id.clock);
  const startNewStructs = findIndexSS(structs, clock);
  writeVarUint(encoder.restEncoder, structs.length - startNewStructs);
  encoder.writeClient(client);
  writeVarUint(encoder.restEncoder, clock);
  const firstStruct = structs[startNewStructs];
  firstStruct.write(encoder, clock - firstStruct.id.clock);
  for (let i2 = startNewStructs + 1; i2 < structs.length; i2++) {
    structs[i2].write(encoder, 0);
  }
};
var writeClientsStructs = (encoder, store, _sm) => {
  const sm = /* @__PURE__ */ new Map();
  _sm.forEach((clock, client) => {
    if (getState(store, client) > clock) {
      sm.set(client, clock);
    }
  });
  getStateVector(store).forEach((_clock, client) => {
    if (!_sm.has(client)) {
      sm.set(client, 0);
    }
  });
  writeVarUint(encoder.restEncoder, sm.size);
  from2(sm.entries()).sort((a2, b2) => b2[0] - a2[0]).forEach(([client, clock]) => {
    writeStructs(
      encoder,
      /** @type {Array<GC|Item>} */
      store.clients.get(client),
      client,
      clock
    );
  });
};
var readClientsStructRefs = (decoder, doc2) => {
  const clientRefs = create2();
  const numOfStateUpdates = readVarUint(decoder.restDecoder);
  for (let i2 = 0; i2 < numOfStateUpdates; i2++) {
    const numberOfStructs = readVarUint(decoder.restDecoder);
    const refs = new Array(numberOfStructs);
    const client = decoder.readClient();
    let clock = readVarUint(decoder.restDecoder);
    clientRefs.set(client, { i: 0, refs });
    for (let i3 = 0; i3 < numberOfStructs; i3++) {
      const info = decoder.readInfo();
      switch (BITS5 & info) {
        case 0: {
          const len3 = decoder.readLen();
          refs[i3] = new GC(createID(client, clock), len3);
          clock += len3;
          break;
        }
        case 10: {
          const len3 = readVarUint(decoder.restDecoder);
          refs[i3] = new Skip(createID(client, clock), len3);
          clock += len3;
          break;
        }
        default: {
          const cantCopyParentInfo = (info & (BIT7 | BIT8)) === 0;
          const struct = new Item(
            createID(client, clock),
            null,
            // left
            (info & BIT8) === BIT8 ? decoder.readLeftID() : null,
            // origin
            null,
            // right
            (info & BIT7) === BIT7 ? decoder.readRightID() : null,
            // right origin
            cantCopyParentInfo ? decoder.readParentInfo() ? doc2.get(decoder.readString()) : decoder.readLeftID() : null,
            // parent
            cantCopyParentInfo && (info & BIT6) === BIT6 ? decoder.readString() : null,
            // parentSub
            readItemContent(decoder, info)
            // item content
          );
          refs[i3] = struct;
          clock += struct.length;
        }
      }
    }
  }
  return clientRefs;
};
var integrateStructs = (transaction, store, clientsStructRefs) => {
  const stack = [];
  let clientsStructRefsIds = from2(clientsStructRefs.keys()).sort((a2, b2) => a2 - b2);
  if (clientsStructRefsIds.length === 0) {
    return null;
  }
  const getNextStructTarget = () => {
    if (clientsStructRefsIds.length === 0) {
      return null;
    }
    let nextStructsTarget = (
      /** @type {{i:number,refs:Array<GC|Item>}} */
      clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1])
    );
    while (nextStructsTarget.refs.length === nextStructsTarget.i) {
      clientsStructRefsIds.pop();
      if (clientsStructRefsIds.length > 0) {
        nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */
        clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]);
      } else {
        return null;
      }
    }
    return nextStructsTarget;
  };
  let curStructsTarget = getNextStructTarget();
  if (curStructsTarget === null) {
    return null;
  }
  const restStructs = new StructStore();
  const missingSV = /* @__PURE__ */ new Map();
  const updateMissingSv = (client, clock) => {
    const mclock = missingSV.get(client);
    if (mclock == null || mclock > clock) {
      missingSV.set(client, clock);
    }
  };
  let stackHead = (
    /** @type {any} */
    curStructsTarget.refs[
      /** @type {any} */
      curStructsTarget.i++
    ]
  );
  const state = /* @__PURE__ */ new Map();
  const addStackToRestSS = () => {
    for (const item of stack) {
      const client = item.id.client;
      const inapplicableItems = clientsStructRefs.get(client);
      if (inapplicableItems) {
        inapplicableItems.i--;
        restStructs.clients.set(client, inapplicableItems.refs.slice(inapplicableItems.i));
        clientsStructRefs.delete(client);
        inapplicableItems.i = 0;
        inapplicableItems.refs = [];
      } else {
        restStructs.clients.set(client, [item]);
      }
      clientsStructRefsIds = clientsStructRefsIds.filter((c2) => c2 !== client);
    }
    stack.length = 0;
  };
  while (true) {
    if (stackHead.constructor !== Skip) {
      const localClock = setIfUndefined(state, stackHead.id.client, () => getState(store, stackHead.id.client));
      const offset = localClock - stackHead.id.clock;
      if (offset < 0) {
        stack.push(stackHead);
        updateMissingSv(stackHead.id.client, stackHead.id.clock - 1);
        addStackToRestSS();
      } else {
        const missing = stackHead.getMissing(transaction, store);
        if (missing !== null) {
          stack.push(stackHead);
          const structRefs = clientsStructRefs.get(
            /** @type {number} */
            missing
          ) || { refs: [], i: 0 };
          if (structRefs.refs.length === structRefs.i) {
            updateMissingSv(
              /** @type {number} */
              missing,
              getState(store, missing)
            );
            addStackToRestSS();
          } else {
            stackHead = structRefs.refs[structRefs.i++];
            continue;
          }
        } else if (offset === 0 || offset < stackHead.length) {
          stackHead.integrate(transaction, offset);
          state.set(stackHead.id.client, stackHead.id.clock + stackHead.length);
        }
      }
    }
    if (stack.length > 0) {
      stackHead = /** @type {GC|Item} */
      stack.pop();
    } else if (curStructsTarget !== null && curStructsTarget.i < curStructsTarget.refs.length) {
      stackHead = /** @type {GC|Item} */
      curStructsTarget.refs[curStructsTarget.i++];
    } else {
      curStructsTarget = getNextStructTarget();
      if (curStructsTarget === null) {
        break;
      } else {
        stackHead = /** @type {GC|Item} */
        curStructsTarget.refs[curStructsTarget.i++];
      }
    }
  }
  if (restStructs.clients.size > 0) {
    const encoder = new UpdateEncoderV2();
    writeClientsStructs(encoder, restStructs, /* @__PURE__ */ new Map());
    writeVarUint(encoder.restEncoder, 0);
    return { missing: missingSV, update: encoder.toUint8Array() };
  }
  return null;
};
var writeStructsFromTransaction = (encoder, transaction) => writeClientsStructs(encoder, transaction.doc.store, transaction.beforeState);
var readUpdateV2 = (decoder, ydoc, transactionOrigin, structDecoder = new UpdateDecoderV2(decoder)) => transact(ydoc, (transaction) => {
  transaction.local = false;
  let retry = false;
  const doc2 = transaction.doc;
  const store = doc2.store;
  const ss = readClientsStructRefs(structDecoder, doc2);
  const restStructs = integrateStructs(transaction, store, ss);
  const pending = store.pendingStructs;
  if (pending) {
    for (const [client, clock] of pending.missing) {
      if (clock < getState(store, client)) {
        retry = true;
        break;
      }
    }
    if (restStructs) {
      for (const [client, clock] of restStructs.missing) {
        const mclock = pending.missing.get(client);
        if (mclock == null || mclock > clock) {
          pending.missing.set(client, clock);
        }
      }
      pending.update = mergeUpdatesV2([pending.update, restStructs.update]);
    }
  } else {
    store.pendingStructs = restStructs;
  }
  const dsRest = readAndApplyDeleteSet(structDecoder, transaction, store);
  if (store.pendingDs) {
    const pendingDSUpdate = new UpdateDecoderV2(createDecoder(store.pendingDs));
    readVarUint(pendingDSUpdate.restDecoder);
    const dsRest2 = readAndApplyDeleteSet(pendingDSUpdate, transaction, store);
    if (dsRest && dsRest2) {
      store.pendingDs = mergeUpdatesV2([dsRest, dsRest2]);
    } else {
      store.pendingDs = dsRest || dsRest2;
    }
  } else {
    store.pendingDs = dsRest;
  }
  if (retry) {
    const update = (
      /** @type {{update: Uint8Array}} */
      store.pendingStructs.update
    );
    store.pendingStructs = null;
    applyUpdateV2(transaction.doc, update);
  }
}, transactionOrigin, false);
var readUpdate = (decoder, ydoc, transactionOrigin) => readUpdateV2(decoder, ydoc, transactionOrigin, new UpdateDecoderV1(decoder));
var applyUpdateV2 = (ydoc, update, transactionOrigin, YDecoder = UpdateDecoderV2) => {
  const decoder = createDecoder(update);
  readUpdateV2(decoder, ydoc, transactionOrigin, new YDecoder(decoder));
};
var applyUpdate = (ydoc, update, transactionOrigin) => applyUpdateV2(ydoc, update, transactionOrigin, UpdateDecoderV1);
var writeStateAsUpdate = (encoder, doc2, targetStateVector = /* @__PURE__ */ new Map()) => {
  writeClientsStructs(encoder, doc2.store, targetStateVector);
  writeDeleteSet(encoder, createDeleteSetFromStructStore(doc2.store));
};
var encodeStateAsUpdateV2 = (doc2, encodedTargetStateVector = new Uint8Array([0]), encoder = new UpdateEncoderV2()) => {
  const targetStateVector = decodeStateVector(encodedTargetStateVector);
  writeStateAsUpdate(encoder, doc2, targetStateVector);
  const updates = [encoder.toUint8Array()];
  if (doc2.store.pendingDs) {
    updates.push(doc2.store.pendingDs);
  }
  if (doc2.store.pendingStructs) {
    updates.push(diffUpdateV2(doc2.store.pendingStructs.update, encodedTargetStateVector));
  }
  if (updates.length > 1) {
    if (encoder.constructor === UpdateEncoderV1) {
      return mergeUpdates(updates.map((update, i2) => i2 === 0 ? update : convertUpdateFormatV2ToV1(update)));
    } else if (encoder.constructor === UpdateEncoderV2) {
      return mergeUpdatesV2(updates);
    }
  }
  return updates[0];
};
var encodeStateAsUpdate = (doc2, encodedTargetStateVector) => encodeStateAsUpdateV2(doc2, encodedTargetStateVector, new UpdateEncoderV1());
var readStateVector = (decoder) => {
  const ss = /* @__PURE__ */ new Map();
  const ssLength = readVarUint(decoder.restDecoder);
  for (let i2 = 0; i2 < ssLength; i2++) {
    const client = readVarUint(decoder.restDecoder);
    const clock = readVarUint(decoder.restDecoder);
    ss.set(client, clock);
  }
  return ss;
};
var decodeStateVector = (decodedState) => readStateVector(new DSDecoderV1(createDecoder(decodedState)));
var writeStateVector = (encoder, sv) => {
  writeVarUint(encoder.restEncoder, sv.size);
  from2(sv.entries()).sort((a2, b2) => b2[0] - a2[0]).forEach(([client, clock]) => {
    writeVarUint(encoder.restEncoder, client);
    writeVarUint(encoder.restEncoder, clock);
  });
  return encoder;
};
var writeDocumentStateVector = (encoder, doc2) => writeStateVector(encoder, getStateVector(doc2.store));
var encodeStateVectorV2 = (doc2, encoder = new DSEncoderV2()) => {
  if (doc2 instanceof Map) {
    writeStateVector(encoder, doc2);
  } else {
    writeDocumentStateVector(encoder, doc2);
  }
  return encoder.toUint8Array();
};
var encodeStateVector = (doc2) => encodeStateVectorV2(doc2, new DSEncoderV1());
var EventHandler = class {
  constructor() {
    this.l = [];
  }
};
var createEventHandler = () => new EventHandler();
var addEventHandlerListener = (eventHandler, f2) => eventHandler.l.push(f2);
var removeEventHandlerListener = (eventHandler, f2) => {
  const l2 = eventHandler.l;
  const len3 = l2.length;
  eventHandler.l = l2.filter((g2) => f2 !== g2);
  if (len3 === eventHandler.l.length) {
    console.error("[yjs] Tried to remove event handler that doesn't exist.");
  }
};
var callEventHandlerListeners = (eventHandler, arg0, arg1) => callAll(eventHandler.l, [arg0, arg1]);
var ID = class {
  /**
   * @param {number} client client id
   * @param {number} clock unique per client id, continuous number
   */
  constructor(client, clock) {
    this.client = client;
    this.clock = clock;
  }
};
var compareIDs = (a2, b2) => a2 === b2 || a2 !== null && b2 !== null && a2.client === b2.client && a2.clock === b2.clock;
var createID = (client, clock) => new ID(client, clock);
var writeID = (encoder, id2) => {
  writeVarUint(encoder, id2.client);
  writeVarUint(encoder, id2.clock);
};
var readID = (decoder) => createID(readVarUint(decoder), readVarUint(decoder));
var findRootTypeKey = (type) => {
  for (const [key, value] of type.doc.share.entries()) {
    if (value === type) {
      return key;
    }
  }
  throw unexpectedCase();
};
var isParentOf = (parent, child) => {
  while (child !== null) {
    if (child.parent === parent) {
      return true;
    }
    child = /** @type {AbstractType<any>} */
    child.parent._item;
  }
  return false;
};
var logType = (type) => {
  const res = [];
  let n2 = type._start;
  while (n2) {
    res.push(n2);
    n2 = n2.right;
  }
  console.log("Children: ", res);
  console.log("Children content: ", res.filter((m) => !m.deleted).map((m) => m.content));
};
var PermanentUserData = class {
  /**
   * @param {Doc} doc
   * @param {YMap<any>} [storeType]
   */
  constructor(doc2, storeType = doc2.getMap("users")) {
    const dss = /* @__PURE__ */ new Map();
    this.yusers = storeType;
    this.doc = doc2;
    this.clients = /* @__PURE__ */ new Map();
    this.dss = dss;
    const initUser = (user, userDescription) => {
      const ds = user.get("ds");
      const ids = user.get("ids");
      const addClientId = (
        /** @param {number} clientid */
        (clientid) => this.clients.set(clientid, userDescription)
      );
      ds.observe(
        /** @param {YArrayEvent<any>} event */
        (event) => {
          event.changes.added.forEach((item) => {
            item.content.getContent().forEach((encodedDs) => {
              if (encodedDs instanceof Uint8Array) {
                this.dss.set(userDescription, mergeDeleteSets([this.dss.get(userDescription) || createDeleteSet(), readDeleteSet(new DSDecoderV1(createDecoder(encodedDs)))]));
              }
            });
          });
        }
      );
      this.dss.set(userDescription, mergeDeleteSets(ds.map((encodedDs) => readDeleteSet(new DSDecoderV1(createDecoder(encodedDs))))));
      ids.observe(
        /** @param {YArrayEvent<any>} event */
        (event) => event.changes.added.forEach((item) => item.content.getContent().forEach(addClientId))
      );
      ids.forEach(addClientId);
    };
    storeType.observe((event) => {
      event.keysChanged.forEach(
        (userDescription) => initUser(storeType.get(userDescription), userDescription)
      );
    });
    storeType.forEach(initUser);
  }
  /**
   * @param {Doc} doc
   * @param {number} clientid
   * @param {string} userDescription
   * @param {Object} conf
   * @param {function(Transaction, DeleteSet):boolean} [conf.filter]
   */
  setUserMapping(doc2, clientid, userDescription, { filter: filter2 = () => true } = {}) {
    const users = this.yusers;
    let user = users.get(userDescription);
    if (!user) {
      user = new YMap();
      user.set("ids", new YArray());
      user.set("ds", new YArray());
      users.set(userDescription, user);
    }
    user.get("ids").push([clientid]);
    users.observe((_event) => {
      setTimeout(() => {
        const userOverwrite = users.get(userDescription);
        if (userOverwrite !== user) {
          user = userOverwrite;
          this.clients.forEach((_userDescription, clientid2) => {
            if (userDescription === _userDescription) {
              user.get("ids").push([clientid2]);
            }
          });
          const encoder = new DSEncoderV1();
          const ds = this.dss.get(userDescription);
          if (ds) {
            writeDeleteSet(encoder, ds);
            user.get("ds").push([encoder.toUint8Array()]);
          }
        }
      }, 0);
    });
    doc2.on(
      "afterTransaction",
      /** @param {Transaction} transaction */
      (transaction) => {
        setTimeout(() => {
          const yds = user.get("ds");
          const ds = transaction.deleteSet;
          if (transaction.local && ds.clients.size > 0 && filter2(transaction, ds)) {
            const encoder = new DSEncoderV1();
            writeDeleteSet(encoder, ds);
            yds.push([encoder.toUint8Array()]);
          }
        });
      }
    );
  }
  /**
   * @param {number} clientid
   * @return {any}
   */
  getUserByClientId(clientid) {
    return this.clients.get(clientid) || null;
  }
  /**
   * @param {ID} id
   * @return {string | null}
   */
  getUserByDeletedId(id2) {
    for (const [userDescription, ds] of this.dss.entries()) {
      if (isDeleted(ds, id2)) {
        return userDescription;
      }
    }
    return null;
  }
};
var RelativePosition = class {
  /**
   * @param {ID|null} type
   * @param {string|null} tname
   * @param {ID|null} item
   * @param {number} assoc
   */
  constructor(type, tname, item, assoc = 0) {
    this.type = type;
    this.tname = tname;
    this.item = item;
    this.assoc = assoc;
  }
};
var relativePositionToJSON = (rpos) => {
  const json = {};
  if (rpos.type) {
    json.type = rpos.type;
  }
  if (rpos.tname) {
    json.tname = rpos.tname;
  }
  if (rpos.item) {
    json.item = rpos.item;
  }
  if (rpos.assoc != null) {
    json.assoc = rpos.assoc;
  }
  return json;
};
var createRelativePositionFromJSON = (json) => new RelativePosition(json.type == null ? null : createID(json.type.client, json.type.clock), json.tname ?? null, json.item == null ? null : createID(json.item.client, json.item.clock), json.assoc == null ? 0 : json.assoc);
var AbsolutePosition = class {
  /**
   * @param {AbstractType<any>} type
   * @param {number} index
   * @param {number} [assoc]
   */
  constructor(type, index, assoc = 0) {
    this.type = type;
    this.index = index;
    this.assoc = assoc;
  }
};
var createAbsolutePosition = (type, index, assoc = 0) => new AbsolutePosition(type, index, assoc);
var createRelativePosition = (type, item, assoc) => {
  let typeid = null;
  let tname = null;
  if (type._item === null) {
    tname = findRootTypeKey(type);
  } else {
    typeid = createID(type._item.id.client, type._item.id.clock);
  }
  return new RelativePosition(typeid, tname, item, assoc);
};
var createRelativePositionFromTypeIndex = (type, index, assoc = 0) => {
  let t2 = type._start;
  if (assoc < 0) {
    if (index === 0) {
      return createRelativePosition(type, null, assoc);
    }
    index--;
  }
  while (t2 !== null) {
    if (!t2.deleted && t2.countable) {
      if (t2.length > index) {
        return createRelativePosition(type, createID(t2.id.client, t2.id.clock + index), assoc);
      }
      index -= t2.length;
    }
    if (t2.right === null && assoc < 0) {
      return createRelativePosition(type, t2.lastId, assoc);
    }
    t2 = t2.right;
  }
  return createRelativePosition(type, null, assoc);
};
var writeRelativePosition = (encoder, rpos) => {
  const { type, tname, item, assoc } = rpos;
  if (item !== null) {
    writeVarUint(encoder, 0);
    writeID(encoder, item);
  } else if (tname !== null) {
    writeUint8(encoder, 1);
    writeVarString(encoder, tname);
  } else if (type !== null) {
    writeUint8(encoder, 2);
    writeID(encoder, type);
  } else {
    throw unexpectedCase();
  }
  writeVarInt(encoder, assoc);
  return encoder;
};
var encodeRelativePosition = (rpos) => {
  const encoder = createEncoder();
  writeRelativePosition(encoder, rpos);
  return toUint8Array(encoder);
};
var readRelativePosition = (decoder) => {
  let type = null;
  let tname = null;
  let itemID = null;
  switch (readVarUint(decoder)) {
    case 0:
      itemID = readID(decoder);
      break;
    case 1:
      tname = readVarString(decoder);
      break;
    case 2: {
      type = readID(decoder);
    }
  }
  const assoc = hasContent(decoder) ? readVarInt(decoder) : 0;
  return new RelativePosition(type, tname, itemID, assoc);
};
var decodeRelativePosition = (uint8Array) => readRelativePosition(createDecoder(uint8Array));
var getItemWithOffset = (store, id2) => {
  const item = getItem(store, id2);
  const diff = id2.clock - item.id.clock;
  return {
    item,
    diff
  };
};
var createAbsolutePositionFromRelativePosition = (rpos, doc2, followUndoneDeletions = true) => {
  const store = doc2.store;
  const rightID = rpos.item;
  const typeID = rpos.type;
  const tname = rpos.tname;
  const assoc = rpos.assoc;
  let type = null;
  let index = 0;
  if (rightID !== null) {
    if (getState(store, rightID.client) <= rightID.clock) {
      return null;
    }
    const res = followUndoneDeletions ? followRedone(store, rightID) : getItemWithOffset(store, rightID);
    const right = res.item;
    if (!(right instanceof Item)) {
      return null;
    }
    type = /** @type {AbstractType<any>} */
    right.parent;
    if (type._item === null || !type._item.deleted) {
      index = right.deleted || !right.countable ? 0 : res.diff + (assoc >= 0 ? 0 : 1);
      let n2 = right.left;
      while (n2 !== null) {
        if (!n2.deleted && n2.countable) {
          index += n2.length;
        }
        n2 = n2.left;
      }
    }
  } else {
    if (tname !== null) {
      type = doc2.get(tname);
    } else if (typeID !== null) {
      if (getState(store, typeID.client) <= typeID.clock) {
        return null;
      }
      const { item } = followUndoneDeletions ? followRedone(store, typeID) : { item: getItem(store, typeID) };
      if (item instanceof Item && item.content instanceof ContentType) {
        type = item.content.type;
      } else {
        return null;
      }
    } else {
      throw unexpectedCase();
    }
    if (assoc >= 0) {
      index = type._length;
    } else {
      index = 0;
    }
  }
  return createAbsolutePosition(type, index, rpos.assoc);
};
var compareRelativePositions = (a2, b2) => a2 === b2 || a2 !== null && b2 !== null && a2.tname === b2.tname && compareIDs(a2.item, b2.item) && compareIDs(a2.type, b2.type) && a2.assoc === b2.assoc;
var Snapshot = class {
  /**
   * @param {DeleteSet} ds
   * @param {Map<number,number>} sv state map
   */
  constructor(ds, sv) {
    this.ds = ds;
    this.sv = sv;
  }
};
var equalSnapshots = (snap1, snap2) => {
  const ds1 = snap1.ds.clients;
  const ds2 = snap2.ds.clients;
  const sv1 = snap1.sv;
  const sv2 = snap2.sv;
  if (sv1.size !== sv2.size || ds1.size !== ds2.size) {
    return false;
  }
  for (const [key, value] of sv1.entries()) {
    if (sv2.get(key) !== value) {
      return false;
    }
  }
  for (const [client, dsitems1] of ds1.entries()) {
    const dsitems2 = ds2.get(client) || [];
    if (dsitems1.length !== dsitems2.length) {
      return false;
    }
    for (let i2 = 0; i2 < dsitems1.length; i2++) {
      const dsitem1 = dsitems1[i2];
      const dsitem2 = dsitems2[i2];
      if (dsitem1.clock !== dsitem2.clock || dsitem1.len !== dsitem2.len) {
        return false;
      }
    }
  }
  return true;
};
var encodeSnapshotV2 = (snapshot2, encoder = new DSEncoderV2()) => {
  writeDeleteSet(encoder, snapshot2.ds);
  writeStateVector(encoder, snapshot2.sv);
  return encoder.toUint8Array();
};
var encodeSnapshot = (snapshot2) => encodeSnapshotV2(snapshot2, new DSEncoderV1());
var decodeSnapshotV2 = (buf, decoder = new DSDecoderV2(createDecoder(buf))) => {
  return new Snapshot(readDeleteSet(decoder), readStateVector(decoder));
};
var decodeSnapshot = (buf) => decodeSnapshotV2(buf, new DSDecoderV1(createDecoder(buf)));
var createSnapshot = (ds, sm) => new Snapshot(ds, sm);
var emptySnapshot = createSnapshot(createDeleteSet(), /* @__PURE__ */ new Map());
var snapshot = (doc2) => createSnapshot(createDeleteSetFromStructStore(doc2.store), getStateVector(doc2.store));
var isVisible = (item, snapshot2) => snapshot2 === void 0 ? !item.deleted : snapshot2.sv.has(item.id.client) && (snapshot2.sv.get(item.id.client) || 0) > item.id.clock && !isDeleted(snapshot2.ds, item.id);
var splitSnapshotAffectedStructs = (transaction, snapshot2) => {
  const meta = setIfUndefined(transaction.meta, splitSnapshotAffectedStructs, create);
  const store = transaction.doc.store;
  if (!meta.has(snapshot2)) {
    snapshot2.sv.forEach((clock, client) => {
      if (clock < getState(store, client)) {
        getItemCleanStart(transaction, createID(client, clock));
      }
    });
    iterateDeletedStructs(transaction, snapshot2.ds, (_item) => {
    });
    meta.add(snapshot2);
  }
};
var createDocFromSnapshot = (originDoc, snapshot2, newDoc = new Doc()) => {
  if (originDoc.gc) {
    throw new Error("Garbage-collection must be disabled in `originDoc`!");
  }
  const { sv, ds } = snapshot2;
  const encoder = new UpdateEncoderV2();
  originDoc.transact((transaction) => {
    let size2 = 0;
    sv.forEach((clock) => {
      if (clock > 0) {
        size2++;
      }
    });
    writeVarUint(encoder.restEncoder, size2);
    for (const [client, clock] of sv) {
      if (clock === 0) {
        continue;
      }
      if (clock < getState(originDoc.store, client)) {
        getItemCleanStart(transaction, createID(client, clock));
      }
      const structs = originDoc.store.clients.get(client) || [];
      const lastStructIndex = findIndexSS(structs, clock - 1);
      writeVarUint(encoder.restEncoder, lastStructIndex + 1);
      encoder.writeClient(client);
      writeVarUint(encoder.restEncoder, 0);
      for (let i2 = 0; i2 <= lastStructIndex; i2++) {
        structs[i2].write(encoder, 0);
      }
    }
    writeDeleteSet(encoder, ds);
  });
  applyUpdateV2(newDoc, encoder.toUint8Array(), "snapshot");
  return newDoc;
};
var snapshotContainsUpdateV2 = (snapshot2, update, YDecoder = UpdateDecoderV2) => {
  const updateDecoder = new YDecoder(createDecoder(update));
  const lazyDecoder = new LazyStructReader(updateDecoder, false);
  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {
    if ((snapshot2.sv.get(curr.id.client) || 0) < curr.id.clock + curr.length) {
      return false;
    }
  }
  const mergedDS = mergeDeleteSets([snapshot2.ds, readDeleteSet(updateDecoder)]);
  return equalDeleteSets(snapshot2.ds, mergedDS);
};
var snapshotContainsUpdate = (snapshot2, update) => snapshotContainsUpdateV2(snapshot2, update, UpdateDecoderV1);
var StructStore = class {
  constructor() {
    this.clients = /* @__PURE__ */ new Map();
    this.pendingStructs = null;
    this.pendingDs = null;
  }
};
var getStateVector = (store) => {
  const sm = /* @__PURE__ */ new Map();
  store.clients.forEach((structs, client) => {
    const struct = structs[structs.length - 1];
    sm.set(client, struct.id.clock + struct.length);
  });
  return sm;
};
var getState = (store, client) => {
  const structs = store.clients.get(client);
  if (structs === void 0) {
    return 0;
  }
  const lastStruct = structs[structs.length - 1];
  return lastStruct.id.clock + lastStruct.length;
};
var addStruct = (store, struct) => {
  let structs = store.clients.get(struct.id.client);
  if (structs === void 0) {
    structs = [];
    store.clients.set(struct.id.client, structs);
  } else {
    const lastStruct = structs[structs.length - 1];
    if (lastStruct.id.clock + lastStruct.length !== struct.id.clock) {
      throw unexpectedCase();
    }
  }
  structs.push(struct);
};
var findIndexSS = (structs, clock) => {
  let left = 0;
  let right = structs.length - 1;
  let mid = structs[right];
  let midclock = mid.id.clock;
  if (midclock === clock) {
    return right;
  }
  let midindex = floor(clock / (midclock + mid.length - 1) * right);
  while (left <= right) {
    mid = structs[midindex];
    midclock = mid.id.clock;
    if (midclock <= clock) {
      if (clock < midclock + mid.length) {
        return midindex;
      }
      left = midindex + 1;
    } else {
      right = midindex - 1;
    }
    midindex = floor((left + right) / 2);
  }
  throw unexpectedCase();
};
var find = (store, id2) => {
  const structs = store.clients.get(id2.client);
  return structs[findIndexSS(structs, id2.clock)];
};
var getItem = (
  /** @type {function(StructStore,ID):Item} */
  find
);
var findIndexCleanStart = (transaction, structs, clock) => {
  const index = findIndexSS(structs, clock);
  const struct = structs[index];
  if (struct.id.clock < clock && struct instanceof Item) {
    structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));
    return index + 1;
  }
  return index;
};
var getItemCleanStart = (transaction, id2) => {
  const structs = (
    /** @type {Array<Item>} */
    transaction.doc.store.clients.get(id2.client)
  );
  return structs[findIndexCleanStart(transaction, structs, id2.clock)];
};
var getItemCleanEnd = (transaction, store, id2) => {
  const structs = store.clients.get(id2.client);
  const index = findIndexSS(structs, id2.clock);
  const struct = structs[index];
  if (id2.clock !== struct.id.clock + struct.length - 1 && struct.constructor !== GC) {
    structs.splice(index + 1, 0, splitItem(transaction, struct, id2.clock - struct.id.clock + 1));
  }
  return struct;
};
var replaceStruct = (store, struct, newStruct) => {
  const structs = (
    /** @type {Array<GC|Item>} */
    store.clients.get(struct.id.client)
  );
  structs[findIndexSS(structs, struct.id.clock)] = newStruct;
};
var iterateStructs = (transaction, structs, clockStart, len3, f2) => {
  if (len3 === 0) {
    return;
  }
  const clockEnd = clockStart + len3;
  let index = findIndexCleanStart(transaction, structs, clockStart);
  let struct;
  do {
    struct = structs[index++];
    if (clockEnd < struct.id.clock + struct.length) {
      findIndexCleanStart(transaction, structs, clockEnd);
    }
    f2(struct);
  } while (index < structs.length && structs[index].id.clock < clockEnd);
};
var Transaction = class {
  /**
   * @param {Doc} doc
   * @param {any} origin
   * @param {boolean} local
   */
  constructor(doc2, origin, local) {
    this.doc = doc2;
    this.deleteSet = new DeleteSet();
    this.beforeState = getStateVector(doc2.store);
    this.afterState = /* @__PURE__ */ new Map();
    this.changed = /* @__PURE__ */ new Map();
    this.changedParentTypes = /* @__PURE__ */ new Map();
    this._mergeStructs = [];
    this.origin = origin;
    this.meta = /* @__PURE__ */ new Map();
    this.local = local;
    this.subdocsAdded = /* @__PURE__ */ new Set();
    this.subdocsRemoved = /* @__PURE__ */ new Set();
    this.subdocsLoaded = /* @__PURE__ */ new Set();
    this._needFormattingCleanup = false;
  }
};
var writeUpdateMessageFromTransaction = (encoder, transaction) => {
  if (transaction.deleteSet.clients.size === 0 && !any(transaction.afterState, (clock, client) => transaction.beforeState.get(client) !== clock)) {
    return false;
  }
  sortAndMergeDeleteSet(transaction.deleteSet);
  writeStructsFromTransaction(encoder, transaction);
  writeDeleteSet(encoder, transaction.deleteSet);
  return true;
};
var addChangedTypeToTransaction = (transaction, type, parentSub) => {
  const item = type._item;
  if (item === null || item.id.clock < (transaction.beforeState.get(item.id.client) || 0) && !item.deleted) {
    setIfUndefined(transaction.changed, type, create).add(parentSub);
  }
};
var tryToMergeWithLefts = (structs, pos) => {
  let right = structs[pos];
  let left = structs[pos - 1];
  let i2 = pos;
  for (; i2 > 0; right = left, left = structs[--i2 - 1]) {
    if (left.deleted === right.deleted && left.constructor === right.constructor) {
      if (left.mergeWith(right)) {
        if (right instanceof Item && right.parentSub !== null && /** @type {AbstractType<any>} */
        right.parent._map.get(right.parentSub) === right) {
          right.parent._map.set(
            right.parentSub,
            /** @type {Item} */
            left
          );
        }
        continue;
      }
    }
    break;
  }
  const merged = pos - i2;
  if (merged) {
    structs.splice(pos + 1 - merged, merged);
  }
  return merged;
};
var tryGcDeleteSet = (ds, store, gcFilter) => {
  for (const [client, deleteItems] of ds.clients.entries()) {
    const structs = (
      /** @type {Array<GC|Item>} */
      store.clients.get(client)
    );
    for (let di = deleteItems.length - 1; di >= 0; di--) {
      const deleteItem = deleteItems[di];
      const endDeleteItemClock = deleteItem.clock + deleteItem.len;
      for (let si = findIndexSS(structs, deleteItem.clock), struct = structs[si]; si < structs.length && struct.id.clock < endDeleteItemClock; struct = structs[++si]) {
        const struct2 = structs[si];
        if (deleteItem.clock + deleteItem.len <= struct2.id.clock) {
          break;
        }
        if (struct2 instanceof Item && struct2.deleted && !struct2.keep && gcFilter(struct2)) {
          struct2.gc(store, false);
        }
      }
    }
  }
};
var tryMergeDeleteSet = (ds, store) => {
  ds.clients.forEach((deleteItems, client) => {
    const structs = (
      /** @type {Array<GC|Item>} */
      store.clients.get(client)
    );
    for (let di = deleteItems.length - 1; di >= 0; di--) {
      const deleteItem = deleteItems[di];
      const mostRightIndexToCheck = min(structs.length - 1, 1 + findIndexSS(structs, deleteItem.clock + deleteItem.len - 1));
      for (let si = mostRightIndexToCheck, struct = structs[si]; si > 0 && struct.id.clock >= deleteItem.clock; struct = structs[si]) {
        si -= 1 + tryToMergeWithLefts(structs, si);
      }
    }
  });
};
var tryGc = (ds, store, gcFilter) => {
  tryGcDeleteSet(ds, store, gcFilter);
  tryMergeDeleteSet(ds, store);
};
var cleanupTransactions = (transactionCleanups, i2) => {
  if (i2 < transactionCleanups.length) {
    const transaction = transactionCleanups[i2];
    const doc2 = transaction.doc;
    const store = doc2.store;
    const ds = transaction.deleteSet;
    const mergeStructs = transaction._mergeStructs;
    try {
      sortAndMergeDeleteSet(ds);
      transaction.afterState = getStateVector(transaction.doc.store);
      doc2.emit("beforeObserverCalls", [transaction, doc2]);
      const fs = [];
      transaction.changed.forEach(
        (subs, itemtype) => fs.push(() => {
          if (itemtype._item === null || !itemtype._item.deleted) {
            itemtype._callObserver(transaction, subs);
          }
        })
      );
      fs.push(() => {
        transaction.changedParentTypes.forEach((events, type) => {
          if (type._dEH.l.length > 0 && (type._item === null || !type._item.deleted)) {
            events = events.filter(
              (event) => event.target._item === null || !event.target._item.deleted
            );
            events.forEach((event) => {
              event.currentTarget = type;
              event._path = null;
            });
            events.sort((event1, event2) => event1.path.length - event2.path.length);
            callEventHandlerListeners(type._dEH, events, transaction);
          }
        });
      });
      fs.push(() => doc2.emit("afterTransaction", [transaction, doc2]));
      callAll(fs, []);
      if (transaction._needFormattingCleanup) {
        cleanupYTextAfterTransaction(transaction);
      }
    } finally {
      if (doc2.gc) {
        tryGcDeleteSet(ds, store, doc2.gcFilter);
      }
      tryMergeDeleteSet(ds, store);
      transaction.afterState.forEach((clock, client) => {
        const beforeClock = transaction.beforeState.get(client) || 0;
        if (beforeClock !== clock) {
          const structs = (
            /** @type {Array<GC|Item>} */
            store.clients.get(client)
          );
          const firstChangePos = max(findIndexSS(structs, beforeClock), 1);
          for (let i3 = structs.length - 1; i3 >= firstChangePos; ) {
            i3 -= 1 + tryToMergeWithLefts(structs, i3);
          }
        }
      });
      for (let i3 = mergeStructs.length - 1; i3 >= 0; i3--) {
        const { client, clock } = mergeStructs[i3].id;
        const structs = (
          /** @type {Array<GC|Item>} */
          store.clients.get(client)
        );
        const replacedStructPos = findIndexSS(structs, clock);
        if (replacedStructPos + 1 < structs.length) {
          if (tryToMergeWithLefts(structs, replacedStructPos + 1) > 1) {
            continue;
          }
        }
        if (replacedStructPos > 0) {
          tryToMergeWithLefts(structs, replacedStructPos);
        }
      }
      if (!transaction.local && transaction.afterState.get(doc2.clientID) !== transaction.beforeState.get(doc2.clientID)) {
        print(ORANGE, BOLD, "[yjs] ", UNBOLD, RED, "Changed the client-id because another client seems to be using it.");
        doc2.clientID = generateNewClientId();
      }
      doc2.emit("afterTransactionCleanup", [transaction, doc2]);
      if (doc2._observers.has("update")) {
        const encoder = new UpdateEncoderV1();
        const hasContent2 = writeUpdateMessageFromTransaction(encoder, transaction);
        if (hasContent2) {
          doc2.emit("update", [encoder.toUint8Array(), transaction.origin, doc2, transaction]);
        }
      }
      if (doc2._observers.has("updateV2")) {
        const encoder = new UpdateEncoderV2();
        const hasContent2 = writeUpdateMessageFromTransaction(encoder, transaction);
        if (hasContent2) {
          doc2.emit("updateV2", [encoder.toUint8Array(), transaction.origin, doc2, transaction]);
        }
      }
      const { subdocsAdded, subdocsLoaded, subdocsRemoved } = transaction;
      if (subdocsAdded.size > 0 || subdocsRemoved.size > 0 || subdocsLoaded.size > 0) {
        subdocsAdded.forEach((subdoc) => {
          subdoc.clientID = doc2.clientID;
          if (subdoc.collectionid == null) {
            subdoc.collectionid = doc2.collectionid;
          }
          doc2.subdocs.add(subdoc);
        });
        subdocsRemoved.forEach((subdoc) => doc2.subdocs.delete(subdoc));
        doc2.emit("subdocs", [{ loaded: subdocsLoaded, added: subdocsAdded, removed: subdocsRemoved }, doc2, transaction]);
        subdocsRemoved.forEach((subdoc) => subdoc.destroy());
      }
      if (transactionCleanups.length <= i2 + 1) {
        doc2._transactionCleanups = [];
        doc2.emit("afterAllTransactions", [doc2, transactionCleanups]);
      } else {
        cleanupTransactions(transactionCleanups, i2 + 1);
      }
    }
  }
};
var transact = (doc2, f2, origin = null, local = true) => {
  const transactionCleanups = doc2._transactionCleanups;
  let initialCall = false;
  let result = null;
  if (doc2._transaction === null) {
    initialCall = true;
    doc2._transaction = new Transaction(doc2, origin, local);
    transactionCleanups.push(doc2._transaction);
    if (transactionCleanups.length === 1) {
      doc2.emit("beforeAllTransactions", [doc2]);
    }
    doc2.emit("beforeTransaction", [doc2._transaction, doc2]);
  }
  try {
    result = f2(doc2._transaction);
  } finally {
    if (initialCall) {
      const finishCleanup = doc2._transaction === transactionCleanups[0];
      doc2._transaction = null;
      if (finishCleanup) {
        cleanupTransactions(transactionCleanups, 0);
      }
    }
  }
  return result;
};
var StackItem = class {
  /**
   * @param {DeleteSet} deletions
   * @param {DeleteSet} insertions
   */
  constructor(deletions, insertions) {
    this.insertions = insertions;
    this.deletions = deletions;
    this.meta = /* @__PURE__ */ new Map();
  }
};
var clearUndoManagerStackItem = (tr, um, stackItem) => {
  iterateDeletedStructs(tr, stackItem.deletions, (item) => {
    if (item instanceof Item && um.scope.some((type) => type === tr.doc || isParentOf(
      /** @type {AbstractType<any>} */
      type,
      item
    ))) {
      keepItem(item, false);
    }
  });
};
var popStackItem = (undoManager, stack, eventType) => {
  let _tr = null;
  const doc2 = undoManager.doc;
  const scope = undoManager.scope;
  transact(doc2, (transaction) => {
    while (stack.length > 0 && undoManager.currStackItem === null) {
      const store = doc2.store;
      const stackItem = (
        /** @type {StackItem} */
        stack.pop()
      );
      const itemsToRedo = /* @__PURE__ */ new Set();
      const itemsToDelete = [];
      let performedChange = false;
      iterateDeletedStructs(transaction, stackItem.insertions, (struct) => {
        if (struct instanceof Item) {
          if (struct.redone !== null) {
            let { item, diff } = followRedone(store, struct.id);
            if (diff > 0) {
              item = getItemCleanStart(transaction, createID(item.id.client, item.id.clock + diff));
            }
            struct = item;
          }
          if (!struct.deleted && scope.some((type) => type === transaction.doc || isParentOf(
            /** @type {AbstractType<any>} */
            type,
            /** @type {Item} */
            struct
          ))) {
            itemsToDelete.push(struct);
          }
        }
      });
      iterateDeletedStructs(transaction, stackItem.deletions, (struct) => {
        if (struct instanceof Item && scope.some((type) => type === transaction.doc || isParentOf(
          /** @type {AbstractType<any>} */
          type,
          struct
        )) && // Never redo structs in stackItem.insertions because they were created and deleted in the same capture interval.
        !isDeleted(stackItem.insertions, struct.id)) {
          itemsToRedo.add(struct);
        }
      });
      itemsToRedo.forEach((struct) => {
        performedChange = redoItem(transaction, struct, itemsToRedo, stackItem.insertions, undoManager.ignoreRemoteMapChanges, undoManager) !== null || performedChange;
      });
      for (let i2 = itemsToDelete.length - 1; i2 >= 0; i2--) {
        const item = itemsToDelete[i2];
        if (undoManager.deleteFilter(item)) {
          item.delete(transaction);
          performedChange = true;
        }
      }
      undoManager.currStackItem = performedChange ? stackItem : null;
    }
    transaction.changed.forEach((subProps, type) => {
      if (subProps.has(null) && type._searchMarker) {
        type._searchMarker.length = 0;
      }
    });
    _tr = transaction;
  }, undoManager);
  const res = undoManager.currStackItem;
  if (res != null) {
    const changedParentTypes = _tr.changedParentTypes;
    undoManager.emit("stack-item-popped", [{ stackItem: res, type: eventType, changedParentTypes, origin: undoManager }, undoManager]);
    undoManager.currStackItem = null;
  }
  return res;
};
var UndoManager = class extends ObservableV2 {
  /**
   * @param {Doc|AbstractType<any>|Array<AbstractType<any>>} typeScope Limits the scope of the UndoManager. If this is set to a ydoc instance, all changes on that ydoc will be undone. If set to a specific type, only changes on that type or its children will be undone. Also accepts an array of types.
   * @param {UndoManagerOptions} options
   */
  constructor(typeScope, {
    captureTimeout = 500,
    captureTransaction = (_tr) => true,
    deleteFilter = () => true,
    trackedOrigins = /* @__PURE__ */ new Set([null]),
    ignoreRemoteMapChanges = false,
    doc: doc2 = (
      /** @type {Doc} */
      isArray(typeScope) ? typeScope[0].doc : typeScope instanceof Doc ? typeScope : typeScope.doc
    )
  } = {}) {
    super();
    this.scope = [];
    this.doc = doc2;
    this.addToScope(typeScope);
    this.deleteFilter = deleteFilter;
    trackedOrigins.add(this);
    this.trackedOrigins = trackedOrigins;
    this.captureTransaction = captureTransaction;
    this.undoStack = [];
    this.redoStack = [];
    this.undoing = false;
    this.redoing = false;
    this.currStackItem = null;
    this.lastChange = 0;
    this.ignoreRemoteMapChanges = ignoreRemoteMapChanges;
    this.captureTimeout = captureTimeout;
    this.afterTransactionHandler = (transaction) => {
      if (!this.captureTransaction(transaction) || !this.scope.some((type) => transaction.changedParentTypes.has(
        /** @type {AbstractType<any>} */
        type
      ) || type === this.doc) || !this.trackedOrigins.has(transaction.origin) && (!transaction.origin || !this.trackedOrigins.has(transaction.origin.constructor))) {
        return;
      }
      const undoing = this.undoing;
      const redoing = this.redoing;
      const stack = undoing ? this.redoStack : this.undoStack;
      if (undoing) {
        this.stopCapturing();
      } else if (!redoing) {
        this.clear(false, true);
      }
      const insertions = new DeleteSet();
      transaction.afterState.forEach((endClock, client) => {
        const startClock = transaction.beforeState.get(client) || 0;
        const len3 = endClock - startClock;
        if (len3 > 0) {
          addToDeleteSet(insertions, client, startClock, len3);
        }
      });
      const now = getUnixTime();
      let didAdd = false;
      if (this.lastChange > 0 && now - this.lastChange < this.captureTimeout && stack.length > 0 && !undoing && !redoing) {
        const lastOp = stack[stack.length - 1];
        lastOp.deletions = mergeDeleteSets([lastOp.deletions, transaction.deleteSet]);
        lastOp.insertions = mergeDeleteSets([lastOp.insertions, insertions]);
      } else {
        stack.push(new StackItem(transaction.deleteSet, insertions));
        didAdd = true;
      }
      if (!undoing && !redoing) {
        this.lastChange = now;
      }
      iterateDeletedStructs(
        transaction,
        transaction.deleteSet,
        /** @param {Item|GC} item */
        (item) => {
          if (item instanceof Item && this.scope.some((type) => type === transaction.doc || isParentOf(
            /** @type {AbstractType<any>} */
            type,
            item
          ))) {
            keepItem(item, true);
          }
        }
      );
      const changeEvent = [{ stackItem: stack[stack.length - 1], origin: transaction.origin, type: undoing ? "redo" : "undo", changedParentTypes: transaction.changedParentTypes }, this];
      if (didAdd) {
        this.emit("stack-item-added", changeEvent);
      } else {
        this.emit("stack-item-updated", changeEvent);
      }
    };
    this.doc.on("afterTransaction", this.afterTransactionHandler);
    this.doc.on("destroy", () => {
      this.destroy();
    });
  }
  /**
   * Extend the scope.
   *
   * @param {Array<AbstractType<any> | Doc> | AbstractType<any> | Doc} ytypes
   */
  addToScope(ytypes) {
    const tmpSet = new Set(this.scope);
    ytypes = isArray(ytypes) ? ytypes : [ytypes];
    ytypes.forEach((ytype) => {
      if (!tmpSet.has(ytype)) {
        tmpSet.add(ytype);
        if (ytype instanceof AbstractType ? ytype.doc !== this.doc : ytype !== this.doc) warn("[yjs#509] Not same Y.Doc");
        this.scope.push(ytype);
      }
    });
  }
  /**
   * @param {any} origin
   */
  addTrackedOrigin(origin) {
    this.trackedOrigins.add(origin);
  }
  /**
   * @param {any} origin
   */
  removeTrackedOrigin(origin) {
    this.trackedOrigins.delete(origin);
  }
  clear(clearUndoStack = true, clearRedoStack = true) {
    if (clearUndoStack && this.canUndo() || clearRedoStack && this.canRedo()) {
      this.doc.transact((tr) => {
        if (clearUndoStack) {
          this.undoStack.forEach((item) => clearUndoManagerStackItem(tr, this, item));
          this.undoStack = [];
        }
        if (clearRedoStack) {
          this.redoStack.forEach((item) => clearUndoManagerStackItem(tr, this, item));
          this.redoStack = [];
        }
        this.emit("stack-cleared", [{ undoStackCleared: clearUndoStack, redoStackCleared: clearRedoStack }]);
      });
    }
  }
  /**
   * UndoManager merges Undo-StackItem if they are created within time-gap
   * smaller than `options.captureTimeout`. Call `um.stopCapturing()` so that the next
   * StackItem won't be merged.
   *
   *
   * @example
   *     // without stopCapturing
   *     ytext.insert(0, 'a')
   *     ytext.insert(1, 'b')
   *     um.undo()
   *     ytext.toString() // => '' (note that 'ab' was removed)
   *     // with stopCapturing
   *     ytext.insert(0, 'a')
   *     um.stopCapturing()
   *     ytext.insert(0, 'b')
   *     um.undo()
   *     ytext.toString() // => 'a' (note that only 'b' was removed)
   *
   */
  stopCapturing() {
    this.lastChange = 0;
  }
  /**
   * Undo last changes on type.
   *
   * @return {StackItem?} Returns StackItem if a change was applied
   */
  undo() {
    this.undoing = true;
    let res;
    try {
      res = popStackItem(this, this.undoStack, "undo");
    } finally {
      this.undoing = false;
    }
    return res;
  }
  /**
   * Redo last undo operation.
   *
   * @return {StackItem?} Returns StackItem if a change was applied
   */
  redo() {
    this.redoing = true;
    let res;
    try {
      res = popStackItem(this, this.redoStack, "redo");
    } finally {
      this.redoing = false;
    }
    return res;
  }
  /**
   * Are undo steps available?
   *
   * @return {boolean} `true` if undo is possible
   */
  canUndo() {
    return this.undoStack.length > 0;
  }
  /**
   * Are redo steps available?
   *
   * @return {boolean} `true` if redo is possible
   */
  canRedo() {
    return this.redoStack.length > 0;
  }
  destroy() {
    this.trackedOrigins.delete(this);
    this.doc.off("afterTransaction", this.afterTransactionHandler);
    super.destroy();
  }
};
function* lazyStructReaderGenerator(decoder) {
  const numOfStateUpdates = readVarUint(decoder.restDecoder);
  for (let i2 = 0; i2 < numOfStateUpdates; i2++) {
    const numberOfStructs = readVarUint(decoder.restDecoder);
    const client = decoder.readClient();
    let clock = readVarUint(decoder.restDecoder);
    for (let i3 = 0; i3 < numberOfStructs; i3++) {
      const info = decoder.readInfo();
      if (info === 10) {
        const len3 = readVarUint(decoder.restDecoder);
        yield new Skip(createID(client, clock), len3);
        clock += len3;
      } else if ((BITS5 & info) !== 0) {
        const cantCopyParentInfo = (info & (BIT7 | BIT8)) === 0;
        const struct = new Item(
          createID(client, clock),
          null,
          // left
          (info & BIT8) === BIT8 ? decoder.readLeftID() : null,
          // origin
          null,
          // right
          (info & BIT7) === BIT7 ? decoder.readRightID() : null,
          // right origin
          // @ts-ignore Force writing a string here.
          cantCopyParentInfo ? decoder.readParentInfo() ? decoder.readString() : decoder.readLeftID() : null,
          // parent
          cantCopyParentInfo && (info & BIT6) === BIT6 ? decoder.readString() : null,
          // parentSub
          readItemContent(decoder, info)
          // item content
        );
        yield struct;
        clock += struct.length;
      } else {
        const len3 = decoder.readLen();
        yield new GC(createID(client, clock), len3);
        clock += len3;
      }
    }
  }
}
var LazyStructReader = class {
  /**
   * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
   * @param {boolean} filterSkips
   */
  constructor(decoder, filterSkips) {
    this.gen = lazyStructReaderGenerator(decoder);
    this.curr = null;
    this.done = false;
    this.filterSkips = filterSkips;
    this.next();
  }
  /**
   * @return {Item | GC | Skip |null}
   */
  next() {
    do {
      this.curr = this.gen.next().value || null;
    } while (this.filterSkips && this.curr !== null && this.curr.constructor === Skip);
    return this.curr;
  }
};
var logUpdate = (update) => logUpdateV2(update, UpdateDecoderV1);
var logUpdateV2 = (update, YDecoder = UpdateDecoderV2) => {
  const structs = [];
  const updateDecoder = new YDecoder(createDecoder(update));
  const lazyDecoder = new LazyStructReader(updateDecoder, false);
  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {
    structs.push(curr);
  }
  print("Structs: ", structs);
  const ds = readDeleteSet(updateDecoder);
  print("DeleteSet: ", ds);
};
var decodeUpdate = (update) => decodeUpdateV2(update, UpdateDecoderV1);
var decodeUpdateV2 = (update, YDecoder = UpdateDecoderV2) => {
  const structs = [];
  const updateDecoder = new YDecoder(createDecoder(update));
  const lazyDecoder = new LazyStructReader(updateDecoder, false);
  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {
    structs.push(curr);
  }
  return {
    structs,
    ds: readDeleteSet(updateDecoder)
  };
};
var LazyStructWriter = class {
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  constructor(encoder) {
    this.currClient = 0;
    this.startClock = 0;
    this.written = 0;
    this.encoder = encoder;
    this.clientStructs = [];
  }
};
var mergeUpdates = (updates) => mergeUpdatesV2(updates, UpdateDecoderV1, UpdateEncoderV1);
var encodeStateVectorFromUpdateV2 = (update, YEncoder = DSEncoderV2, YDecoder = UpdateDecoderV2) => {
  const encoder = new YEncoder();
  const updateDecoder = new LazyStructReader(new YDecoder(createDecoder(update)), false);
  let curr = updateDecoder.curr;
  if (curr !== null) {
    let size2 = 0;
    let currClient = curr.id.client;
    let stopCounting = curr.id.clock !== 0;
    let currClock = stopCounting ? 0 : curr.id.clock + curr.length;
    for (; curr !== null; curr = updateDecoder.next()) {
      if (currClient !== curr.id.client) {
        if (currClock !== 0) {
          size2++;
          writeVarUint(encoder.restEncoder, currClient);
          writeVarUint(encoder.restEncoder, currClock);
        }
        currClient = curr.id.client;
        currClock = 0;
        stopCounting = curr.id.clock !== 0;
      }
      if (curr.constructor === Skip) {
        stopCounting = true;
      }
      if (!stopCounting) {
        currClock = curr.id.clock + curr.length;
      }
    }
    if (currClock !== 0) {
      size2++;
      writeVarUint(encoder.restEncoder, currClient);
      writeVarUint(encoder.restEncoder, currClock);
    }
    const enc = createEncoder();
    writeVarUint(enc, size2);
    writeBinaryEncoder(enc, encoder.restEncoder);
    encoder.restEncoder = enc;
    return encoder.toUint8Array();
  } else {
    writeVarUint(encoder.restEncoder, 0);
    return encoder.toUint8Array();
  }
};
var encodeStateVectorFromUpdate = (update) => encodeStateVectorFromUpdateV2(update, DSEncoderV1, UpdateDecoderV1);
var parseUpdateMetaV2 = (update, YDecoder = UpdateDecoderV2) => {
  const from3 = /* @__PURE__ */ new Map();
  const to = /* @__PURE__ */ new Map();
  const updateDecoder = new LazyStructReader(new YDecoder(createDecoder(update)), false);
  let curr = updateDecoder.curr;
  if (curr !== null) {
    let currClient = curr.id.client;
    let currClock = curr.id.clock;
    from3.set(currClient, currClock);
    for (; curr !== null; curr = updateDecoder.next()) {
      if (currClient !== curr.id.client) {
        to.set(currClient, currClock);
        from3.set(curr.id.client, curr.id.clock);
        currClient = curr.id.client;
      }
      currClock = curr.id.clock + curr.length;
    }
    to.set(currClient, currClock);
  }
  return { from: from3, to };
};
var parseUpdateMeta = (update) => parseUpdateMetaV2(update, UpdateDecoderV1);
var sliceStruct = (left, diff) => {
  if (left.constructor === GC) {
    const { client, clock } = left.id;
    return new GC(createID(client, clock + diff), left.length - diff);
  } else if (left.constructor === Skip) {
    const { client, clock } = left.id;
    return new Skip(createID(client, clock + diff), left.length - diff);
  } else {
    const leftItem = (
      /** @type {Item} */
      left
    );
    const { client, clock } = leftItem.id;
    return new Item(
      createID(client, clock + diff),
      null,
      createID(client, clock + diff - 1),
      null,
      leftItem.rightOrigin,
      leftItem.parent,
      leftItem.parentSub,
      leftItem.content.splice(diff)
    );
  }
};
var mergeUpdatesV2 = (updates, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {
  if (updates.length === 1) {
    return updates[0];
  }
  const updateDecoders = updates.map((update) => new YDecoder(createDecoder(update)));
  let lazyStructDecoders = updateDecoders.map((decoder) => new LazyStructReader(decoder, true));
  let currWrite = null;
  const updateEncoder = new YEncoder();
  const lazyStructEncoder = new LazyStructWriter(updateEncoder);
  while (true) {
    lazyStructDecoders = lazyStructDecoders.filter((dec) => dec.curr !== null);
    lazyStructDecoders.sort(
      /** @type {function(any,any):number} */
      (dec1, dec2) => {
        if (dec1.curr.id.client === dec2.curr.id.client) {
          const clockDiff = dec1.curr.id.clock - dec2.curr.id.clock;
          if (clockDiff === 0) {
            return dec1.curr.constructor === dec2.curr.constructor ? 0 : dec1.curr.constructor === Skip ? 1 : -1;
          } else {
            return clockDiff;
          }
        } else {
          return dec2.curr.id.client - dec1.curr.id.client;
        }
      }
    );
    if (lazyStructDecoders.length === 0) {
      break;
    }
    const currDecoder = lazyStructDecoders[0];
    const firstClient = (
      /** @type {Item | GC} */
      currDecoder.curr.id.client
    );
    if (currWrite !== null) {
      let curr = (
        /** @type {Item | GC | null} */
        currDecoder.curr
      );
      let iterated = false;
      while (curr !== null && curr.id.clock + curr.length <= currWrite.struct.id.clock + currWrite.struct.length && curr.id.client >= currWrite.struct.id.client) {
        curr = currDecoder.next();
        iterated = true;
      }
      if (curr === null || // current decoder is empty
      curr.id.client !== firstClient || // check whether there is another decoder that has has updates from `firstClient`
      iterated && curr.id.clock > currWrite.struct.id.clock + currWrite.struct.length) {
        continue;
      }
      if (firstClient !== currWrite.struct.id.client) {
        writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
        currWrite = { struct: curr, offset: 0 };
        currDecoder.next();
      } else {
        if (currWrite.struct.id.clock + currWrite.struct.length < curr.id.clock) {
          if (currWrite.struct.constructor === Skip) {
            currWrite.struct.length = curr.id.clock + curr.length - currWrite.struct.id.clock;
          } else {
            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
            const diff = curr.id.clock - currWrite.struct.id.clock - currWrite.struct.length;
            const struct = new Skip(createID(firstClient, currWrite.struct.id.clock + currWrite.struct.length), diff);
            currWrite = { struct, offset: 0 };
          }
        } else {
          const diff = currWrite.struct.id.clock + currWrite.struct.length - curr.id.clock;
          if (diff > 0) {
            if (currWrite.struct.constructor === Skip) {
              currWrite.struct.length -= diff;
            } else {
              curr = sliceStruct(curr, diff);
            }
          }
          if (!currWrite.struct.mergeWith(
            /** @type {any} */
            curr
          )) {
            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
            currWrite = { struct: curr, offset: 0 };
            currDecoder.next();
          }
        }
      }
    } else {
      currWrite = { struct: (
        /** @type {Item | GC} */
        currDecoder.curr
      ), offset: 0 };
      currDecoder.next();
    }
    for (let next = currDecoder.curr; next !== null && next.id.client === firstClient && next.id.clock === currWrite.struct.id.clock + currWrite.struct.length && next.constructor !== Skip; next = currDecoder.next()) {
      writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
      currWrite = { struct: next, offset: 0 };
    }
  }
  if (currWrite !== null) {
    writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
    currWrite = null;
  }
  finishLazyStructWriting(lazyStructEncoder);
  const dss = updateDecoders.map((decoder) => readDeleteSet(decoder));
  const ds = mergeDeleteSets(dss);
  writeDeleteSet(updateEncoder, ds);
  return updateEncoder.toUint8Array();
};
var diffUpdateV2 = (update, sv, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {
  const state = decodeStateVector(sv);
  const encoder = new YEncoder();
  const lazyStructWriter = new LazyStructWriter(encoder);
  const decoder = new YDecoder(createDecoder(update));
  const reader = new LazyStructReader(decoder, false);
  while (reader.curr) {
    const curr = reader.curr;
    const currClient = curr.id.client;
    const svClock = state.get(currClient) || 0;
    if (reader.curr.constructor === Skip) {
      reader.next();
      continue;
    }
    if (curr.id.clock + curr.length > svClock) {
      writeStructToLazyStructWriter(lazyStructWriter, curr, max(svClock - curr.id.clock, 0));
      reader.next();
      while (reader.curr && reader.curr.id.client === currClient) {
        writeStructToLazyStructWriter(lazyStructWriter, reader.curr, 0);
        reader.next();
      }
    } else {
      while (reader.curr && reader.curr.id.client === currClient && reader.curr.id.clock + reader.curr.length <= svClock) {
        reader.next();
      }
    }
  }
  finishLazyStructWriting(lazyStructWriter);
  const ds = readDeleteSet(decoder);
  writeDeleteSet(encoder, ds);
  return encoder.toUint8Array();
};
var diffUpdate = (update, sv) => diffUpdateV2(update, sv, UpdateDecoderV1, UpdateEncoderV1);
var flushLazyStructWriter = (lazyWriter) => {
  if (lazyWriter.written > 0) {
    lazyWriter.clientStructs.push({ written: lazyWriter.written, restEncoder: toUint8Array(lazyWriter.encoder.restEncoder) });
    lazyWriter.encoder.restEncoder = createEncoder();
    lazyWriter.written = 0;
  }
};
var writeStructToLazyStructWriter = (lazyWriter, struct, offset) => {
  if (lazyWriter.written > 0 && lazyWriter.currClient !== struct.id.client) {
    flushLazyStructWriter(lazyWriter);
  }
  if (lazyWriter.written === 0) {
    lazyWriter.currClient = struct.id.client;
    lazyWriter.encoder.writeClient(struct.id.client);
    writeVarUint(lazyWriter.encoder.restEncoder, struct.id.clock + offset);
  }
  struct.write(lazyWriter.encoder, offset);
  lazyWriter.written++;
};
var finishLazyStructWriting = (lazyWriter) => {
  flushLazyStructWriter(lazyWriter);
  const restEncoder = lazyWriter.encoder.restEncoder;
  writeVarUint(restEncoder, lazyWriter.clientStructs.length);
  for (let i2 = 0; i2 < lazyWriter.clientStructs.length; i2++) {
    const partStructs = lazyWriter.clientStructs[i2];
    writeVarUint(restEncoder, partStructs.written);
    writeUint8Array(restEncoder, partStructs.restEncoder);
  }
};
var convertUpdateFormat = (update, blockTransformer, YDecoder, YEncoder) => {
  const updateDecoder = new YDecoder(createDecoder(update));
  const lazyDecoder = new LazyStructReader(updateDecoder, false);
  const updateEncoder = new YEncoder();
  const lazyWriter = new LazyStructWriter(updateEncoder);
  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {
    writeStructToLazyStructWriter(lazyWriter, blockTransformer(curr), 0);
  }
  finishLazyStructWriting(lazyWriter);
  const ds = readDeleteSet(updateDecoder);
  writeDeleteSet(updateEncoder, ds);
  return updateEncoder.toUint8Array();
};
var createObfuscator = ({ formatting = true, subdocs = true, yxml = true } = {}) => {
  let i2 = 0;
  const mapKeyCache = create2();
  const nodeNameCache = create2();
  const formattingKeyCache = create2();
  const formattingValueCache = create2();
  formattingValueCache.set(null, null);
  return (block) => {
    switch (block.constructor) {
      case GC:
      case Skip:
        return block;
      case Item: {
        const item = (
          /** @type {Item} */
          block
        );
        const content = item.content;
        switch (content.constructor) {
          case ContentDeleted:
            break;
          case ContentType: {
            if (yxml) {
              const type = (
                /** @type {ContentType} */
                content.type
              );
              if (type instanceof YXmlElement) {
                type.nodeName = setIfUndefined(nodeNameCache, type.nodeName, () => "node-" + i2);
              }
              if (type instanceof YXmlHook) {
                type.hookName = setIfUndefined(nodeNameCache, type.hookName, () => "hook-" + i2);
              }
            }
            break;
          }
          case ContentAny: {
            const c2 = (
              /** @type {ContentAny} */
              content
            );
            c2.arr = c2.arr.map(() => i2);
            break;
          }
          case ContentBinary: {
            const c2 = (
              /** @type {ContentBinary} */
              content
            );
            c2.content = new Uint8Array([i2]);
            break;
          }
          case ContentDoc: {
            const c2 = (
              /** @type {ContentDoc} */
              content
            );
            if (subdocs) {
              c2.opts = {};
              c2.doc.guid = i2 + "";
            }
            break;
          }
          case ContentEmbed: {
            const c2 = (
              /** @type {ContentEmbed} */
              content
            );
            c2.embed = {};
            break;
          }
          case ContentFormat: {
            const c2 = (
              /** @type {ContentFormat} */
              content
            );
            if (formatting) {
              c2.key = setIfUndefined(formattingKeyCache, c2.key, () => i2 + "");
              c2.value = setIfUndefined(formattingValueCache, c2.value, () => ({ i: i2 }));
            }
            break;
          }
          case ContentJSON: {
            const c2 = (
              /** @type {ContentJSON} */
              content
            );
            c2.arr = c2.arr.map(() => i2);
            break;
          }
          case ContentString: {
            const c2 = (
              /** @type {ContentString} */
              content
            );
            c2.str = repeat(i2 % 10 + "", c2.str.length);
            break;
          }
          default:
            unexpectedCase();
        }
        if (item.parentSub) {
          item.parentSub = setIfUndefined(mapKeyCache, item.parentSub, () => i2 + "");
        }
        i2++;
        return block;
      }
      default:
        unexpectedCase();
    }
  };
};
var obfuscateUpdate = (update, opts) => convertUpdateFormat(update, createObfuscator(opts), UpdateDecoderV1, UpdateEncoderV1);
var obfuscateUpdateV2 = (update, opts) => convertUpdateFormat(update, createObfuscator(opts), UpdateDecoderV2, UpdateEncoderV2);
var convertUpdateFormatV1ToV2 = (update) => convertUpdateFormat(update, id, UpdateDecoderV1, UpdateEncoderV2);
var convertUpdateFormatV2ToV1 = (update) => convertUpdateFormat(update, id, UpdateDecoderV2, UpdateEncoderV1);
var errorComputeChanges = "You must not compute changes after the event-handler fired.";
var YEvent = class {
  /**
   * @param {T} target The changed type.
   * @param {Transaction} transaction
   */
  constructor(target, transaction) {
    this.target = target;
    this.currentTarget = target;
    this.transaction = transaction;
    this._changes = null;
    this._keys = null;
    this._delta = null;
    this._path = null;
  }
  /**
   * Computes the path from `y` to the changed type.
   *
   * @todo v14 should standardize on path: Array<{parent, index}> because that is easier to work with.
   *
   * The following property holds:
   * @example
   *   let type = y
   *   event.path.forEach(dir => {
   *     type = type.get(dir)
   *   })
   *   type === event.target // => true
   */
  get path() {
    return this._path || (this._path = getPathTo(this.currentTarget, this.target));
  }
  /**
   * Check if a struct is deleted by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  deletes(struct) {
    return isDeleted(this.transaction.deleteSet, struct.id);
  }
  /**
   * @type {Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}
   */
  get keys() {
    if (this._keys === null) {
      if (this.transaction.doc._transactionCleanups.length === 0) {
        throw create3(errorComputeChanges);
      }
      const keys4 = /* @__PURE__ */ new Map();
      const target = this.target;
      const changed = (
        /** @type Set<string|null> */
        this.transaction.changed.get(target)
      );
      changed.forEach((key) => {
        if (key !== null) {
          const item = (
            /** @type {Item} */
            target._map.get(key)
          );
          let action;
          let oldValue;
          if (this.adds(item)) {
            let prev = item.left;
            while (prev !== null && this.adds(prev)) {
              prev = prev.left;
            }
            if (this.deletes(item)) {
              if (prev !== null && this.deletes(prev)) {
                action = "delete";
                oldValue = last(prev.content.getContent());
              } else {
                return;
              }
            } else {
              if (prev !== null && this.deletes(prev)) {
                action = "update";
                oldValue = last(prev.content.getContent());
              } else {
                action = "add";
                oldValue = void 0;
              }
            }
          } else {
            if (this.deletes(item)) {
              action = "delete";
              oldValue = last(
                /** @type {Item} */
                item.content.getContent()
              );
            } else {
              return;
            }
          }
          keys4.set(key, { action, oldValue });
        }
      });
      this._keys = keys4;
    }
    return this._keys;
  }
  /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {Array<{insert?: string | Array<any> | object | AbstractType<any>, retain?: number, delete?: number, attributes?: Object<string, any>}>}
   */
  get delta() {
    return this.changes.delta;
  }
  /**
   * Check if a struct is added by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  adds(struct) {
    return struct.id.clock >= (this.transaction.beforeState.get(struct.id.client) || 0);
  }
  /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    let changes = this._changes;
    if (changes === null) {
      if (this.transaction.doc._transactionCleanups.length === 0) {
        throw create3(errorComputeChanges);
      }
      const target = this.target;
      const added = create();
      const deleted = create();
      const delta = [];
      changes = {
        added,
        deleted,
        delta,
        keys: this.keys
      };
      const changed = (
        /** @type Set<string|null> */
        this.transaction.changed.get(target)
      );
      if (changed.has(null)) {
        let lastOp = null;
        const packOp = () => {
          if (lastOp) {
            delta.push(lastOp);
          }
        };
        for (let item = target._start; item !== null; item = item.right) {
          if (item.deleted) {
            if (this.deletes(item) && !this.adds(item)) {
              if (lastOp === null || lastOp.delete === void 0) {
                packOp();
                lastOp = { delete: 0 };
              }
              lastOp.delete += item.length;
              deleted.add(item);
            }
          } else {
            if (this.adds(item)) {
              if (lastOp === null || lastOp.insert === void 0) {
                packOp();
                lastOp = { insert: [] };
              }
              lastOp.insert = lastOp.insert.concat(item.content.getContent());
              added.add(item);
            } else {
              if (lastOp === null || lastOp.retain === void 0) {
                packOp();
                lastOp = { retain: 0 };
              }
              lastOp.retain += item.length;
            }
          }
        }
        if (lastOp !== null && lastOp.retain === void 0) {
          packOp();
        }
      }
      this._changes = changes;
    }
    return (
      /** @type {any} */
      changes
    );
  }
};
var getPathTo = (parent, child) => {
  const path2 = [];
  while (child._item !== null && child !== parent) {
    if (child._item.parentSub !== null) {
      path2.unshift(child._item.parentSub);
    } else {
      let i2 = 0;
      let c2 = (
        /** @type {AbstractType<any>} */
        child._item.parent._start
      );
      while (c2 !== child._item && c2 !== null) {
        if (!c2.deleted && c2.countable) {
          i2 += c2.length;
        }
        c2 = c2.right;
      }
      path2.unshift(i2);
    }
    child = /** @type {AbstractType<any>} */
    child._item.parent;
  }
  return path2;
};
var warnPrematureAccess = () => {
  warn("Invalid access: Add Yjs type to a document before reading data.");
};
var maxSearchMarker = 80;
var globalSearchMarkerTimestamp = 0;
var ArraySearchMarker = class {
  /**
   * @param {Item} p
   * @param {number} index
   */
  constructor(p2, index) {
    p2.marker = true;
    this.p = p2;
    this.index = index;
    this.timestamp = globalSearchMarkerTimestamp++;
  }
};
var refreshMarkerTimestamp = (marker) => {
  marker.timestamp = globalSearchMarkerTimestamp++;
};
var overwriteMarker = (marker, p2, index) => {
  marker.p.marker = false;
  marker.p = p2;
  p2.marker = true;
  marker.index = index;
  marker.timestamp = globalSearchMarkerTimestamp++;
};
var markPosition = (searchMarker, p2, index) => {
  if (searchMarker.length >= maxSearchMarker) {
    const marker = searchMarker.reduce((a2, b2) => a2.timestamp < b2.timestamp ? a2 : b2);
    overwriteMarker(marker, p2, index);
    return marker;
  } else {
    const pm = new ArraySearchMarker(p2, index);
    searchMarker.push(pm);
    return pm;
  }
};
var findMarker = (yarray, index) => {
  if (yarray._start === null || index === 0 || yarray._searchMarker === null) {
    return null;
  }
  const marker = yarray._searchMarker.length === 0 ? null : yarray._searchMarker.reduce((a2, b2) => abs(index - a2.index) < abs(index - b2.index) ? a2 : b2);
  let p2 = yarray._start;
  let pindex = 0;
  if (marker !== null) {
    p2 = marker.p;
    pindex = marker.index;
    refreshMarkerTimestamp(marker);
  }
  while (p2.right !== null && pindex < index) {
    if (!p2.deleted && p2.countable) {
      if (index < pindex + p2.length) {
        break;
      }
      pindex += p2.length;
    }
    p2 = p2.right;
  }
  while (p2.left !== null && pindex > index) {
    p2 = p2.left;
    if (!p2.deleted && p2.countable) {
      pindex -= p2.length;
    }
  }
  while (p2.left !== null && p2.left.id.client === p2.id.client && p2.left.id.clock + p2.left.length === p2.id.clock) {
    p2 = p2.left;
    if (!p2.deleted && p2.countable) {
      pindex -= p2.length;
    }
  }
  if (marker !== null && abs(marker.index - pindex) < /** @type {YText|YArray<any>} */
  p2.parent.length / maxSearchMarker) {
    overwriteMarker(marker, p2, pindex);
    return marker;
  } else {
    return markPosition(yarray._searchMarker, p2, pindex);
  }
};
var updateMarkerChanges = (searchMarker, index, len3) => {
  for (let i2 = searchMarker.length - 1; i2 >= 0; i2--) {
    const m = searchMarker[i2];
    if (len3 > 0) {
      let p2 = m.p;
      p2.marker = false;
      while (p2 && (p2.deleted || !p2.countable)) {
        p2 = p2.left;
        if (p2 && !p2.deleted && p2.countable) {
          m.index -= p2.length;
        }
      }
      if (p2 === null || p2.marker === true) {
        searchMarker.splice(i2, 1);
        continue;
      }
      m.p = p2;
      p2.marker = true;
    }
    if (index < m.index || len3 > 0 && index === m.index) {
      m.index = max(index, m.index + len3);
    }
  }
};
var getTypeChildren = (t2) => {
  t2.doc ?? warnPrematureAccess();
  let s2 = t2._start;
  const arr = [];
  while (s2) {
    arr.push(s2);
    s2 = s2.right;
  }
  return arr;
};
var callTypeObservers = (type, transaction, event) => {
  const changedType = type;
  const changedParentTypes = transaction.changedParentTypes;
  while (true) {
    setIfUndefined(changedParentTypes, type, () => []).push(event);
    if (type._item === null) {
      break;
    }
    type = /** @type {AbstractType<any>} */
    type._item.parent;
  }
  callEventHandlerListeners(changedType._eH, event, transaction);
};
var AbstractType = class {
  constructor() {
    this._item = null;
    this._map = /* @__PURE__ */ new Map();
    this._start = null;
    this.doc = null;
    this._length = 0;
    this._eH = createEventHandler();
    this._dEH = createEventHandler();
    this._searchMarker = null;
  }
  /**
   * @return {AbstractType<any>|null}
   */
  get parent() {
    return this._item ? (
      /** @type {AbstractType<any>} */
      this._item.parent
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item|null} item
   */
  _integrate(y2, item) {
    this.doc = y2;
    this._item = item;
  }
  /**
   * @return {AbstractType<EventType>}
   */
  _copy() {
    throw methodUnimplemented();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {AbstractType<EventType>}
   */
  clone() {
    throw methodUnimplemented();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} _encoder
   */
  _write(_encoder) {
  }
  /**
   * The first non-deleted item
   */
  get _first() {
    let n2 = this._start;
    while (n2 !== null && n2.deleted) {
      n2 = n2.right;
    }
    return n2;
  }
  /**
   * Creates YEvent and calls all type observers.
   * Must be implemented by each type.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} _parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, _parentSubs) {
    if (!transaction.local && this._searchMarker) {
      this._searchMarker.length = 0;
    }
  }
  /**
   * Observe all events that are created on this type.
   *
   * @param {function(EventType, Transaction):void} f Observer function
   */
  observe(f2) {
    addEventHandlerListener(this._eH, f2);
  }
  /**
   * Observe all events that are created by this type and its children.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  observeDeep(f2) {
    addEventHandlerListener(this._dEH, f2);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(EventType,Transaction):void} f Observer function
   */
  unobserve(f2) {
    removeEventHandlerListener(this._eH, f2);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  unobserveDeep(f2) {
    removeEventHandlerListener(this._dEH, f2);
  }
  /**
   * @abstract
   * @return {any}
   */
  toJSON() {
  }
};
var typeListSlice = (type, start, end) => {
  type.doc ?? warnPrematureAccess();
  if (start < 0) {
    start = type._length + start;
  }
  if (end < 0) {
    end = type._length + end;
  }
  let len3 = end - start;
  const cs = [];
  let n2 = type._start;
  while (n2 !== null && len3 > 0) {
    if (n2.countable && !n2.deleted) {
      const c2 = n2.content.getContent();
      if (c2.length <= start) {
        start -= c2.length;
      } else {
        for (let i2 = start; i2 < c2.length && len3 > 0; i2++) {
          cs.push(c2[i2]);
          len3--;
        }
        start = 0;
      }
    }
    n2 = n2.right;
  }
  return cs;
};
var typeListToArray = (type) => {
  type.doc ?? warnPrematureAccess();
  const cs = [];
  let n2 = type._start;
  while (n2 !== null) {
    if (n2.countable && !n2.deleted) {
      const c2 = n2.content.getContent();
      for (let i2 = 0; i2 < c2.length; i2++) {
        cs.push(c2[i2]);
      }
    }
    n2 = n2.right;
  }
  return cs;
};
var typeListToArraySnapshot = (type, snapshot2) => {
  const cs = [];
  let n2 = type._start;
  while (n2 !== null) {
    if (n2.countable && isVisible(n2, snapshot2)) {
      const c2 = n2.content.getContent();
      for (let i2 = 0; i2 < c2.length; i2++) {
        cs.push(c2[i2]);
      }
    }
    n2 = n2.right;
  }
  return cs;
};
var typeListForEach = (type, f2) => {
  let index = 0;
  let n2 = type._start;
  type.doc ?? warnPrematureAccess();
  while (n2 !== null) {
    if (n2.countable && !n2.deleted) {
      const c2 = n2.content.getContent();
      for (let i2 = 0; i2 < c2.length; i2++) {
        f2(c2[i2], index++, type);
      }
    }
    n2 = n2.right;
  }
};
var typeListMap = (type, f2) => {
  const result = [];
  typeListForEach(type, (c2, i2) => {
    result.push(f2(c2, i2, type));
  });
  return result;
};
var typeListCreateIterator = (type) => {
  let n2 = type._start;
  let currentContent = null;
  let currentContentIndex = 0;
  return {
    [Symbol.iterator]() {
      return this;
    },
    next: () => {
      if (currentContent === null) {
        while (n2 !== null && n2.deleted) {
          n2 = n2.right;
        }
        if (n2 === null) {
          return {
            done: true,
            value: void 0
          };
        }
        currentContent = n2.content.getContent();
        currentContentIndex = 0;
        n2 = n2.right;
      }
      const value = currentContent[currentContentIndex++];
      if (currentContent.length <= currentContentIndex) {
        currentContent = null;
      }
      return {
        done: false,
        value
      };
    }
  };
};
var typeListGet = (type, index) => {
  type.doc ?? warnPrematureAccess();
  const marker = findMarker(type, index);
  let n2 = type._start;
  if (marker !== null) {
    n2 = marker.p;
    index -= marker.index;
  }
  for (; n2 !== null; n2 = n2.right) {
    if (!n2.deleted && n2.countable) {
      if (index < n2.length) {
        return n2.content.getContent()[index];
      }
      index -= n2.length;
    }
  }
};
var typeListInsertGenericsAfter = (transaction, parent, referenceItem, content) => {
  let left = referenceItem;
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  const store = doc2.store;
  const right = referenceItem === null ? parent._start : referenceItem.right;
  let jsonContent = [];
  const packJsonContent = () => {
    if (jsonContent.length > 0) {
      left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentAny(jsonContent));
      left.integrate(transaction, 0);
      jsonContent = [];
    }
  };
  content.forEach((c2) => {
    if (c2 === null) {
      jsonContent.push(c2);
    } else {
      switch (c2.constructor) {
        case Number:
        case Object:
        case Boolean:
        case Array:
        case String:
          jsonContent.push(c2);
          break;
        default:
          packJsonContent();
          switch (c2.constructor) {
            case Uint8Array:
            case ArrayBuffer:
              left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentBinary(new Uint8Array(
                /** @type {Uint8Array} */
                c2
              )));
              left.integrate(transaction, 0);
              break;
            case Doc:
              left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentDoc(
                /** @type {Doc} */
                c2
              ));
              left.integrate(transaction, 0);
              break;
            default:
              if (c2 instanceof AbstractType) {
                left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentType(c2));
                left.integrate(transaction, 0);
              } else {
                throw new Error("Unexpected content type in insert operation");
              }
          }
      }
    }
  });
  packJsonContent();
};
var lengthExceeded = () => create3("Length exceeded!");
var typeListInsertGenerics = (transaction, parent, index, content) => {
  if (index > parent._length) {
    throw lengthExceeded();
  }
  if (index === 0) {
    if (parent._searchMarker) {
      updateMarkerChanges(parent._searchMarker, index, content.length);
    }
    return typeListInsertGenericsAfter(transaction, parent, null, content);
  }
  const startIndex = index;
  const marker = findMarker(parent, index);
  let n2 = parent._start;
  if (marker !== null) {
    n2 = marker.p;
    index -= marker.index;
    if (index === 0) {
      n2 = n2.prev;
      index += n2 && n2.countable && !n2.deleted ? n2.length : 0;
    }
  }
  for (; n2 !== null; n2 = n2.right) {
    if (!n2.deleted && n2.countable) {
      if (index <= n2.length) {
        if (index < n2.length) {
          getItemCleanStart(transaction, createID(n2.id.client, n2.id.clock + index));
        }
        break;
      }
      index -= n2.length;
    }
  }
  if (parent._searchMarker) {
    updateMarkerChanges(parent._searchMarker, startIndex, content.length);
  }
  return typeListInsertGenericsAfter(transaction, parent, n2, content);
};
var typeListPushGenerics = (transaction, parent, content) => {
  const marker = (parent._searchMarker || []).reduce((maxMarker, currMarker) => currMarker.index > maxMarker.index ? currMarker : maxMarker, { index: 0, p: parent._start });
  let n2 = marker.p;
  if (n2) {
    while (n2.right) {
      n2 = n2.right;
    }
  }
  return typeListInsertGenericsAfter(transaction, parent, n2, content);
};
var typeListDelete = (transaction, parent, index, length4) => {
  if (length4 === 0) {
    return;
  }
  const startIndex = index;
  const startLength = length4;
  const marker = findMarker(parent, index);
  let n2 = parent._start;
  if (marker !== null) {
    n2 = marker.p;
    index -= marker.index;
  }
  for (; n2 !== null && index > 0; n2 = n2.right) {
    if (!n2.deleted && n2.countable) {
      if (index < n2.length) {
        getItemCleanStart(transaction, createID(n2.id.client, n2.id.clock + index));
      }
      index -= n2.length;
    }
  }
  while (length4 > 0 && n2 !== null) {
    if (!n2.deleted) {
      if (length4 < n2.length) {
        getItemCleanStart(transaction, createID(n2.id.client, n2.id.clock + length4));
      }
      n2.delete(transaction);
      length4 -= n2.length;
    }
    n2 = n2.right;
  }
  if (length4 > 0) {
    throw lengthExceeded();
  }
  if (parent._searchMarker) {
    updateMarkerChanges(
      parent._searchMarker,
      startIndex,
      -startLength + length4
      /* in case we remove the above exception */
    );
  }
};
var typeMapDelete = (transaction, parent, key) => {
  const c2 = parent._map.get(key);
  if (c2 !== void 0) {
    c2.delete(transaction);
  }
};
var typeMapSet = (transaction, parent, key, value) => {
  const left = parent._map.get(key) || null;
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  let content;
  if (value == null) {
    content = new ContentAny([value]);
  } else {
    switch (value.constructor) {
      case Number:
      case Object:
      case Boolean:
      case Array:
      case String:
      case Date:
      case BigInt:
        content = new ContentAny([value]);
        break;
      case Uint8Array:
        content = new ContentBinary(
          /** @type {Uint8Array} */
          value
        );
        break;
      case Doc:
        content = new ContentDoc(
          /** @type {Doc} */
          value
        );
        break;
      default:
        if (value instanceof AbstractType) {
          content = new ContentType(value);
        } else {
          throw new Error("Unexpected content type");
        }
    }
  }
  new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, null, null, parent, key, content).integrate(transaction, 0);
};
var typeMapGet = (parent, key) => {
  parent.doc ?? warnPrematureAccess();
  const val = parent._map.get(key);
  return val !== void 0 && !val.deleted ? val.content.getContent()[val.length - 1] : void 0;
};
var typeMapGetAll = (parent) => {
  const res = {};
  parent.doc ?? warnPrematureAccess();
  parent._map.forEach((value, key) => {
    if (!value.deleted) {
      res[key] = value.content.getContent()[value.length - 1];
    }
  });
  return res;
};
var typeMapHas = (parent, key) => {
  parent.doc ?? warnPrematureAccess();
  const val = parent._map.get(key);
  return val !== void 0 && !val.deleted;
};
var typeMapGetSnapshot = (parent, key, snapshot2) => {
  let v2 = parent._map.get(key) || null;
  while (v2 !== null && (!snapshot2.sv.has(v2.id.client) || v2.id.clock >= (snapshot2.sv.get(v2.id.client) || 0))) {
    v2 = v2.left;
  }
  return v2 !== null && isVisible(v2, snapshot2) ? v2.content.getContent()[v2.length - 1] : void 0;
};
var typeMapGetAllSnapshot = (parent, snapshot2) => {
  const res = {};
  parent._map.forEach((value, key) => {
    let v2 = value;
    while (v2 !== null && (!snapshot2.sv.has(v2.id.client) || v2.id.clock >= (snapshot2.sv.get(v2.id.client) || 0))) {
      v2 = v2.left;
    }
    if (v2 !== null && isVisible(v2, snapshot2)) {
      res[key] = v2.content.getContent()[v2.length - 1];
    }
  });
  return res;
};
var createMapIterator = (type) => {
  type.doc ?? warnPrematureAccess();
  return iteratorFilter(
    type._map.entries(),
    /** @param {any} entry */
    (entry) => !entry[1].deleted
  );
};
var YArrayEvent = class extends YEvent {
};
var YArray = class _YArray extends AbstractType {
  constructor() {
    super();
    this._prelimContent = [];
    this._searchMarker = [];
  }
  /**
   * Construct a new YArray containing the specified items.
   * @template {Object<string,any>|Array<any>|number|null|string|Uint8Array} T
   * @param {Array<T>} items
   * @return {YArray<T>}
   */
  static from(items) {
    const a2 = new _YArray();
    a2.push(items);
    return a2;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y2, item) {
    super._integrate(y2, item);
    this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    );
    this._prelimContent = null;
  }
  /**
   * @return {YArray<T>}
   */
  _copy() {
    return new _YArray();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YArray<T>}
   */
  clone() {
    const arr = new _YArray();
    arr.insert(0, this.toArray().map(
      (el) => el instanceof AbstractType ? (
        /** @type {typeof el} */
        el.clone()
      ) : el
    ));
    return arr;
  }
  get length() {
    this.doc ?? warnPrematureAccess();
    return this._length;
  }
  /**
   * Creates YArrayEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    super._callObserver(transaction, parentSubs);
    callTypeObservers(this, transaction, new YArrayEvent(this, transaction));
  }
  /**
   * Inserts new content at an index.
   *
   * Important: This function expects an array of content. Not just a content
   * object. The reason for this "weirdness" is that inserting several elements
   * is very efficient when it is done as a single operation.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  yarray.insert(0, ['a'])
   *  // Insert numbers 1, 2 at position 1
   *  yarray.insert(1, [1, 2])
   *
   * @param {number} index The index to insert content at.
   * @param {Array<T>} content The array of content
   */
  insert(index, content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListInsertGenerics(
          transaction,
          this,
          index,
          /** @type {any} */
          content
        );
      });
    } else {
      this._prelimContent.splice(index, 0, ...content);
    }
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<T>} content Array of content to append.
   *
   * @todo Use the following implementation in all types.
   */
  push(content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListPushGenerics(
          transaction,
          this,
          /** @type {any} */
          content
        );
      });
    } else {
      this._prelimContent.push(...content);
    }
  }
  /**
   * Prepends content to this YArray.
   *
   * @param {Array<T>} content Array of content to prepend.
   */
  unshift(content) {
    this.insert(0, content);
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} length The number of elements to remove. Defaults to 1.
   */
  delete(index, length4 = 1) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListDelete(transaction, this, index, length4);
      });
    } else {
      this._prelimContent.splice(index, length4);
    }
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {T}
   */
  get(index) {
    return typeListGet(this, index);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<T>}
   */
  toArray() {
    return typeListToArray(this);
  }
  /**
   * Returns a portion of this YArray into a JavaScript Array selected
   * from start to end (end not included).
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<T>}
   */
  slice(start = 0, end = this.length) {
    return typeListSlice(this, start, end);
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Array<any>}
   */
  toJSON() {
    return this.map((c2) => c2 instanceof AbstractType ? c2.toJSON() : c2);
  }
  /**
   * Returns an Array with the result of calling a provided function on every
   * element of this YArray.
   *
   * @template M
   * @param {function(T,number,YArray<T>):M} f Function that produces an element of the new Array
   * @return {Array<M>} A new array with each element being the result of the
   *                 callback function
   */
  map(f2) {
    return typeListMap(
      this,
      /** @type {any} */
      f2
    );
  }
  /**
   * Executes a provided function once on every element of this YArray.
   *
   * @param {function(T,number,YArray<T>):void} f A function to execute on every element of this YArray.
   */
  forEach(f2) {
    typeListForEach(this, f2);
  }
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return typeListCreateIterator(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder) {
    encoder.writeTypeRef(YArrayRefID);
  }
};
var readYArray = (_decoder) => new YArray();
var YMapEvent = class extends YEvent {
  /**
   * @param {YMap<T>} ymap The YArray that changed.
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed.
   */
  constructor(ymap, transaction, subs) {
    super(ymap, transaction);
    this.keysChanged = subs;
  }
};
var YMap = class _YMap extends AbstractType {
  /**
   *
   * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap
   */
  constructor(entries) {
    super();
    this._prelimContent = null;
    if (entries === void 0) {
      this._prelimContent = /* @__PURE__ */ new Map();
    } else {
      this._prelimContent = new Map(entries);
    }
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y2, item) {
    super._integrate(y2, item);
    this._prelimContent.forEach((value, key) => {
      this.set(key, value);
    });
    this._prelimContent = null;
  }
  /**
   * @return {YMap<MapType>}
   */
  _copy() {
    return new _YMap();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YMap<MapType>}
   */
  clone() {
    const map3 = new _YMap();
    this.forEach((value, key) => {
      map3.set(key, value instanceof AbstractType ? (
        /** @type {typeof value} */
        value.clone()
      ) : value);
    });
    return map3;
  }
  /**
   * Creates YMapEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    callTypeObservers(this, transaction, new YMapEvent(this, transaction, parentSubs));
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Object<string,any>}
   */
  toJSON() {
    this.doc ?? warnPrematureAccess();
    const map3 = {};
    this._map.forEach((item, key) => {
      if (!item.deleted) {
        const v2 = item.content.getContent()[item.length - 1];
        map3[key] = v2 instanceof AbstractType ? v2.toJSON() : v2;
      }
    });
    return map3;
  }
  /**
   * Returns the size of the YMap (count of key/value pairs)
   *
   * @return {number}
   */
  get size() {
    return [...createMapIterator(this)].length;
  }
  /**
   * Returns the keys for each element in the YMap Type.
   *
   * @return {IterableIterator<string>}
   */
  keys() {
    return iteratorMap(
      createMapIterator(this),
      /** @param {any} v */
      (v2) => v2[0]
    );
  }
  /**
   * Returns the values for each element in the YMap Type.
   *
   * @return {IterableIterator<MapType>}
   */
  values() {
    return iteratorMap(
      createMapIterator(this),
      /** @param {any} v */
      (v2) => v2[1].content.getContent()[v2[1].length - 1]
    );
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */
  entries() {
    return iteratorMap(
      createMapIterator(this),
      /** @param {any} v */
      (v2) => (
        /** @type {any} */
        [v2[0], v2[1].content.getContent()[v2[1].length - 1]]
      )
    );
  }
  /**
   * Executes a provided function on once on every key-value pair.
   *
   * @param {function(MapType,string,YMap<MapType>):void} f A function to execute on every element of this YArray.
   */
  forEach(f2) {
    this.doc ?? warnPrematureAccess();
    this._map.forEach((item, key) => {
      if (!item.deleted) {
        f2(item.content.getContent()[item.length - 1], key, this);
      }
    });
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Remove a specified element from this YMap.
   *
   * @param {string} key The key of the element to remove.
   */
  delete(key) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapDelete(transaction, this, key);
      });
    } else {
      this._prelimContent.delete(key);
    }
  }
  /**
   * Adds or updates an element with a specified key and value.
   * @template {MapType} VAL
   *
   * @param {string} key The key of the element to add to this YMap
   * @param {VAL} value The value of the element to add
   * @return {VAL}
   */
  set(key, value) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapSet(
          transaction,
          this,
          key,
          /** @type {any} */
          value
        );
      });
    } else {
      this._prelimContent.set(key, value);
    }
    return value;
  }
  /**
   * Returns a specified element from this YMap.
   *
   * @param {string} key
   * @return {MapType|undefined}
   */
  get(key) {
    return (
      /** @type {any} */
      typeMapGet(this, key)
    );
  }
  /**
   * Returns a boolean indicating whether the specified key exists or not.
   *
   * @param {string} key The key to test.
   * @return {boolean}
   */
  has(key) {
    return typeMapHas(this, key);
  }
  /**
   * Removes all elements from this YMap.
   */
  clear() {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        this.forEach(function(_value, key, map3) {
          typeMapDelete(transaction, map3, key);
        });
      });
    } else {
      this._prelimContent.clear();
    }
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder) {
    encoder.writeTypeRef(YMapRefID);
  }
};
var readYMap = (_decoder) => new YMap();
var equalAttrs = (a2, b2) => a2 === b2 || typeof a2 === "object" && typeof b2 === "object" && a2 && b2 && equalFlat(a2, b2);
var ItemTextListPosition = class {
  /**
   * @param {Item|null} left
   * @param {Item|null} right
   * @param {number} index
   * @param {Map<string,any>} currentAttributes
   */
  constructor(left, right, index, currentAttributes) {
    this.left = left;
    this.right = right;
    this.index = index;
    this.currentAttributes = currentAttributes;
  }
  /**
   * Only call this if you know that this.right is defined
   */
  forward() {
    if (this.right === null) {
      unexpectedCase();
    }
    switch (this.right.content.constructor) {
      case ContentFormat:
        if (!this.right.deleted) {
          updateCurrentAttributes(
            this.currentAttributes,
            /** @type {ContentFormat} */
            this.right.content
          );
        }
        break;
      default:
        if (!this.right.deleted) {
          this.index += this.right.length;
        }
        break;
    }
    this.left = this.right;
    this.right = this.right.right;
  }
};
var findNextPosition = (transaction, pos, count) => {
  while (pos.right !== null && count > 0) {
    switch (pos.right.content.constructor) {
      case ContentFormat:
        if (!pos.right.deleted) {
          updateCurrentAttributes(
            pos.currentAttributes,
            /** @type {ContentFormat} */
            pos.right.content
          );
        }
        break;
      default:
        if (!pos.right.deleted) {
          if (count < pos.right.length) {
            getItemCleanStart(transaction, createID(pos.right.id.client, pos.right.id.clock + count));
          }
          pos.index += pos.right.length;
          count -= pos.right.length;
        }
        break;
    }
    pos.left = pos.right;
    pos.right = pos.right.right;
  }
  return pos;
};
var findPosition = (transaction, parent, index, useSearchMarker) => {
  const currentAttributes = /* @__PURE__ */ new Map();
  const marker = useSearchMarker ? findMarker(parent, index) : null;
  if (marker) {
    const pos = new ItemTextListPosition(marker.p.left, marker.p, marker.index, currentAttributes);
    return findNextPosition(transaction, pos, index - marker.index);
  } else {
    const pos = new ItemTextListPosition(null, parent._start, 0, currentAttributes);
    return findNextPosition(transaction, pos, index);
  }
};
var insertNegatedAttributes = (transaction, parent, currPos, negatedAttributes) => {
  while (currPos.right !== null && (currPos.right.deleted === true || currPos.right.content.constructor === ContentFormat && equalAttrs(
    negatedAttributes.get(
      /** @type {ContentFormat} */
      currPos.right.content.key
    ),
    /** @type {ContentFormat} */
    currPos.right.content.value
  ))) {
    if (!currPos.right.deleted) {
      negatedAttributes.delete(
        /** @type {ContentFormat} */
        currPos.right.content.key
      );
    }
    currPos.forward();
  }
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  negatedAttributes.forEach((val, key) => {
    const left = currPos.left;
    const right = currPos.right;
    const nextFormat = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));
    nextFormat.integrate(transaction, 0);
    currPos.right = nextFormat;
    currPos.forward();
  });
};
var updateCurrentAttributes = (currentAttributes, format) => {
  const { key, value } = format;
  if (value === null) {
    currentAttributes.delete(key);
  } else {
    currentAttributes.set(key, value);
  }
};
var minimizeAttributeChanges = (currPos, attributes) => {
  while (true) {
    if (currPos.right === null) {
      break;
    } else if (currPos.right.deleted || currPos.right.content.constructor === ContentFormat && equalAttrs(
      attributes[
        /** @type {ContentFormat} */
        currPos.right.content.key
      ] ?? null,
      /** @type {ContentFormat} */
      currPos.right.content.value
    )) ;
    else {
      break;
    }
    currPos.forward();
  }
};
var insertAttributes = (transaction, parent, currPos, attributes) => {
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  const negatedAttributes = /* @__PURE__ */ new Map();
  for (const key in attributes) {
    const val = attributes[key];
    const currentVal = currPos.currentAttributes.get(key) ?? null;
    if (!equalAttrs(currentVal, val)) {
      negatedAttributes.set(key, currentVal);
      const { left, right } = currPos;
      currPos.right = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));
      currPos.right.integrate(transaction, 0);
      currPos.forward();
    }
  }
  return negatedAttributes;
};
var insertText = (transaction, parent, currPos, text2, attributes) => {
  currPos.currentAttributes.forEach((_val, key) => {
    if (attributes[key] === void 0) {
      attributes[key] = null;
    }
  });
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  minimizeAttributeChanges(currPos, attributes);
  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);
  const content = text2.constructor === String ? new ContentString(
    /** @type {string} */
    text2
  ) : text2 instanceof AbstractType ? new ContentType(text2) : new ContentEmbed(text2);
  let { left, right, index } = currPos;
  if (parent._searchMarker) {
    updateMarkerChanges(parent._searchMarker, currPos.index, content.getLength());
  }
  right = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, content);
  right.integrate(transaction, 0);
  currPos.right = right;
  currPos.index = index;
  currPos.forward();
  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);
};
var formatText = (transaction, parent, currPos, length4, attributes) => {
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  minimizeAttributeChanges(currPos, attributes);
  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);
  iterationLoop: while (currPos.right !== null && (length4 > 0 || negatedAttributes.size > 0 && (currPos.right.deleted || currPos.right.content.constructor === ContentFormat))) {
    if (!currPos.right.deleted) {
      switch (currPos.right.content.constructor) {
        case ContentFormat: {
          const { key, value } = (
            /** @type {ContentFormat} */
            currPos.right.content
          );
          const attr = attributes[key];
          if (attr !== void 0) {
            if (equalAttrs(attr, value)) {
              negatedAttributes.delete(key);
            } else {
              if (length4 === 0) {
                break iterationLoop;
              }
              negatedAttributes.set(key, value);
            }
            currPos.right.delete(transaction);
          } else {
            currPos.currentAttributes.set(key, value);
          }
          break;
        }
        default:
          if (length4 < currPos.right.length) {
            getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length4));
          }
          length4 -= currPos.right.length;
          break;
      }
    }
    currPos.forward();
  }
  if (length4 > 0) {
    let newlines = "";
    for (; length4 > 0; length4--) {
      newlines += "\n";
    }
    currPos.right = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), currPos.left, currPos.left && currPos.left.lastId, currPos.right, currPos.right && currPos.right.id, parent, null, new ContentString(newlines));
    currPos.right.integrate(transaction, 0);
    currPos.forward();
  }
  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);
};
var cleanupFormattingGap = (transaction, start, curr, startAttributes, currAttributes) => {
  let end = start;
  const endFormats = create2();
  while (end && (!end.countable || end.deleted)) {
    if (!end.deleted && end.content.constructor === ContentFormat) {
      const cf = (
        /** @type {ContentFormat} */
        end.content
      );
      endFormats.set(cf.key, cf);
    }
    end = end.right;
  }
  let cleanups = 0;
  let reachedCurr = false;
  while (start !== end) {
    if (curr === start) {
      reachedCurr = true;
    }
    if (!start.deleted) {
      const content = start.content;
      switch (content.constructor) {
        case ContentFormat: {
          const { key, value } = (
            /** @type {ContentFormat} */
            content
          );
          const startAttrValue = startAttributes.get(key) ?? null;
          if (endFormats.get(key) !== content || startAttrValue === value) {
            start.delete(transaction);
            cleanups++;
            if (!reachedCurr && (currAttributes.get(key) ?? null) === value && startAttrValue !== value) {
              if (startAttrValue === null) {
                currAttributes.delete(key);
              } else {
                currAttributes.set(key, startAttrValue);
              }
            }
          }
          if (!reachedCurr && !start.deleted) {
            updateCurrentAttributes(
              currAttributes,
              /** @type {ContentFormat} */
              content
            );
          }
          break;
        }
      }
    }
    start = /** @type {Item} */
    start.right;
  }
  return cleanups;
};
var cleanupContextlessFormattingGap = (transaction, item) => {
  while (item && item.right && (item.right.deleted || !item.right.countable)) {
    item = item.right;
  }
  const attrs = /* @__PURE__ */ new Set();
  while (item && (item.deleted || !item.countable)) {
    if (!item.deleted && item.content.constructor === ContentFormat) {
      const key = (
        /** @type {ContentFormat} */
        item.content.key
      );
      if (attrs.has(key)) {
        item.delete(transaction);
      } else {
        attrs.add(key);
      }
    }
    item = item.left;
  }
};
var cleanupYTextFormatting = (type) => {
  let res = 0;
  transact(
    /** @type {Doc} */
    type.doc,
    (transaction) => {
      let start = (
        /** @type {Item} */
        type._start
      );
      let end = type._start;
      let startAttributes = create2();
      const currentAttributes = copy(startAttributes);
      while (end) {
        if (end.deleted === false) {
          switch (end.content.constructor) {
            case ContentFormat:
              updateCurrentAttributes(
                currentAttributes,
                /** @type {ContentFormat} */
                end.content
              );
              break;
            default:
              res += cleanupFormattingGap(transaction, start, end, startAttributes, currentAttributes);
              startAttributes = copy(currentAttributes);
              start = end;
              break;
          }
        }
        end = end.right;
      }
    }
  );
  return res;
};
var cleanupYTextAfterTransaction = (transaction) => {
  const needFullCleanup = /* @__PURE__ */ new Set();
  const doc2 = transaction.doc;
  for (const [client, afterClock] of transaction.afterState.entries()) {
    const clock = transaction.beforeState.get(client) || 0;
    if (afterClock === clock) {
      continue;
    }
    iterateStructs(
      transaction,
      /** @type {Array<Item|GC>} */
      doc2.store.clients.get(client),
      clock,
      afterClock,
      (item) => {
        if (!item.deleted && /** @type {Item} */
        item.content.constructor === ContentFormat && item.constructor !== GC) {
          needFullCleanup.add(
            /** @type {any} */
            item.parent
          );
        }
      }
    );
  }
  transact(doc2, (t2) => {
    iterateDeletedStructs(transaction, transaction.deleteSet, (item) => {
      if (item instanceof GC || !/** @type {YText} */
      item.parent._hasFormatting || needFullCleanup.has(
        /** @type {YText} */
        item.parent
      )) {
        return;
      }
      const parent = (
        /** @type {YText} */
        item.parent
      );
      if (item.content.constructor === ContentFormat) {
        needFullCleanup.add(parent);
      } else {
        cleanupContextlessFormattingGap(t2, item);
      }
    });
    for (const yText of needFullCleanup) {
      cleanupYTextFormatting(yText);
    }
  });
};
var deleteText = (transaction, currPos, length4) => {
  const startLength = length4;
  const startAttrs = copy(currPos.currentAttributes);
  const start = currPos.right;
  while (length4 > 0 && currPos.right !== null) {
    if (currPos.right.deleted === false) {
      switch (currPos.right.content.constructor) {
        case ContentType:
        case ContentEmbed:
        case ContentString:
          if (length4 < currPos.right.length) {
            getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length4));
          }
          length4 -= currPos.right.length;
          currPos.right.delete(transaction);
          break;
      }
    }
    currPos.forward();
  }
  if (start) {
    cleanupFormattingGap(transaction, start, currPos.right, startAttrs, currPos.currentAttributes);
  }
  const parent = (
    /** @type {AbstractType<any>} */
    /** @type {Item} */
    (currPos.left || currPos.right).parent
  );
  if (parent._searchMarker) {
    updateMarkerChanges(parent._searchMarker, currPos.index, -startLength + length4);
  }
  return currPos;
};
var YTextEvent = class extends YEvent {
  /**
   * @param {YText} ytext
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed
   */
  constructor(ytext, transaction, subs) {
    super(ytext, transaction);
    this.childListChanged = false;
    this.keysChanged = /* @__PURE__ */ new Set();
    subs.forEach((sub2) => {
      if (sub2 === null) {
        this.childListChanged = true;
      } else {
        this.keysChanged.add(sub2);
      }
    });
  }
  /**
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    if (this._changes === null) {
      const changes = {
        keys: this.keys,
        delta: this.delta,
        added: /* @__PURE__ */ new Set(),
        deleted: /* @__PURE__ */ new Set()
      };
      this._changes = changes;
    }
    return (
      /** @type {any} */
      this._changes
    );
  }
  /**
   * Compute the changes in the delta format.
   * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.
   *
   * @type {Array<{insert?:string|object|AbstractType<any>, delete?:number, retain?:number, attributes?: Object<string,any>}>}
   *
   * @public
   */
  get delta() {
    if (this._delta === null) {
      const y2 = (
        /** @type {Doc} */
        this.target.doc
      );
      const delta = [];
      transact(y2, (transaction) => {
        const currentAttributes = /* @__PURE__ */ new Map();
        const oldAttributes = /* @__PURE__ */ new Map();
        let item = this.target._start;
        let action = null;
        const attributes = {};
        let insert = "";
        let retain = 0;
        let deleteLen = 0;
        const addOp = () => {
          if (action !== null) {
            let op = null;
            switch (action) {
              case "delete":
                if (deleteLen > 0) {
                  op = { delete: deleteLen };
                }
                deleteLen = 0;
                break;
              case "insert":
                if (typeof insert === "object" || insert.length > 0) {
                  op = { insert };
                  if (currentAttributes.size > 0) {
                    op.attributes = {};
                    currentAttributes.forEach((value, key) => {
                      if (value !== null) {
                        op.attributes[key] = value;
                      }
                    });
                  }
                }
                insert = "";
                break;
              case "retain":
                if (retain > 0) {
                  op = { retain };
                  if (!isEmpty(attributes)) {
                    op.attributes = assign({}, attributes);
                  }
                }
                retain = 0;
                break;
            }
            if (op) delta.push(op);
            action = null;
          }
        };
        while (item !== null) {
          switch (item.content.constructor) {
            case ContentType:
            case ContentEmbed:
              if (this.adds(item)) {
                if (!this.deletes(item)) {
                  addOp();
                  action = "insert";
                  insert = item.content.getContent()[0];
                  addOp();
                }
              } else if (this.deletes(item)) {
                if (action !== "delete") {
                  addOp();
                  action = "delete";
                }
                deleteLen += 1;
              } else if (!item.deleted) {
                if (action !== "retain") {
                  addOp();
                  action = "retain";
                }
                retain += 1;
              }
              break;
            case ContentString:
              if (this.adds(item)) {
                if (!this.deletes(item)) {
                  if (action !== "insert") {
                    addOp();
                    action = "insert";
                  }
                  insert += /** @type {ContentString} */
                  item.content.str;
                }
              } else if (this.deletes(item)) {
                if (action !== "delete") {
                  addOp();
                  action = "delete";
                }
                deleteLen += item.length;
              } else if (!item.deleted) {
                if (action !== "retain") {
                  addOp();
                  action = "retain";
                }
                retain += item.length;
              }
              break;
            case ContentFormat: {
              const { key, value } = (
                /** @type {ContentFormat} */
                item.content
              );
              if (this.adds(item)) {
                if (!this.deletes(item)) {
                  const curVal = currentAttributes.get(key) ?? null;
                  if (!equalAttrs(curVal, value)) {
                    if (action === "retain") {
                      addOp();
                    }
                    if (equalAttrs(value, oldAttributes.get(key) ?? null)) {
                      delete attributes[key];
                    } else {
                      attributes[key] = value;
                    }
                  } else if (value !== null) {
                    item.delete(transaction);
                  }
                }
              } else if (this.deletes(item)) {
                oldAttributes.set(key, value);
                const curVal = currentAttributes.get(key) ?? null;
                if (!equalAttrs(curVal, value)) {
                  if (action === "retain") {
                    addOp();
                  }
                  attributes[key] = curVal;
                }
              } else if (!item.deleted) {
                oldAttributes.set(key, value);
                const attr = attributes[key];
                if (attr !== void 0) {
                  if (!equalAttrs(attr, value)) {
                    if (action === "retain") {
                      addOp();
                    }
                    if (value === null) {
                      delete attributes[key];
                    } else {
                      attributes[key] = value;
                    }
                  } else if (attr !== null) {
                    item.delete(transaction);
                  }
                }
              }
              if (!item.deleted) {
                if (action === "insert") {
                  addOp();
                }
                updateCurrentAttributes(
                  currentAttributes,
                  /** @type {ContentFormat} */
                  item.content
                );
              }
              break;
            }
          }
          item = item.right;
        }
        addOp();
        while (delta.length > 0) {
          const lastOp = delta[delta.length - 1];
          if (lastOp.retain !== void 0 && lastOp.attributes === void 0) {
            delta.pop();
          } else {
            break;
          }
        }
      });
      this._delta = delta;
    }
    return (
      /** @type {any} */
      this._delta
    );
  }
};
var YText = class _YText extends AbstractType {
  /**
   * @param {String} [string] The initial value of the YText.
   */
  constructor(string) {
    super();
    this._pending = string !== void 0 ? [() => this.insert(0, string)] : [];
    this._searchMarker = [];
    this._hasFormatting = false;
  }
  /**
   * Number of characters of this text type.
   *
   * @type {number}
   */
  get length() {
    this.doc ?? warnPrematureAccess();
    return this._length;
  }
  /**
   * @param {Doc} y
   * @param {Item} item
   */
  _integrate(y2, item) {
    super._integrate(y2, item);
    try {
      this._pending.forEach((f2) => f2());
    } catch (e2) {
      console.error(e2);
    }
    this._pending = null;
  }
  _copy() {
    return new _YText();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YText}
   */
  clone() {
    const text2 = new _YText();
    text2.applyDelta(this.toDelta());
    return text2;
  }
  /**
   * Creates YTextEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    super._callObserver(transaction, parentSubs);
    const event = new YTextEvent(this, transaction, parentSubs);
    callTypeObservers(this, transaction, event);
    if (!transaction.local && this._hasFormatting) {
      transaction._needFormattingCleanup = true;
    }
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @public
   */
  toString() {
    this.doc ?? warnPrematureAccess();
    let str = "";
    let n2 = this._start;
    while (n2 !== null) {
      if (!n2.deleted && n2.countable && n2.content.constructor === ContentString) {
        str += /** @type {ContentString} */
        n2.content.str;
      }
      n2 = n2.right;
    }
    return str;
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @return {string}
   * @public
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Apply a {@link Delta} on this shared YText type.
   *
   * @param {Array<any>} delta The changes to apply on this element.
   * @param {object}  opts
   * @param {boolean} [opts.sanitize] Sanitize input delta. Removes ending newlines if set to true.
   *
   *
   * @public
   */
  applyDelta(delta, { sanitize = true } = {}) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        const currPos = new ItemTextListPosition(null, this._start, 0, /* @__PURE__ */ new Map());
        for (let i2 = 0; i2 < delta.length; i2++) {
          const op = delta[i2];
          if (op.insert !== void 0) {
            const ins = !sanitize && typeof op.insert === "string" && i2 === delta.length - 1 && currPos.right === null && op.insert.slice(-1) === "\n" ? op.insert.slice(0, -1) : op.insert;
            if (typeof ins !== "string" || ins.length > 0) {
              insertText(transaction, this, currPos, ins, op.attributes || {});
            }
          } else if (op.retain !== void 0) {
            formatText(transaction, this, currPos, op.retain, op.attributes || {});
          } else if (op.delete !== void 0) {
            deleteText(transaction, currPos, op.delete);
          }
        }
      });
    } else {
      this._pending.push(() => this.applyDelta(delta));
    }
  }
  /**
   * Returns the Delta representation of this YText type.
   *
   * @param {Snapshot} [snapshot]
   * @param {Snapshot} [prevSnapshot]
   * @param {function('removed' | 'added', ID):any} [computeYChange]
   * @return {any} The Delta representation of this type.
   *
   * @public
   */
  toDelta(snapshot2, prevSnapshot, computeYChange) {
    this.doc ?? warnPrematureAccess();
    const ops = [];
    const currentAttributes = /* @__PURE__ */ new Map();
    const doc2 = (
      /** @type {Doc} */
      this.doc
    );
    let str = "";
    let n2 = this._start;
    function packStr() {
      if (str.length > 0) {
        const attributes = {};
        let addAttributes = false;
        currentAttributes.forEach((value, key) => {
          addAttributes = true;
          attributes[key] = value;
        });
        const op = { insert: str };
        if (addAttributes) {
          op.attributes = attributes;
        }
        ops.push(op);
        str = "";
      }
    }
    const computeDelta = () => {
      while (n2 !== null) {
        if (isVisible(n2, snapshot2) || prevSnapshot !== void 0 && isVisible(n2, prevSnapshot)) {
          switch (n2.content.constructor) {
            case ContentString: {
              const cur = currentAttributes.get("ychange");
              if (snapshot2 !== void 0 && !isVisible(n2, snapshot2)) {
                if (cur === void 0 || cur.user !== n2.id.client || cur.type !== "removed") {
                  packStr();
                  currentAttributes.set("ychange", computeYChange ? computeYChange("removed", n2.id) : { type: "removed" });
                }
              } else if (prevSnapshot !== void 0 && !isVisible(n2, prevSnapshot)) {
                if (cur === void 0 || cur.user !== n2.id.client || cur.type !== "added") {
                  packStr();
                  currentAttributes.set("ychange", computeYChange ? computeYChange("added", n2.id) : { type: "added" });
                }
              } else if (cur !== void 0) {
                packStr();
                currentAttributes.delete("ychange");
              }
              str += /** @type {ContentString} */
              n2.content.str;
              break;
            }
            case ContentType:
            case ContentEmbed: {
              packStr();
              const op = {
                insert: n2.content.getContent()[0]
              };
              if (currentAttributes.size > 0) {
                const attrs = (
                  /** @type {Object<string,any>} */
                  {}
                );
                op.attributes = attrs;
                currentAttributes.forEach((value, key) => {
                  attrs[key] = value;
                });
              }
              ops.push(op);
              break;
            }
            case ContentFormat:
              if (isVisible(n2, snapshot2)) {
                packStr();
                updateCurrentAttributes(
                  currentAttributes,
                  /** @type {ContentFormat} */
                  n2.content
                );
              }
              break;
          }
        }
        n2 = n2.right;
      }
      packStr();
    };
    if (snapshot2 || prevSnapshot) {
      transact(doc2, (transaction) => {
        if (snapshot2) {
          splitSnapshotAffectedStructs(transaction, snapshot2);
        }
        if (prevSnapshot) {
          splitSnapshotAffectedStructs(transaction, prevSnapshot);
        }
        computeDelta();
      }, "cleanup");
    } else {
      computeDelta();
    }
    return ops;
  }
  /**
   * Insert text at a given index.
   *
   * @param {number} index The index at which to start inserting.
   * @param {String} text The text to insert at the specified position.
   * @param {TextAttributes} [attributes] Optionally define some formatting
   *                                    information to apply on the inserted
   *                                    Text.
   * @public
   */
  insert(index, text2, attributes) {
    if (text2.length <= 0) {
      return;
    }
    const y2 = this.doc;
    if (y2 !== null) {
      transact(y2, (transaction) => {
        const pos = findPosition(transaction, this, index, !attributes);
        if (!attributes) {
          attributes = {};
          pos.currentAttributes.forEach((v2, k) => {
            attributes[k] = v2;
          });
        }
        insertText(transaction, this, pos, text2, attributes);
      });
    } else {
      this._pending.push(() => this.insert(index, text2, attributes));
    }
  }
  /**
   * Inserts an embed at a index.
   *
   * @param {number} index The index to insert the embed at.
   * @param {Object | AbstractType<any>} embed The Object that represents the embed.
   * @param {TextAttributes} [attributes] Attribute information to apply on the
   *                                    embed
   *
   * @public
   */
  insertEmbed(index, embed, attributes) {
    const y2 = this.doc;
    if (y2 !== null) {
      transact(y2, (transaction) => {
        const pos = findPosition(transaction, this, index, !attributes);
        insertText(transaction, this, pos, embed, attributes || {});
      });
    } else {
      this._pending.push(() => this.insertEmbed(index, embed, attributes || {}));
    }
  }
  /**
   * Deletes text starting from an index.
   *
   * @param {number} index Index at which to start deleting.
   * @param {number} length The number of characters to remove. Defaults to 1.
   *
   * @public
   */
  delete(index, length4) {
    if (length4 === 0) {
      return;
    }
    const y2 = this.doc;
    if (y2 !== null) {
      transact(y2, (transaction) => {
        deleteText(transaction, findPosition(transaction, this, index, true), length4);
      });
    } else {
      this._pending.push(() => this.delete(index, length4));
    }
  }
  /**
   * Assigns properties to a range of text.
   *
   * @param {number} index The position where to start formatting.
   * @param {number} length The amount of characters to assign properties to.
   * @param {TextAttributes} attributes Attribute information to apply on the
   *                                    text.
   *
   * @public
   */
  format(index, length4, attributes) {
    if (length4 === 0) {
      return;
    }
    const y2 = this.doc;
    if (y2 !== null) {
      transact(y2, (transaction) => {
        const pos = findPosition(transaction, this, index, false);
        if (pos.right === null) {
          return;
        }
        formatText(transaction, this, pos, length4, attributes);
      });
    } else {
      this._pending.push(() => this.format(index, length4, attributes));
    }
  }
  /**
   * Removes an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(attributeName) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapDelete(transaction, this, attributeName);
      });
    } else {
      this._pending.push(() => this.removeAttribute(attributeName));
    }
  }
  /**
   * Sets or updates an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be set.
   * @param {any} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(attributeName, attributeValue) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapSet(transaction, this, attributeName, attributeValue);
      });
    } else {
      this._pending.push(() => this.setAttribute(attributeName, attributeValue));
    }
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {any} The queried attribute value.
   *
   * @public
   */
  getAttribute(attributeName) {
    return (
      /** @type {any} */
      typeMapGet(this, attributeName)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @return {Object<string, any>} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes() {
    return typeMapGetAll(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder) {
    encoder.writeTypeRef(YTextRefID);
  }
};
var readYText = (_decoder) => new YText();
var YXmlTreeWalker = class {
  /**
   * @param {YXmlFragment | YXmlElement} root
   * @param {function(AbstractType<any>):boolean} [f]
   */
  constructor(root, f2 = () => true) {
    this._filter = f2;
    this._root = root;
    this._currentNode = /** @type {Item} */
    root._start;
    this._firstCall = true;
    root.doc ?? warnPrematureAccess();
  }
  [Symbol.iterator]() {
    return this;
  }
  /**
   * Get the next node.
   *
   * @return {IteratorResult<YXmlElement|YXmlText|YXmlHook>} The next node.
   *
   * @public
   */
  next() {
    let n2 = this._currentNode;
    let type = n2 && n2.content && /** @type {any} */
    n2.content.type;
    if (n2 !== null && (!this._firstCall || n2.deleted || !this._filter(type))) {
      do {
        type = /** @type {any} */
        n2.content.type;
        if (!n2.deleted && (type.constructor === YXmlElement || type.constructor === YXmlFragment) && type._start !== null) {
          n2 = type._start;
        } else {
          while (n2 !== null) {
            const nxt = n2.next;
            if (nxt !== null) {
              n2 = nxt;
              break;
            } else if (n2.parent === this._root) {
              n2 = null;
            } else {
              n2 = /** @type {AbstractType<any>} */
              n2.parent._item;
            }
          }
        }
      } while (n2 !== null && (n2.deleted || !this._filter(
        /** @type {ContentType} */
        n2.content.type
      )));
    }
    this._firstCall = false;
    if (n2 === null) {
      return { value: void 0, done: true };
    }
    this._currentNode = n2;
    return { value: (
      /** @type {any} */
      n2.content.type
    ), done: false };
  }
};
var YXmlFragment = class _YXmlFragment extends AbstractType {
  constructor() {
    super();
    this._prelimContent = [];
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get firstChild() {
    const first = this._first;
    return first ? first.content.getContent()[0] : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y2, item) {
    super._integrate(y2, item);
    this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    );
    this._prelimContent = null;
  }
  _copy() {
    return new _YXmlFragment();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlFragment}
   */
  clone() {
    const el = new _YXmlFragment();
    el.insert(0, this.toArray().map((item) => item instanceof AbstractType ? item.clone() : item));
    return el;
  }
  get length() {
    this.doc ?? warnPrematureAccess();
    return this._prelimContent === null ? this._length : this._prelimContent.length;
  }
  /**
   * Create a subtree of childNodes.
   *
   * @example
   * const walker = elem.createTreeWalker(dom => dom.nodeName === 'div')
   * for (let node in walker) {
   *   // `node` is a div node
   *   nop(node)
   * }
   *
   * @param {function(AbstractType<any>):boolean} filter Function that is called on each child element and
   *                          returns a Boolean indicating whether the child
   *                          is to be included in the subtree.
   * @return {YXmlTreeWalker} A subtree and a position within it.
   *
   * @public
   */
  createTreeWalker(filter2) {
    return new YXmlTreeWalker(this, filter2);
  }
  /**
   * Returns the first YXmlElement that matches the query.
   * Similar to DOM's {@link querySelector}.
   *
   * Query support:
   *   - tagname
   * TODO:
   *   - id
   *   - attribute
   *
   * @param {CSS_Selector} query The query on the children.
   * @return {YXmlElement|YXmlText|YXmlHook|null} The first element that matches the query or null.
   *
   * @public
   */
  querySelector(query) {
    query = query.toUpperCase();
    const iterator = new YXmlTreeWalker(this, (element2) => element2.nodeName && element2.nodeName.toUpperCase() === query);
    const next = iterator.next();
    if (next.done) {
      return null;
    } else {
      return next.value;
    }
  }
  /**
   * Returns all YXmlElements that match the query.
   * Similar to Dom's {@link querySelectorAll}.
   *
   * @todo Does not yet support all queries. Currently only query by tagName.
   *
   * @param {CSS_Selector} query The query on the children
   * @return {Array<YXmlElement|YXmlText|YXmlHook|null>} The elements that match this query.
   *
   * @public
   */
  querySelectorAll(query) {
    query = query.toUpperCase();
    return from2(new YXmlTreeWalker(this, (element2) => element2.nodeName && element2.nodeName.toUpperCase() === query));
  }
  /**
   * Creates YXmlEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    callTypeObservers(this, transaction, new YXmlEvent(this, parentSubs, transaction));
  }
  /**
   * Get the string representation of all the children of this YXmlFragment.
   *
   * @return {string} The string representation of all children.
   */
  toString() {
    return typeListMap(this, (xml) => xml.toString()).join("");
  }
  /**
   * @return {string}
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks = {}, binding) {
    const fragment = _document.createDocumentFragment();
    if (binding !== void 0) {
      binding._createAssociation(fragment, this);
    }
    typeListForEach(this, (xmlType) => {
      fragment.insertBefore(xmlType.toDOM(_document, hooks, binding), null);
    });
    return fragment;
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {number} index The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insert(index, content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListInsertGenerics(transaction, this, index, content);
      });
    } else {
      this._prelimContent.splice(index, 0, ...content);
    }
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insertAfter(ref, content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        const refItem = ref && ref instanceof AbstractType ? ref._item : ref;
        typeListInsertGenericsAfter(transaction, this, refItem, content);
      });
    } else {
      const pc = (
        /** @type {Array<any>} */
        this._prelimContent
      );
      const index = ref === null ? 0 : pc.findIndex((el) => el === ref) + 1;
      if (index === 0 && ref !== null) {
        throw create3("Reference item not found");
      }
      pc.splice(index, 0, ...content);
    }
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} [length=1] The number of elements to remove. Defaults to 1.
   */
  delete(index, length4 = 1) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListDelete(transaction, this, index, length4);
      });
    } else {
      this._prelimContent.splice(index, length4);
    }
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<YXmlElement|YXmlText|YXmlHook>}
   */
  toArray() {
    return typeListToArray(this);
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to append.
   */
  push(content) {
    this.insert(this.length, content);
  }
  /**
   * Prepends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to prepend.
   */
  unshift(content) {
    this.insert(0, content);
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {YXmlElement|YXmlText}
   */
  get(index) {
    return typeListGet(this, index);
  }
  /**
   * Returns a portion of this YXmlFragment into a JavaScript Array selected
   * from start to end (end not included).
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<YXmlElement|YXmlText>}
   */
  slice(start = 0, end = this.length) {
    return typeListSlice(this, start, end);
  }
  /**
   * Executes a provided function on once on every child element.
   *
   * @param {function(YXmlElement|YXmlText,number, typeof self):void} f A function to execute on every element of this YArray.
   */
  forEach(f2) {
    typeListForEach(this, f2);
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(encoder) {
    encoder.writeTypeRef(YXmlFragmentRefID);
  }
};
var readYXmlFragment = (_decoder) => new YXmlFragment();
var YXmlElement = class _YXmlElement extends YXmlFragment {
  constructor(nodeName = "UNDEFINED") {
    super();
    this.nodeName = nodeName;
    this._prelimAttrs = /* @__PURE__ */ new Map();
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get nextSibling() {
    const n2 = this._item ? this._item.next : null;
    return n2 ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n2.content.type
    ) : null;
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get prevSibling() {
    const n2 = this._item ? this._item.prev : null;
    return n2 ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n2.content.type
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y2, item) {
    super._integrate(y2, item);
    /** @type {Map<string, any>} */
    this._prelimAttrs.forEach((value, key) => {
      this.setAttribute(key, value);
    });
    this._prelimAttrs = null;
  }
  /**
   * Creates an Item with the same effect as this Item (without position effect)
   *
   * @return {YXmlElement}
   */
  _copy() {
    return new _YXmlElement(this.nodeName);
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlElement<KV>}
   */
  clone() {
    const el = new _YXmlElement(this.nodeName);
    const attrs = this.getAttributes();
    forEach(attrs, (value, key) => {
      if (typeof value === "string") {
        el.setAttribute(key, value);
      }
    });
    el.insert(0, this.toArray().map((item) => item instanceof AbstractType ? item.clone() : item));
    return el;
  }
  /**
   * Returns the XML serialization of this YXmlElement.
   * The attributes are ordered by attribute-name, so you can easily use this
   * method to compare YXmlElements
   *
   * @return {string} The string representation of this type.
   *
   * @public
   */
  toString() {
    const attrs = this.getAttributes();
    const stringBuilder = [];
    const keys4 = [];
    for (const key in attrs) {
      keys4.push(key);
    }
    keys4.sort();
    const keysLen = keys4.length;
    for (let i2 = 0; i2 < keysLen; i2++) {
      const key = keys4[i2];
      stringBuilder.push(key + '="' + attrs[key] + '"');
    }
    const nodeName = this.nodeName.toLocaleLowerCase();
    const attrsString = stringBuilder.length > 0 ? " " + stringBuilder.join(" ") : "";
    return `<${nodeName}${attrsString}>${super.toString()}</${nodeName}>`;
  }
  /**
   * Removes an attribute from this YXmlElement.
   *
   * @param {string} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(attributeName) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapDelete(transaction, this, attributeName);
      });
    } else {
      this._prelimAttrs.delete(attributeName);
    }
  }
  /**
   * Sets or updates an attribute.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that is to be set.
   * @param {KV[KEY]} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(attributeName, attributeValue) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapSet(transaction, this, attributeName, attributeValue);
      });
    } else {
      this._prelimAttrs.set(attributeName, attributeValue);
    }
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {KV[KEY]|undefined} The queried attribute value.
   *
   * @public
   */
  getAttribute(attributeName) {
    return (
      /** @type {any} */
      typeMapGet(this, attributeName)
    );
  }
  /**
   * Returns whether an attribute exists
   *
   * @param {string} attributeName The attribute name to check for existence.
   * @return {boolean} whether the attribute exists.
   *
   * @public
   */
  hasAttribute(attributeName) {
    return (
      /** @type {any} */
      typeMapHas(this, attributeName)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @param {Snapshot} [snapshot]
   * @return {{ [Key in Extract<keyof KV,string>]?: KV[Key]}} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes(snapshot2) {
    return (
      /** @type {any} */
      snapshot2 ? typeMapGetAllSnapshot(this, snapshot2) : typeMapGetAll(this)
    );
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks = {}, binding) {
    const dom = _document.createElement(this.nodeName);
    const attrs = this.getAttributes();
    for (const key in attrs) {
      const value = attrs[key];
      if (typeof value === "string") {
        dom.setAttribute(key, value);
      }
    }
    typeListForEach(this, (yxml) => {
      dom.appendChild(yxml.toDOM(_document, hooks, binding));
    });
    if (binding !== void 0) {
      binding._createAssociation(dom, this);
    }
    return dom;
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(encoder) {
    encoder.writeTypeRef(YXmlElementRefID);
    encoder.writeKey(this.nodeName);
  }
};
var readYXmlElement = (decoder) => new YXmlElement(decoder.readKey());
var YXmlEvent = class extends YEvent {
  /**
   * @param {YXmlElement|YXmlText|YXmlFragment} target The target on which the event is created.
   * @param {Set<string|null>} subs The set of changed attributes. `null` is included if the
   *                   child list changed.
   * @param {Transaction} transaction The transaction instance with which the
   *                                  change was created.
   */
  constructor(target, subs, transaction) {
    super(target, transaction);
    this.childListChanged = false;
    this.attributesChanged = /* @__PURE__ */ new Set();
    subs.forEach((sub2) => {
      if (sub2 === null) {
        this.childListChanged = true;
      } else {
        this.attributesChanged.add(sub2);
      }
    });
  }
};
var YXmlHook = class _YXmlHook extends YMap {
  /**
   * @param {string} hookName nodeName of the Dom Node.
   */
  constructor(hookName) {
    super();
    this.hookName = hookName;
  }
  /**
   * Creates an Item with the same effect as this Item (without position effect)
   */
  _copy() {
    return new _YXmlHook(this.hookName);
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlHook}
   */
  clone() {
    const el = new _YXmlHook(this.hookName);
    this.forEach((value, key) => {
      el.set(key, value);
    });
    return el;
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object.<string, any>} [hooks] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type
   * @return {Element} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks = {}, binding) {
    const hook = hooks[this.hookName];
    let dom;
    if (hook !== void 0) {
      dom = hook.createDom(this);
    } else {
      dom = document.createElement(this.hookName);
    }
    dom.setAttribute("data-yjs-hook", this.hookName);
    if (binding !== void 0) {
      binding._createAssociation(dom, this);
    }
    return dom;
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(encoder) {
    encoder.writeTypeRef(YXmlHookRefID);
    encoder.writeKey(this.hookName);
  }
};
var readYXmlHook = (decoder) => new YXmlHook(decoder.readKey());
var YXmlText = class _YXmlText extends YText {
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get nextSibling() {
    const n2 = this._item ? this._item.next : null;
    return n2 ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n2.content.type
    ) : null;
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get prevSibling() {
    const n2 = this._item ? this._item.prev : null;
    return n2 ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n2.content.type
    ) : null;
  }
  _copy() {
    return new _YXmlText();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlText}
   */
  clone() {
    const text2 = new _YXmlText();
    text2.applyDelta(this.toDelta());
    return text2;
  }
  /**
   * Creates a Dom Element that mirrors this YXmlText.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Text} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks, binding) {
    const dom = _document.createTextNode(this.toString());
    if (binding !== void 0) {
      binding._createAssociation(dom, this);
    }
    return dom;
  }
  toString() {
    return this.toDelta().map((delta) => {
      const nestedNodes = [];
      for (const nodeName in delta.attributes) {
        const attrs = [];
        for (const key in delta.attributes[nodeName]) {
          attrs.push({ key, value: delta.attributes[nodeName][key] });
        }
        attrs.sort((a2, b2) => a2.key < b2.key ? -1 : 1);
        nestedNodes.push({ nodeName, attrs });
      }
      nestedNodes.sort((a2, b2) => a2.nodeName < b2.nodeName ? -1 : 1);
      let str = "";
      for (let i2 = 0; i2 < nestedNodes.length; i2++) {
        const node = nestedNodes[i2];
        str += `<${node.nodeName}`;
        for (let j = 0; j < node.attrs.length; j++) {
          const attr = node.attrs[j];
          str += ` ${attr.key}="${attr.value}"`;
        }
        str += ">";
      }
      str += delta.insert;
      for (let i2 = nestedNodes.length - 1; i2 >= 0; i2--) {
        str += `</${nestedNodes[i2].nodeName}>`;
      }
      return str;
    }).join("");
  }
  /**
   * @return {string}
   */
  toJSON() {
    return this.toString();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder) {
    encoder.writeTypeRef(YXmlTextRefID);
  }
};
var readYXmlText = (decoder) => new YXmlText();
var AbstractStruct = class {
  /**
   * @param {ID} id
   * @param {number} length
   */
  constructor(id2, length4) {
    this.id = id2;
    this.length = length4;
  }
  /**
   * @type {boolean}
   */
  get deleted() {
    throw methodUnimplemented();
  }
  /**
   * Merge this struct with the item to the right.
   * This method is already assuming that `this.id.clock + this.length === this.id.clock`.
   * Also this method does *not* remove right from StructStore!
   * @param {AbstractStruct} right
   * @return {boolean} whether this merged with right
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   * @param {number} encodingRef
   */
  write(encoder, offset, encodingRef) {
    throw methodUnimplemented();
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    throw methodUnimplemented();
  }
};
var structGCRefNumber = 0;
var GC = class extends AbstractStruct {
  get deleted() {
    return true;
  }
  delete() {
  }
  /**
   * @param {GC} right
   * @return {boolean}
   */
  mergeWith(right) {
    if (this.constructor !== right.constructor) {
      return false;
    }
    this.length += right.length;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    if (offset > 0) {
      this.id.clock += offset;
      this.length -= offset;
    }
    addStruct(transaction.doc.store, this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeInfo(structGCRefNumber);
    encoder.writeLen(this.length - offset);
  }
  /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(transaction, store) {
    return null;
  }
};
var ContentBinary = class _ContentBinary {
  /**
   * @param {Uint8Array} content
   */
  constructor(content) {
    this.content = content;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.content];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentBinary}
   */
  copy() {
    return new _ContentBinary(this.content);
  }
  /**
   * @param {number} offset
   * @return {ContentBinary}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentBinary} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeBuf(this.content);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 3;
  }
};
var readContentBinary = (decoder) => new ContentBinary(decoder.readBuf());
var ContentDeleted = class _ContentDeleted {
  /**
   * @param {number} len
   */
  constructor(len3) {
    this.len = len3;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.len;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return false;
  }
  /**
   * @return {ContentDeleted}
   */
  copy() {
    return new _ContentDeleted(this.len);
  }
  /**
   * @param {number} offset
   * @return {ContentDeleted}
   */
  splice(offset) {
    const right = new _ContentDeleted(this.len - offset);
    this.len = offset;
    return right;
  }
  /**
   * @param {ContentDeleted} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.len += right.len;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
    addToDeleteSet(transaction.deleteSet, item.id.client, item.id.clock, this.len);
    item.markDeleted();
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeLen(this.len - offset);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 1;
  }
};
var readContentDeleted = (decoder) => new ContentDeleted(decoder.readLen());
var createDocFromOpts = (guid, opts) => new Doc({ guid, ...opts, shouldLoad: opts.shouldLoad || opts.autoLoad || false });
var ContentDoc = class _ContentDoc {
  /**
   * @param {Doc} doc
   */
  constructor(doc2) {
    if (doc2._item) {
      console.error("This document was already integrated as a sub-document. You should create a second instance instead with the same guid.");
    }
    this.doc = doc2;
    const opts = {};
    this.opts = opts;
    if (!doc2.gc) {
      opts.gc = false;
    }
    if (doc2.autoLoad) {
      opts.autoLoad = true;
    }
    if (doc2.meta !== null) {
      opts.meta = doc2.meta;
    }
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.doc];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentDoc}
   */
  copy() {
    return new _ContentDoc(createDocFromOpts(this.doc.guid, this.opts));
  }
  /**
   * @param {number} offset
   * @return {ContentDoc}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentDoc} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
    this.doc._item = item;
    transaction.subdocsAdded.add(this.doc);
    if (this.doc.shouldLoad) {
      transaction.subdocsLoaded.add(this.doc);
    }
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
    if (transaction.subdocsAdded.has(this.doc)) {
      transaction.subdocsAdded.delete(this.doc);
    } else {
      transaction.subdocsRemoved.add(this.doc);
    }
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeString(this.doc.guid);
    encoder.writeAny(this.opts);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 9;
  }
};
var readContentDoc = (decoder) => new ContentDoc(createDocFromOpts(decoder.readString(), decoder.readAny()));
var ContentEmbed = class _ContentEmbed {
  /**
   * @param {Object} embed
   */
  constructor(embed) {
    this.embed = embed;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.embed];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentEmbed}
   */
  copy() {
    return new _ContentEmbed(this.embed);
  }
  /**
   * @param {number} offset
   * @return {ContentEmbed}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentEmbed} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeJSON(this.embed);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 5;
  }
};
var readContentEmbed = (decoder) => new ContentEmbed(decoder.readJSON());
var ContentFormat = class _ContentFormat {
  /**
   * @param {string} key
   * @param {Object} value
   */
  constructor(key, value) {
    this.key = key;
    this.value = value;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return false;
  }
  /**
   * @return {ContentFormat}
   */
  copy() {
    return new _ContentFormat(this.key, this.value);
  }
  /**
   * @param {number} _offset
   * @return {ContentFormat}
   */
  splice(_offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentFormat} _right
   * @return {boolean}
   */
  mergeWith(_right) {
    return false;
  }
  /**
   * @param {Transaction} _transaction
   * @param {Item} item
   */
  integrate(_transaction, item) {
    const p2 = (
      /** @type {YText} */
      item.parent
    );
    p2._searchMarker = null;
    p2._hasFormatting = true;
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeKey(this.key);
    encoder.writeJSON(this.value);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 6;
  }
};
var readContentFormat = (decoder) => new ContentFormat(decoder.readKey(), decoder.readJSON());
var ContentJSON = class _ContentJSON {
  /**
   * @param {Array<any>} arr
   */
  constructor(arr) {
    this.arr = arr;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.arr.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.arr;
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentJSON}
   */
  copy() {
    return new _ContentJSON(this.arr);
  }
  /**
   * @param {number} offset
   * @return {ContentJSON}
   */
  splice(offset) {
    const right = new _ContentJSON(this.arr.slice(offset));
    this.arr = this.arr.slice(0, offset);
    return right;
  }
  /**
   * @param {ContentJSON} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.arr = this.arr.concat(right.arr);
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    const len3 = this.arr.length;
    encoder.writeLen(len3 - offset);
    for (let i2 = offset; i2 < len3; i2++) {
      const c2 = this.arr[i2];
      encoder.writeString(c2 === void 0 ? "undefined" : JSON.stringify(c2));
    }
  }
  /**
   * @return {number}
   */
  getRef() {
    return 2;
  }
};
var readContentJSON = (decoder) => {
  const len3 = decoder.readLen();
  const cs = [];
  for (let i2 = 0; i2 < len3; i2++) {
    const c2 = decoder.readString();
    if (c2 === "undefined") {
      cs.push(void 0);
    } else {
      cs.push(JSON.parse(c2));
    }
  }
  return new ContentJSON(cs);
};
var isDevMode = getVariable("node_env") === "development";
var ContentAny = class _ContentAny {
  /**
   * @param {Array<any>} arr
   */
  constructor(arr) {
    this.arr = arr;
    isDevMode && deepFreeze(arr);
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.arr.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.arr;
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentAny}
   */
  copy() {
    return new _ContentAny(this.arr);
  }
  /**
   * @param {number} offset
   * @return {ContentAny}
   */
  splice(offset) {
    const right = new _ContentAny(this.arr.slice(offset));
    this.arr = this.arr.slice(0, offset);
    return right;
  }
  /**
   * @param {ContentAny} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.arr = this.arr.concat(right.arr);
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    const len3 = this.arr.length;
    encoder.writeLen(len3 - offset);
    for (let i2 = offset; i2 < len3; i2++) {
      const c2 = this.arr[i2];
      encoder.writeAny(c2);
    }
  }
  /**
   * @return {number}
   */
  getRef() {
    return 8;
  }
};
var readContentAny = (decoder) => {
  const len3 = decoder.readLen();
  const cs = [];
  for (let i2 = 0; i2 < len3; i2++) {
    cs.push(decoder.readAny());
  }
  return new ContentAny(cs);
};
var ContentString = class _ContentString {
  /**
   * @param {string} str
   */
  constructor(str) {
    this.str = str;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.str.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.str.split("");
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentString}
   */
  copy() {
    return new _ContentString(this.str);
  }
  /**
   * @param {number} offset
   * @return {ContentString}
   */
  splice(offset) {
    const right = new _ContentString(this.str.slice(offset));
    this.str = this.str.slice(0, offset);
    const firstCharCode = this.str.charCodeAt(offset - 1);
    if (firstCharCode >= 55296 && firstCharCode <= 56319) {
      this.str = this.str.slice(0, offset - 1) + "";
      right.str = "" + right.str.slice(1);
    }
    return right;
  }
  /**
   * @param {ContentString} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.str += right.str;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeString(offset === 0 ? this.str : this.str.slice(offset));
  }
  /**
   * @return {number}
   */
  getRef() {
    return 4;
  }
};
var readContentString = (decoder) => new ContentString(decoder.readString());
var typeRefs = [
  readYArray,
  readYMap,
  readYText,
  readYXmlElement,
  readYXmlFragment,
  readYXmlHook,
  readYXmlText
];
var YArrayRefID = 0;
var YMapRefID = 1;
var YTextRefID = 2;
var YXmlElementRefID = 3;
var YXmlFragmentRefID = 4;
var YXmlHookRefID = 5;
var YXmlTextRefID = 6;
var ContentType = class _ContentType {
  /**
   * @param {AbstractType<any>} type
   */
  constructor(type) {
    this.type = type;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.type];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentType}
   */
  copy() {
    return new _ContentType(this.type._copy());
  }
  /**
   * @param {number} offset
   * @return {ContentType}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentType} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
    this.type._integrate(transaction.doc, item);
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
    let item = this.type._start;
    while (item !== null) {
      if (!item.deleted) {
        item.delete(transaction);
      } else if (item.id.clock < (transaction.beforeState.get(item.id.client) || 0)) {
        transaction._mergeStructs.push(item);
      }
      item = item.right;
    }
    this.type._map.forEach((item2) => {
      if (!item2.deleted) {
        item2.delete(transaction);
      } else if (item2.id.clock < (transaction.beforeState.get(item2.id.client) || 0)) {
        transaction._mergeStructs.push(item2);
      }
    });
    transaction.changed.delete(this.type);
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
    let item = this.type._start;
    while (item !== null) {
      item.gc(store, true);
      item = item.right;
    }
    this.type._start = null;
    this.type._map.forEach(
      /** @param {Item | null} item */
      (item2) => {
        while (item2 !== null) {
          item2.gc(store, true);
          item2 = item2.left;
        }
      }
    );
    this.type._map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    this.type._write(encoder);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 7;
  }
};
var readContentType = (decoder) => new ContentType(typeRefs[decoder.readTypeRef()](decoder));
var followRedone = (store, id2) => {
  let nextID = id2;
  let diff = 0;
  let item;
  do {
    if (diff > 0) {
      nextID = createID(nextID.client, nextID.clock + diff);
    }
    item = getItem(store, nextID);
    diff = nextID.clock - item.id.clock;
    nextID = item.redone;
  } while (nextID !== null && item instanceof Item);
  return {
    item,
    diff
  };
};
var keepItem = (item, keep) => {
  while (item !== null && item.keep !== keep) {
    item.keep = keep;
    item = /** @type {AbstractType<any>} */
    item.parent._item;
  }
};
var splitItem = (transaction, leftItem, diff) => {
  const { client, clock } = leftItem.id;
  const rightItem = new Item(
    createID(client, clock + diff),
    leftItem,
    createID(client, clock + diff - 1),
    leftItem.right,
    leftItem.rightOrigin,
    leftItem.parent,
    leftItem.parentSub,
    leftItem.content.splice(diff)
  );
  if (leftItem.deleted) {
    rightItem.markDeleted();
  }
  if (leftItem.keep) {
    rightItem.keep = true;
  }
  if (leftItem.redone !== null) {
    rightItem.redone = createID(leftItem.redone.client, leftItem.redone.clock + diff);
  }
  leftItem.right = rightItem;
  if (rightItem.right !== null) {
    rightItem.right.left = rightItem;
  }
  transaction._mergeStructs.push(rightItem);
  if (rightItem.parentSub !== null && rightItem.right === null) {
    rightItem.parent._map.set(rightItem.parentSub, rightItem);
  }
  leftItem.length = diff;
  return rightItem;
};
var isDeletedByUndoStack = (stack, id2) => some(
  stack,
  /** @param {StackItem} s */
  (s2) => isDeleted(s2.deletions, id2)
);
var redoItem = (transaction, item, redoitems, itemsToDelete, ignoreRemoteMapChanges, um) => {
  const doc2 = transaction.doc;
  const store = doc2.store;
  const ownClientID = doc2.clientID;
  const redone = item.redone;
  if (redone !== null) {
    return getItemCleanStart(transaction, redone);
  }
  let parentItem = (
    /** @type {AbstractType<any>} */
    item.parent._item
  );
  let left = null;
  let right;
  if (parentItem !== null && parentItem.deleted === true) {
    if (parentItem.redone === null && (!redoitems.has(parentItem) || redoItem(transaction, parentItem, redoitems, itemsToDelete, ignoreRemoteMapChanges, um) === null)) {
      return null;
    }
    while (parentItem.redone !== null) {
      parentItem = getItemCleanStart(transaction, parentItem.redone);
    }
  }
  const parentType = parentItem === null ? (
    /** @type {AbstractType<any>} */
    item.parent
  ) : (
    /** @type {ContentType} */
    parentItem.content.type
  );
  if (item.parentSub === null) {
    left = item.left;
    right = item;
    while (left !== null) {
      let leftTrace = left;
      while (leftTrace !== null && /** @type {AbstractType<any>} */
      leftTrace.parent._item !== parentItem) {
        leftTrace = leftTrace.redone === null ? null : getItemCleanStart(transaction, leftTrace.redone);
      }
      if (leftTrace !== null && /** @type {AbstractType<any>} */
      leftTrace.parent._item === parentItem) {
        left = leftTrace;
        break;
      }
      left = left.left;
    }
    while (right !== null) {
      let rightTrace = right;
      while (rightTrace !== null && /** @type {AbstractType<any>} */
      rightTrace.parent._item !== parentItem) {
        rightTrace = rightTrace.redone === null ? null : getItemCleanStart(transaction, rightTrace.redone);
      }
      if (rightTrace !== null && /** @type {AbstractType<any>} */
      rightTrace.parent._item === parentItem) {
        right = rightTrace;
        break;
      }
      right = right.right;
    }
  } else {
    right = null;
    if (item.right && !ignoreRemoteMapChanges) {
      left = item;
      while (left !== null && left.right !== null && (left.right.redone || isDeleted(itemsToDelete, left.right.id) || isDeletedByUndoStack(um.undoStack, left.right.id) || isDeletedByUndoStack(um.redoStack, left.right.id))) {
        left = left.right;
        while (left.redone) left = getItemCleanStart(transaction, left.redone);
      }
      if (left && left.right !== null) {
        return null;
      }
    } else {
      left = parentType._map.get(item.parentSub) || null;
    }
  }
  const nextClock = getState(store, ownClientID);
  const nextId = createID(ownClientID, nextClock);
  const redoneItem = new Item(
    nextId,
    left,
    left && left.lastId,
    right,
    right && right.id,
    parentType,
    item.parentSub,
    item.content.copy()
  );
  item.redone = nextId;
  keepItem(redoneItem, true);
  redoneItem.integrate(transaction, 0);
  return redoneItem;
};
var Item = class _Item extends AbstractStruct {
  /**
   * @param {ID} id
   * @param {Item | null} left
   * @param {ID | null} origin
   * @param {Item | null} right
   * @param {ID | null} rightOrigin
   * @param {AbstractType<any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.
   * @param {string | null} parentSub
   * @param {AbstractContent} content
   */
  constructor(id2, left, origin, right, rightOrigin, parent, parentSub, content) {
    super(id2, content.getLength());
    this.origin = origin;
    this.left = left;
    this.right = right;
    this.rightOrigin = rightOrigin;
    this.parent = parent;
    this.parentSub = parentSub;
    this.redone = null;
    this.content = content;
    this.info = this.content.isCountable() ? BIT2 : 0;
  }
  /**
   * This is used to mark the item as an indexed fast-search marker
   *
   * @type {boolean}
   */
  set marker(isMarked) {
    if ((this.info & BIT4) > 0 !== isMarked) {
      this.info ^= BIT4;
    }
  }
  get marker() {
    return (this.info & BIT4) > 0;
  }
  /**
   * If true, do not garbage collect this Item.
   */
  get keep() {
    return (this.info & BIT1) > 0;
  }
  set keep(doKeep) {
    if (this.keep !== doKeep) {
      this.info ^= BIT1;
    }
  }
  get countable() {
    return (this.info & BIT2) > 0;
  }
  /**
   * Whether this item was deleted or not.
   * @type {Boolean}
   */
  get deleted() {
    return (this.info & BIT3) > 0;
  }
  set deleted(doDelete) {
    if (this.deleted !== doDelete) {
      this.info ^= BIT3;
    }
  }
  markDeleted() {
    this.info |= BIT3;
  }
  /**
   * Return the creator clientID of the missing op or define missing items and return null.
   *
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(transaction, store) {
    if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= getState(store, this.origin.client)) {
      return this.origin.client;
    }
    if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= getState(store, this.rightOrigin.client)) {
      return this.rightOrigin.client;
    }
    if (this.parent && this.parent.constructor === ID && this.id.client !== this.parent.client && this.parent.clock >= getState(store, this.parent.client)) {
      return this.parent.client;
    }
    if (this.origin) {
      this.left = getItemCleanEnd(transaction, store, this.origin);
      this.origin = this.left.lastId;
    }
    if (this.rightOrigin) {
      this.right = getItemCleanStart(transaction, this.rightOrigin);
      this.rightOrigin = this.right.id;
    }
    if (this.left && this.left.constructor === GC || this.right && this.right.constructor === GC) {
      this.parent = null;
    } else if (!this.parent) {
      if (this.left && this.left.constructor === _Item) {
        this.parent = this.left.parent;
        this.parentSub = this.left.parentSub;
      } else if (this.right && this.right.constructor === _Item) {
        this.parent = this.right.parent;
        this.parentSub = this.right.parentSub;
      }
    } else if (this.parent.constructor === ID) {
      const parentItem = getItem(store, this.parent);
      if (parentItem.constructor === GC) {
        this.parent = null;
      } else {
        this.parent = /** @type {ContentType} */
        parentItem.content.type;
      }
    }
    return null;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    if (offset > 0) {
      this.id.clock += offset;
      this.left = getItemCleanEnd(transaction, transaction.doc.store, createID(this.id.client, this.id.clock - 1));
      this.origin = this.left.lastId;
      this.content = this.content.splice(offset);
      this.length -= offset;
    }
    if (this.parent) {
      if (!this.left && (!this.right || this.right.left !== null) || this.left && this.left.right !== this.right) {
        let left = this.left;
        let o2;
        if (left !== null) {
          o2 = left.right;
        } else if (this.parentSub !== null) {
          o2 = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null;
          while (o2 !== null && o2.left !== null) {
            o2 = o2.left;
          }
        } else {
          o2 = /** @type {AbstractType<any>} */
          this.parent._start;
        }
        const conflictingItems = /* @__PURE__ */ new Set();
        const itemsBeforeOrigin = /* @__PURE__ */ new Set();
        while (o2 !== null && o2 !== this.right) {
          itemsBeforeOrigin.add(o2);
          conflictingItems.add(o2);
          if (compareIDs(this.origin, o2.origin)) {
            if (o2.id.client < this.id.client) {
              left = o2;
              conflictingItems.clear();
            } else if (compareIDs(this.rightOrigin, o2.rightOrigin)) {
              break;
            }
          } else if (o2.origin !== null && itemsBeforeOrigin.has(getItem(transaction.doc.store, o2.origin))) {
            if (!conflictingItems.has(getItem(transaction.doc.store, o2.origin))) {
              left = o2;
              conflictingItems.clear();
            }
          } else {
            break;
          }
          o2 = o2.right;
        }
        this.left = left;
      }
      if (this.left !== null) {
        const right = this.left.right;
        this.right = right;
        this.left.right = this;
      } else {
        let r;
        if (this.parentSub !== null) {
          r = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null;
          while (r !== null && r.left !== null) {
            r = r.left;
          }
        } else {
          r = /** @type {AbstractType<any>} */
          this.parent._start;
          this.parent._start = this;
        }
        this.right = r;
      }
      if (this.right !== null) {
        this.right.left = this;
      } else if (this.parentSub !== null) {
        this.parent._map.set(this.parentSub, this);
        if (this.left !== null) {
          this.left.delete(transaction);
        }
      }
      if (this.parentSub === null && this.countable && !this.deleted) {
        this.parent._length += this.length;
      }
      addStruct(transaction.doc.store, this);
      this.content.integrate(transaction, this);
      addChangedTypeToTransaction(
        transaction,
        /** @type {AbstractType<any>} */
        this.parent,
        this.parentSub
      );
      if (
        /** @type {AbstractType<any>} */
        this.parent._item !== null && /** @type {AbstractType<any>} */
        this.parent._item.deleted || this.parentSub !== null && this.right !== null
      ) {
        this.delete(transaction);
      }
    } else {
      new GC(this.id, this.length).integrate(transaction, 0);
    }
  }
  /**
   * Returns the next non-deleted item
   */
  get next() {
    let n2 = this.right;
    while (n2 !== null && n2.deleted) {
      n2 = n2.right;
    }
    return n2;
  }
  /**
   * Returns the previous non-deleted item
   */
  get prev() {
    let n2 = this.left;
    while (n2 !== null && n2.deleted) {
      n2 = n2.left;
    }
    return n2;
  }
  /**
   * Computes the last content address of this Item.
   */
  get lastId() {
    return this.length === 1 ? this.id : createID(this.id.client, this.id.clock + this.length - 1);
  }
  /**
   * Try to merge two items
   *
   * @param {Item} right
   * @return {boolean}
   */
  mergeWith(right) {
    if (this.constructor === right.constructor && compareIDs(right.origin, this.lastId) && this.right === right && compareIDs(this.rightOrigin, right.rightOrigin) && this.id.client === right.id.client && this.id.clock + this.length === right.id.clock && this.deleted === right.deleted && this.redone === null && right.redone === null && this.content.constructor === right.content.constructor && this.content.mergeWith(right.content)) {
      const searchMarker = (
        /** @type {AbstractType<any>} */
        this.parent._searchMarker
      );
      if (searchMarker) {
        searchMarker.forEach((marker) => {
          if (marker.p === right) {
            marker.p = this;
            if (!this.deleted && this.countable) {
              marker.index -= this.length;
            }
          }
        });
      }
      if (right.keep) {
        this.keep = true;
      }
      this.right = right.right;
      if (this.right !== null) {
        this.right.left = this;
      }
      this.length += right.length;
      return true;
    }
    return false;
  }
  /**
   * Mark this Item as deleted.
   *
   * @param {Transaction} transaction
   */
  delete(transaction) {
    if (!this.deleted) {
      const parent = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      if (this.countable && this.parentSub === null) {
        parent._length -= this.length;
      }
      this.markDeleted();
      addToDeleteSet(transaction.deleteSet, this.id.client, this.id.clock, this.length);
      addChangedTypeToTransaction(transaction, parent, this.parentSub);
      this.content.delete(transaction);
    }
  }
  /**
   * @param {StructStore} store
   * @param {boolean} parentGCd
   */
  gc(store, parentGCd) {
    if (!this.deleted) {
      throw unexpectedCase();
    }
    this.content.gc(store);
    if (parentGCd) {
      replaceStruct(store, this, new GC(this.id, this.length));
    } else {
      this.content = new ContentDeleted(this.length);
    }
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   */
  write(encoder, offset) {
    const origin = offset > 0 ? createID(this.id.client, this.id.clock + offset - 1) : this.origin;
    const rightOrigin = this.rightOrigin;
    const parentSub = this.parentSub;
    const info = this.content.getRef() & BITS5 | (origin === null ? 0 : BIT8) | // origin is defined
    (rightOrigin === null ? 0 : BIT7) | // right origin is defined
    (parentSub === null ? 0 : BIT6);
    encoder.writeInfo(info);
    if (origin !== null) {
      encoder.writeLeftID(origin);
    }
    if (rightOrigin !== null) {
      encoder.writeRightID(rightOrigin);
    }
    if (origin === null && rightOrigin === null) {
      const parent = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      if (parent._item !== void 0) {
        const parentItem = parent._item;
        if (parentItem === null) {
          const ykey = findRootTypeKey(parent);
          encoder.writeParentInfo(true);
          encoder.writeString(ykey);
        } else {
          encoder.writeParentInfo(false);
          encoder.writeLeftID(parentItem.id);
        }
      } else if (parent.constructor === String) {
        encoder.writeParentInfo(true);
        encoder.writeString(parent);
      } else if (parent.constructor === ID) {
        encoder.writeParentInfo(false);
        encoder.writeLeftID(parent);
      } else {
        unexpectedCase();
      }
      if (parentSub !== null) {
        encoder.writeString(parentSub);
      }
    }
    this.content.write(encoder, offset);
  }
};
var readItemContent = (decoder, info) => contentRefs[info & BITS5](decoder);
var contentRefs = [
  () => {
    unexpectedCase();
  },
  // GC is not ItemContent
  readContentDeleted,
  // 1
  readContentJSON,
  // 2
  readContentBinary,
  // 3
  readContentString,
  // 4
  readContentEmbed,
  // 5
  readContentFormat,
  // 6
  readContentType,
  // 7
  readContentAny,
  // 8
  readContentDoc,
  // 9
  () => {
    unexpectedCase();
  }
  // 10 - Skip is not ItemContent
];
var structSkipRefNumber = 10;
var Skip = class extends AbstractStruct {
  get deleted() {
    return true;
  }
  delete() {
  }
  /**
   * @param {Skip} right
   * @return {boolean}
   */
  mergeWith(right) {
    if (this.constructor !== right.constructor) {
      return false;
    }
    this.length += right.length;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    unexpectedCase();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeInfo(structSkipRefNumber);
    writeVarUint(encoder.restEncoder, this.length - offset);
  }
  /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(transaction, store) {
    return null;
  }
};
var glo = (
  /** @type {any} */
  typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {}
);
var importIdentifier = "__ $YJS$ __";
if (glo[importIdentifier] === true) {
  console.error("Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438");
}
glo[importIdentifier] = true;

// node_modules/@blocksuite/store/dist/consts.js
var COLLECTION_VERSION = 2;
var PAGE_VERSION = 2;
var SCHEMA_NOT_FOUND_MESSAGE = "Schema not found. The block flavour may not be registered.";
var TEXT_UNIQ_IDENTIFIER = "$blocksuite:internal:text$";
var NATIVE_UNIQ_IDENTIFIER = "$blocksuite:internal:native$";
var SYS_KEYS = /* @__PURE__ */ new Set(["id", "flavour", "children"]);

// node_modules/@blocksuite/store/dist/reactive/boxed.js
var _Boxed = class _Boxed {
  get yMap() {
    return this._map;
  }
  constructor(value, onChange) {
    this.getValue = () => {
      return this._map.get("value");
    };
    this.setValue = (value2) => {
      return this._map.set("value", value2);
    };
    this._onChange = onChange;
    if (value instanceof YMap && value.doc && value.get("type") === NATIVE_UNIQ_IDENTIFIER) {
      this._map = value;
    } else {
      this._map = new YMap();
      this._map.set("type", NATIVE_UNIQ_IDENTIFIER);
      this._map.set("value", value);
    }
    this._map.observeDeep(() => {
      this._onChange?.(this.getValue());
    });
  }
  bind(onChange) {
    this._onChange = onChange;
  }
};
_Boxed.from = (map3, onChange) => {
  return new _Boxed(map3.get("value"), onChange);
};
_Boxed.is = (value) => {
  return value instanceof YMap && value.get("type") === NATIVE_UNIQ_IDENTIFIER;
};
var Boxed = _Boxed;

// node_modules/@blocksuite/store/dist/reactive/text.js
var Text = class _Text {
  get deltas$() {
    return this._deltas$;
  }
  get length() {
    return this._length$.value;
  }
  get yText() {
    return this._yText;
  }
  constructor(input, onChange) {
    this._onChange = onChange;
    let length4 = 0;
    if (typeof input === "string") {
      const text2 = input.replaceAll("\r\n", "\n");
      length4 = text2.length;
      this._yText = new YText(text2);
    } else if (input instanceof YText) {
      this._yText = input;
      if (input.doc) {
        length4 = input.length;
      }
    } else if (input instanceof Array) {
      for (const delta of input) {
        if (delta.insert) {
          delta.insert = delta.insert.replaceAll("\r\n", "\n");
          length4 += delta.insert.length;
        }
      }
      const yText = new YText();
      yText.applyDelta(input);
      this._yText = yText;
    } else {
      this._yText = new YText();
    }
    this._length$ = d(length4);
    this._deltas$ = d(this._yText.doc ? this._yText.toDelta() : []);
    this._yText.observe(() => {
      this._length$.value = this._yText.length;
      this._deltas$.value = this._yText.toDelta();
      this._onChange?.(this._yText);
    });
  }
  _transact(callback) {
    const doc2 = this._yText.doc;
    if (!doc2) {
      throw new BlockSuiteError(ErrorCode.ReactiveProxyError, "Failed to transact text! yText is not attached to a doc");
    }
    doc2.transact(() => {
      callback();
    }, doc2.clientID);
  }
  applyDelta(delta) {
    this._transact(() => {
      this._yText?.applyDelta(delta);
    });
  }
  bind(onChange) {
    this._onChange = onChange;
  }
  clear() {
    if (!this._yText.length) {
      return;
    }
    this._transact(() => {
      this._yText.delete(0, this._yText.length);
    });
  }
  clone() {
    return new _Text(this._yText.clone(), this._onChange);
  }
  delete(index, length4) {
    if (length4 === 0) {
      return;
    }
    if (index < 0 || length4 < 0 || index + length4 > this._yText.length) {
      throw new BlockSuiteError(ErrorCode.ReactiveProxyError, "Failed to delete text! Index or length out of range, index: " + index + ", length: " + length4 + ", text length: " + this._yText.length);
    }
    this._transact(() => {
      this._yText.delete(index, length4);
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  format(index, length4, format) {
    if (length4 === 0) {
      return;
    }
    if (index < 0 || length4 < 0 || index + length4 > this._yText.length) {
      throw new BlockSuiteError(ErrorCode.ReactiveProxyError, "Failed to format text! Index or length out of range, index: " + index + ", length: " + length4 + ", text length: " + this._yText.length);
    }
    this._transact(() => {
      this._yText.format(index, length4, format);
    });
  }
  insert(content, index, attributes) {
    if (!content.length) {
      return;
    }
    if (index < 0 || index > this._yText.length) {
      throw new BlockSuiteError(ErrorCode.ReactiveProxyError, "Failed to insert text! Index or length out of range, index: " + index + ", length: " + length + ", text length: " + this._yText.length);
    }
    this._transact(() => {
      this._yText.insert(index, content, attributes);
    });
  }
  join(other) {
    if (!other || !other.toDelta().length) {
      return;
    }
    this._transact(() => {
      const yOther = other._yText;
      const delta = yOther.toDelta();
      delta.unshift({ retain: this._yText.length });
      this._yText.applyDelta(delta);
    });
  }
  replace(index, length4, content, attributes) {
    if (index < 0 || length4 < 0 || index + length4 > this._yText.length) {
      throw new BlockSuiteError(ErrorCode.ReactiveProxyError, "Failed to replace text! The length of the text is" + this._yText.length + ", but you are trying to replace from" + index + "to" + index + length4);
    }
    this._transact(() => {
      this._yText.delete(index, length4);
      this._yText.insert(index, content, attributes);
    });
  }
  sliceToDelta(begin, end) {
    const result = [];
    if (end && begin >= end) {
      return result;
    }
    if (begin === 0 && end === 0) {
      return [];
    }
    const delta = this.toDelta();
    if (begin < 1 && !end) {
      return delta;
    }
    if (delta && delta instanceof Array) {
      let charNum = 0;
      for (let i2 = 0; i2 < delta.length; i2++) {
        const content = delta[i2];
        let contentText = content.insert || "";
        const contentLen = contentText.length;
        const isLastOp = end && charNum + contentLen > end;
        const isFirstOp = charNum + contentLen > begin && result.length === 0;
        if (isFirstOp && isLastOp) {
          contentText = contentText.slice(begin - charNum, end - charNum);
          result.push({
            ...content,
            insert: contentText
          });
          break;
        } else if (isFirstOp || isLastOp) {
          contentText = isLastOp ? contentText.slice(0, end - charNum) : contentText.slice(begin - charNum);
          result.push({
            ...content,
            insert: contentText
          });
        } else {
          result.length > 0 && result.push(content);
        }
        if (end && charNum + contentLen > end) {
          break;
        }
        charNum = charNum + contentLen;
      }
    }
    return result;
  }
  /**
   * NOTE: The string included in [index, index + length) will be deleted.
   *
   * Here are three cases for point position(index + length):
   * [{insert: 'abc', ...}, {insert: 'def', ...}, {insert: 'ghi', ...}]
   * 1. abc|de|fghi
   *    left: [{insert: 'abc', ...}]
   *    right: [{insert: 'f', ...}, {insert: 'ghi', ...}]
   * 2. abc|def|ghi
   *    left: [{insert: 'abc', ...}]
   *    right: [{insert: 'ghi', ...}]
   * 3. abc|defg|hi
   *    left: [{insert: 'abc', ...}]
   *    right: [{insert: 'hi', ...}]
   */
  split(index, length4 = 0) {
    if (index < 0 || length4 < 0 || index + length4 > this._yText.length) {
      throw new BlockSuiteError(ErrorCode.ReactiveProxyError, "Failed to split text! Index or length out of range, index: " + index + ", length: " + length4 + ", text length: " + this._yText.length);
    }
    const deltas = this._yText.toDelta();
    if (!(deltas instanceof Array)) {
      throw new BlockSuiteError(ErrorCode.ReactiveProxyError, "This text cannot be split because we failed to get the deltas of it.");
    }
    let tmpIndex = 0;
    const rightDeltas = [];
    for (let i2 = 0; i2 < deltas.length; i2++) {
      const insert = deltas[i2].insert;
      if (typeof insert === "string") {
        if (tmpIndex + insert.length >= index + length4) {
          const insertRight = insert.slice(index + length4 - tmpIndex);
          rightDeltas.push({
            insert: insertRight,
            attributes: deltas[i2].attributes
          });
          rightDeltas.push(...deltas.slice(i2 + 1));
          break;
        }
        tmpIndex += insert.length;
      } else {
        throw new BlockSuiteError(ErrorCode.ReactiveProxyError, "This text cannot be split because it contains non-string insert.");
      }
    }
    this.delete(index, this.length - index);
    const rightYText = new YText();
    rightYText.applyDelta(rightDeltas);
    const rightText = new _Text(rightYText, this._onChange);
    return rightText;
  }
  toDelta() {
    return this._yText?.toDelta() || [];
  }
  toString() {
    return this._yText?.toString() || "";
  }
};

// node_modules/@blocksuite/store/dist/reactive/utils.js
function isPureObject(value) {
  return value !== null && typeof value === "object" && Object.prototype.toString.call(value) === "[object Object]" && [Object, void 0, null].some((x) => x === value.constructor);
}
function native2Y(value, { deep = true, transform = (x) => x } = {}) {
  if (value instanceof Boxed) {
    return value.yMap;
  }
  if (value instanceof Text) {
    if (value.yText.doc) {
      return value.yText.clone();
    }
    return value.yText;
  }
  if (Array.isArray(value)) {
    const yArray = new YArray();
    const result = value.map((item) => {
      return deep ? native2Y(item, { deep, transform }) : item;
    });
    yArray.insert(0, result);
    return yArray;
  }
  if (isPureObject(value)) {
    const yMap = new YMap();
    Object.entries(value).forEach(([key, value2]) => {
      yMap.set(key, deep ? native2Y(value2, { deep, transform }) : value2);
    });
    return yMap;
  }
  return value;
}
function y2Native(yAbstract, { deep = true, transform = (x) => x } = {}) {
  if (Boxed.is(yAbstract)) {
    const data = new Boxed(yAbstract);
    return transform(data, yAbstract);
  }
  if (yAbstract instanceof YText) {
    const data = new Text(yAbstract);
    return transform(data, yAbstract);
  }
  if (yAbstract instanceof YArray) {
    const data = yAbstract.toArray().map((item) => deep ? y2Native(item, { deep, transform }) : item);
    return transform(data, yAbstract);
  }
  if (yAbstract instanceof YMap) {
    const data = Object.fromEntries(Array.from(yAbstract.entries()).map(([key, value]) => {
      return [key, deep ? y2Native(value, { deep, transform }) : value];
    }));
    return transform(data, yAbstract);
  }
  return transform(yAbstract, yAbstract);
}
var BaseReactiveYData = class {
  constructor() {
    this._getOrigin = (doc2) => {
      return {
        doc: doc2,
        proxy: true,
        target: this
      };
    };
    this._onObserve = (event, handler) => {
      if (event.transaction.origin?.proxy !== true && (!event.transaction.local || event.transaction.origin instanceof UndoManager)) {
        handler();
      }
      this._options.onChange?.(this._proxy);
    };
    this._skipNext = false;
    this._stashed = /* @__PURE__ */ new Set();
    this._transact = (doc2, fn) => {
      doc2.transact(fn, this._getOrigin(doc2));
    };
    this._updateWithSkip = (fn) => {
      this._skipNext = true;
      fn();
      this._skipNext = false;
    };
  }
  get proxy() {
    return this._proxy;
  }
};

// node_modules/@blocksuite/store/dist/reactive/proxy.js
var proxies = /* @__PURE__ */ new WeakMap();
var ReactiveYArray = class extends BaseReactiveYData {
  constructor(_source, _ySource, _options) {
    super();
    this._source = _source;
    this._ySource = _ySource;
    this._options = _options;
    this._observer = (event) => {
      this._onObserve(event, () => {
        let retain = 0;
        event.changes.delta.forEach((change) => {
          if (change.retain) {
            retain += change.retain;
            return;
          }
          if (change.delete) {
            this._updateWithSkip(() => {
              this._source.splice(retain, change.delete);
            });
            return;
          }
          if (change.insert) {
            const _arr = [change.insert].flat();
            const proxyList = _arr.map((value) => createYProxy(value));
            this._updateWithSkip(() => {
              this._source.splice(retain, 0, ...proxyList);
            });
            retain += change.insert.length;
          }
        });
      });
    };
    this._getProxy = () => {
      return new Proxy(this._source, {
        has: (target, p2) => {
          return Reflect.has(target, p2);
        },
        set: (target, p2, value, receiver) => {
          if (typeof p2 !== "string") {
            throw new BlockSuiteError(ErrorCode.ReactiveProxyError, "key cannot be a symbol");
          }
          const index = Number(p2);
          if (this._skipNext || Number.isNaN(index)) {
            return Reflect.set(target, p2, value, receiver);
          }
          if (this._stashed.has(index)) {
            const result = Reflect.set(target, p2, value, receiver);
            this._options.onChange?.(this._proxy);
            return result;
          }
          const reactive = proxies.get(this._ySource);
          if (!reactive) {
            throw new BlockSuiteError(ErrorCode.ReactiveProxyError, "YData is not subscribed before changes");
          }
          const doc2 = this._ySource.doc;
          if (!doc2) {
            throw new BlockSuiteError(ErrorCode.ReactiveProxyError, "YData is not bound to a Y.Doc");
          }
          const yData = native2Y(value);
          this._transact(doc2, () => {
            if (index < this._ySource.length) {
              this._ySource.delete(index, 1);
            }
            this._ySource.insert(index, [yData]);
          });
          const data = createYProxy(yData, this._options);
          return Reflect.set(target, p2, data, receiver);
        },
        get: (target, p2, receiver) => {
          return Reflect.get(target, p2, receiver);
        },
        deleteProperty: (target, p2) => {
          if (typeof p2 !== "string") {
            throw new BlockSuiteError(ErrorCode.ReactiveProxyError, "key cannot be a symbol");
          }
          const proxied = proxies.get(this._ySource);
          if (!proxied) {
            throw new BlockSuiteError(ErrorCode.ReactiveProxyError, "YData is not subscribed before changes");
          }
          const doc2 = this._ySource.doc;
          if (!doc2) {
            throw new BlockSuiteError(ErrorCode.ReactiveProxyError, "YData is not bound to a Y.Doc");
          }
          const index = Number(p2);
          if (this._skipNext || Number.isNaN(index)) {
            return Reflect.deleteProperty(target, p2);
          }
          this._transact(doc2, () => {
            this._ySource.delete(index, 1);
          });
          return Reflect.deleteProperty(target, p2);
        }
      });
    };
    this._proxy = this._getProxy();
    proxies.set(_ySource, this);
    _ySource.observe(this._observer);
  }
  pop(prop) {
    const value = this._source[prop];
    this._stashed.delete(prop);
    this._proxy[prop] = value;
  }
  stash(prop) {
    this._stashed.add(prop);
  }
};
var ReactiveYMap = class extends BaseReactiveYData {
  constructor(_source, _ySource, _options) {
    super();
    this._source = _source;
    this._ySource = _ySource;
    this._options = _options;
    this._observer = (event) => {
      this._onObserve(event, () => {
        event.keysChanged.forEach((key) => {
          const type = event.changes.keys.get(key);
          if (!type) {
            return;
          }
          if (type.action === "delete") {
            this._updateWithSkip(() => {
              delete this._source[key];
            });
          } else if (type.action === "add" || type.action === "update") {
            const current = this._ySource.get(key);
            this._updateWithSkip(() => {
              this._source[key] = proxies.has(current) ? proxies.get(current) : createYProxy(current, this._options);
            });
          }
        });
      });
    };
    this._getProxy = () => {
      return new Proxy(this._source, {
        has: (target, p2) => {
          return Reflect.has(target, p2);
        },
        set: (target, p2, value, receiver) => {
          if (typeof p2 !== "string") {
            throw new BlockSuiteError(ErrorCode.ReactiveProxyError, "key cannot be a symbol");
          }
          if (this._skipNext) {
            return Reflect.set(target, p2, value, receiver);
          }
          if (this._stashed.has(p2)) {
            const result = Reflect.set(target, p2, value, receiver);
            this._options.onChange?.(this._proxy);
            return result;
          }
          const reactive = proxies.get(this._ySource);
          if (!reactive) {
            throw new BlockSuiteError(ErrorCode.ReactiveProxyError, "YData is not subscribed before changes");
          }
          const doc2 = this._ySource.doc;
          if (!doc2) {
            throw new BlockSuiteError(ErrorCode.ReactiveProxyError, "YData is not bound to a Y.Doc");
          }
          const yData = native2Y(value);
          this._transact(doc2, () => {
            this._ySource.set(p2, yData);
          });
          const data = createYProxy(yData, this._options);
          return Reflect.set(target, p2, data, receiver);
        },
        get: (target, p2, receiver) => {
          return Reflect.get(target, p2, receiver);
        },
        deleteProperty: (target, p2) => {
          if (typeof p2 !== "string") {
            throw new BlockSuiteError(ErrorCode.ReactiveProxyError, "key cannot be a symbol");
          }
          if (this._skipNext) {
            return Reflect.deleteProperty(target, p2);
          }
          const proxied = proxies.get(this._ySource);
          if (!proxied) {
            throw new BlockSuiteError(ErrorCode.ReactiveProxyError, "YData is not subscribed before changes");
          }
          const doc2 = this._ySource.doc;
          if (!doc2) {
            throw new BlockSuiteError(ErrorCode.ReactiveProxyError, "YData is not bound to a Y.Doc");
          }
          this._transact(doc2, () => {
            this._ySource.delete(p2);
          });
          return Reflect.deleteProperty(target, p2);
        }
      });
    };
    this._proxy = this._getProxy();
    proxies.set(_ySource, this);
    _ySource.observe(this._observer);
  }
  pop(prop) {
    const value = this._source[prop];
    this._stashed.delete(prop);
    this._proxy[prop] = value;
  }
  stash(prop) {
    this._stashed.add(prop);
  }
};
function createYProxy(yAbstract, options = {}) {
  if (proxies.has(yAbstract)) {
    return proxies.get(yAbstract).proxy;
  }
  return y2Native(yAbstract, {
    transform: (value, origin) => {
      if (value instanceof Text) {
        value.bind(options.onChange);
        return value;
      }
      if (Boxed.is(origin)) {
        value.bind(options.onChange);
        return value;
      }
      if (origin instanceof YArray) {
        const data = new ReactiveYArray(value, origin, options);
        return data.proxy;
      }
      if (origin instanceof YMap) {
        const data = new ReactiveYMap(value, origin, options);
        return data.proxy;
      }
      return value;
    }
  });
}
function stashProp(yAbstract, prop) {
  const proxy = proxies.get(yAbstract);
  if (!proxy) {
    throw new BlockSuiteError(ErrorCode.ReactiveProxyError, "YData is not subscribed before changes");
  }
  proxy.stash(prop);
}
function popProp(yAbstract, prop) {
  const proxy = proxies.get(yAbstract);
  if (!proxy) {
    throw new BlockSuiteError(ErrorCode.ReactiveProxyError, "YData is not subscribed before changes");
  }
  proxy.pop(prop);
}

// node_modules/@blocksuite/store/dist/schema/base.js
var _a;
var FlavourSchema = external_exports.string();
var ParentSchema = external_exports.array(external_exports.string()).optional();
var ContentSchema = external_exports.array(external_exports.string()).optional();
var role = ["root", "hub", "content"];
var RoleSchema = external_exports.enum(role);
var internalPrimitives = Object.freeze({
  Text: (input = "") => new Text(input),
  Boxed: (input) => new Boxed(input)
});
var BlockSchema = external_exports.object({
  version: external_exports.number(),
  model: external_exports.object({
    role: RoleSchema,
    flavour: FlavourSchema,
    parent: ParentSchema,
    children: ContentSchema,
    props: external_exports.function().args(external_exports.custom()).returns(external_exports.record(external_exports.any())).optional(),
    toModel: external_exports.function().args().returns(external_exports.custom()).optional()
  }),
  transformer: external_exports.function().args().returns(external_exports.custom()).optional()
});
function defineBlockSchema({ flavour, props, metadata, toModel, transformer }) {
  const schema = {
    version: metadata.version,
    model: {
      role: metadata.role,
      parent: metadata.parent,
      children: metadata.children,
      flavour,
      props,
      toModel
    },
    transformer
  };
  BlockSchema.parse(schema);
  return schema;
}
function MagicProps() {
  return class {
  };
}
var modelLabel = Symbol("model_label");
var BlockModel = class extends MagicProps() {
  get children() {
    return this._childModels.value;
  }
  get doc() {
    return this.page;
  }
  set doc(doc2) {
    this.page = doc2;
  }
  get parent() {
    return this.doc.getParent(this);
  }
  constructor() {
    super();
    this._children = d([]);
    this._childModels = w(() => {
      const value = [];
      this._children.value.map((id2) => {
        const block = this.page.getBlock$(id2);
        if (block) {
          value.push(block.model);
        }
      });
      return value;
    });
    this.childMap = w(() => this._children.value.reduce((map3, id2, index) => {
      map3.set(id2, index);
      return map3;
    }, /* @__PURE__ */ new Map()));
    this.created = new Slot();
    this.deleted = new Slot();
    this.isEmpty = w(() => {
      return this._children.value.length === 0;
    });
    this[_a] = "type_info_label";
    this.propsUpdated = new Slot();
    this._onCreated = this.created.once(() => {
      this._children.value = this.yBlock.get("sys:children").toArray();
      this.yBlock.get("sys:children").observe((event) => {
        this._children.value = event.target.toArray();
      });
      this.yBlock.observe((event) => {
        if (event.keysChanged.has("sys:children")) {
          this._children.value = this.yBlock.get("sys:children").toArray();
        }
      });
    });
    this._onDeleted = this.deleted.once(() => {
      this._onCreated.dispose();
    });
  }
  dispose() {
    this.created.dispose();
    this.deleted.dispose();
    this.propsUpdated.dispose();
  }
  firstChild() {
    return this.children[0] || null;
  }
  lastChild() {
    if (!this.children.length) {
      return this;
    }
    return this.children[this.children.length - 1].lastChild();
  }
  [(_a = modelLabel, Symbol.dispose)]() {
    this._onCreated.dispose();
    this._onDeleted.dispose();
  }
};

// node_modules/@isaacs/balanced-match/dist/esm/index.js
var balanced = (a2, b2, str) => {
  const ma = a2 instanceof RegExp ? maybeMatch(a2, str) : a2;
  const mb = b2 instanceof RegExp ? maybeMatch(b2, str) : b2;
  const r = ma !== null && mb != null && range(ma, mb, str);
  return r && {
    start: r[0],
    end: r[1],
    pre: str.slice(0, r[0]),
    body: str.slice(r[0] + ma.length, r[1]),
    post: str.slice(r[1] + mb.length)
  };
};
var maybeMatch = (reg, str) => {
  const m = str.match(reg);
  return m ? m[0] : null;
};
var range = (a2, b2, str) => {
  let begs, beg, left, right = void 0, result;
  let ai = str.indexOf(a2);
  let bi = str.indexOf(b2, ai + 1);
  let i2 = ai;
  if (ai >= 0 && bi > 0) {
    if (a2 === b2) {
      return [ai, bi];
    }
    begs = [];
    left = str.length;
    while (i2 >= 0 && !result) {
      if (i2 === ai) {
        begs.push(i2);
        ai = str.indexOf(a2, i2 + 1);
      } else if (begs.length === 1) {
        const r = begs.pop();
        if (r !== void 0)
          result = [r, bi];
      } else {
        beg = begs.pop();
        if (beg !== void 0 && beg < left) {
          left = beg;
          right = bi;
        }
        bi = str.indexOf(b2, i2 + 1);
      }
      i2 = ai < bi && ai >= 0 ? ai : bi;
    }
    if (begs.length && right !== void 0) {
      result = [left, right];
    }
  }
  return result;
};

// node_modules/@isaacs/brace-expansion/dist/esm/index.js
var escSlash = "\0SLASH" + Math.random() + "\0";
var escOpen = "\0OPEN" + Math.random() + "\0";
var escClose = "\0CLOSE" + Math.random() + "\0";
var escComma = "\0COMMA" + Math.random() + "\0";
var escPeriod = "\0PERIOD" + Math.random() + "\0";
var escSlashPattern = new RegExp(escSlash, "g");
var escOpenPattern = new RegExp(escOpen, "g");
var escClosePattern = new RegExp(escClose, "g");
var escCommaPattern = new RegExp(escComma, "g");
var escPeriodPattern = new RegExp(escPeriod, "g");
var slashPattern = /\\\\/g;
var openPattern = /\\{/g;
var closePattern = /\\}/g;
var commaPattern = /\\,/g;
var periodPattern = /\\./g;
function numeric(str) {
  return !isNaN(str) ? parseInt(str, 10) : str.charCodeAt(0);
}
function escapeBraces(str) {
  return str.replace(slashPattern, escSlash).replace(openPattern, escOpen).replace(closePattern, escClose).replace(commaPattern, escComma).replace(periodPattern, escPeriod);
}
function unescapeBraces(str) {
  return str.replace(escSlashPattern, "\\").replace(escOpenPattern, "{").replace(escClosePattern, "}").replace(escCommaPattern, ",").replace(escPeriodPattern, ".");
}
function parseCommaParts(str) {
  if (!str) {
    return [""];
  }
  const parts = [];
  const m = balanced("{", "}", str);
  if (!m) {
    return str.split(",");
  }
  const { pre, body, post } = m;
  const p2 = pre.split(",");
  p2[p2.length - 1] += "{" + body + "}";
  const postParts = parseCommaParts(post);
  if (post.length) {
    ;
    p2[p2.length - 1] += postParts.shift();
    p2.push.apply(p2, postParts);
  }
  parts.push.apply(parts, p2);
  return parts;
}
function expand(str) {
  if (!str) {
    return [];
  }
  if (str.slice(0, 2) === "{}") {
    str = "\\{\\}" + str.slice(2);
  }
  return expand_(escapeBraces(str), true).map(unescapeBraces);
}
function embrace(str) {
  return "{" + str + "}";
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}
function lte(i2, y2) {
  return i2 <= y2;
}
function gte(i2, y2) {
  return i2 >= y2;
}
function expand_(str, isTop) {
  const expansions = [];
  const m = balanced("{", "}", str);
  if (!m)
    return [str];
  const pre = m.pre;
  const post = m.post.length ? expand_(m.post, false) : [""];
  if (/\$$/.test(m.pre)) {
    for (let k = 0; k < post.length; k++) {
      const expansion = pre + "{" + m.body + "}" + post[k];
      expansions.push(expansion);
    }
  } else {
    const isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
    const isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
    const isSequence = isNumericSequence || isAlphaSequence;
    const isOptions = m.body.indexOf(",") >= 0;
    if (!isSequence && !isOptions) {
      if (m.post.match(/,(?!,).*\}/)) {
        str = m.pre + "{" + m.body + escClose + m.post;
        return expand_(str);
      }
      return [str];
    }
    let n2;
    if (isSequence) {
      n2 = m.body.split(/\.\./);
    } else {
      n2 = parseCommaParts(m.body);
      if (n2.length === 1 && n2[0] !== void 0) {
        n2 = expand_(n2[0], false).map(embrace);
        if (n2.length === 1) {
          return post.map((p2) => m.pre + n2[0] + p2);
        }
      }
    }
    let N;
    if (isSequence && n2[0] !== void 0 && n2[1] !== void 0) {
      const x = numeric(n2[0]);
      const y2 = numeric(n2[1]);
      const width = Math.max(n2[0].length, n2[1].length);
      let incr = n2.length === 3 && n2[2] !== void 0 ? Math.abs(numeric(n2[2])) : 1;
      let test2 = lte;
      const reverse = y2 < x;
      if (reverse) {
        incr *= -1;
        test2 = gte;
      }
      const pad = n2.some(isPadded);
      N = [];
      for (let i2 = x; test2(i2, y2); i2 += incr) {
        let c2;
        if (isAlphaSequence) {
          c2 = String.fromCharCode(i2);
          if (c2 === "\\") {
            c2 = "";
          }
        } else {
          c2 = String(i2);
          if (pad) {
            const need = width - c2.length;
            if (need > 0) {
              const z = new Array(need + 1).join("0");
              if (i2 < 0) {
                c2 = "-" + z + c2.slice(1);
              } else {
                c2 = z + c2;
              }
            }
          }
        }
        N.push(c2);
      }
    } else {
      N = [];
      for (let j = 0; j < n2.length; j++) {
        N.push.apply(N, expand_(n2[j], false));
      }
    }
    for (let j = 0; j < N.length; j++) {
      for (let k = 0; k < post.length; k++) {
        const expansion = pre + N[j] + post[k];
        if (!isTop || isSequence || expansion) {
          expansions.push(expansion);
        }
      }
    }
  }
  return expansions;
}

// node_modules/minimatch/dist/esm/assert-valid-pattern.js
var MAX_PATTERN_LENGTH = 1024 * 64;
var assertValidPattern = (pattern) => {
  if (typeof pattern !== "string") {
    throw new TypeError("invalid pattern");
  }
  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new TypeError("pattern is too long");
  }
};

// node_modules/minimatch/dist/esm/brace-expressions.js
var posixClasses = {
  "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", true],
  "[:alpha:]": ["\\p{L}\\p{Nl}", true],
  "[:ascii:]": ["\\x00-\\x7f", false],
  "[:blank:]": ["\\p{Zs}\\t", true],
  "[:cntrl:]": ["\\p{Cc}", true],
  "[:digit:]": ["\\p{Nd}", true],
  "[:graph:]": ["\\p{Z}\\p{C}", true, true],
  "[:lower:]": ["\\p{Ll}", true],
  "[:print:]": ["\\p{C}", true],
  "[:punct:]": ["\\p{P}", true],
  "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", true],
  "[:upper:]": ["\\p{Lu}", true],
  "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", true],
  "[:xdigit:]": ["A-Fa-f0-9", false]
};
var braceEscape = (s2) => s2.replace(/[[\]\\-]/g, "\\$&");
var regexpEscape = (s2) => s2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var rangesToString = (ranges) => ranges.join("");
var parseClass = (glob, position) => {
  const pos = position;
  if (glob.charAt(pos) !== "[") {
    throw new Error("not in a brace expression");
  }
  const ranges = [];
  const negs = [];
  let i2 = pos + 1;
  let sawStart = false;
  let uflag = false;
  let escaping = false;
  let negate = false;
  let endPos = pos;
  let rangeStart = "";
  WHILE: while (i2 < glob.length) {
    const c2 = glob.charAt(i2);
    if ((c2 === "!" || c2 === "^") && i2 === pos + 1) {
      negate = true;
      i2++;
      continue;
    }
    if (c2 === "]" && sawStart && !escaping) {
      endPos = i2 + 1;
      break;
    }
    sawStart = true;
    if (c2 === "\\") {
      if (!escaping) {
        escaping = true;
        i2++;
        continue;
      }
    }
    if (c2 === "[" && !escaping) {
      for (const [cls, [unip, u2, neg2]] of Object.entries(posixClasses)) {
        if (glob.startsWith(cls, i2)) {
          if (rangeStart) {
            return ["$.", false, glob.length - pos, true];
          }
          i2 += cls.length;
          if (neg2)
            negs.push(unip);
          else
            ranges.push(unip);
          uflag = uflag || u2;
          continue WHILE;
        }
      }
    }
    escaping = false;
    if (rangeStart) {
      if (c2 > rangeStart) {
        ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c2));
      } else if (c2 === rangeStart) {
        ranges.push(braceEscape(c2));
      }
      rangeStart = "";
      i2++;
      continue;
    }
    if (glob.startsWith("-]", i2 + 1)) {
      ranges.push(braceEscape(c2 + "-"));
      i2 += 2;
      continue;
    }
    if (glob.startsWith("-", i2 + 1)) {
      rangeStart = c2;
      i2 += 2;
      continue;
    }
    ranges.push(braceEscape(c2));
    i2++;
  }
  if (endPos < i2) {
    return ["", false, 0, false];
  }
  if (!ranges.length && !negs.length) {
    return ["$.", false, glob.length - pos, true];
  }
  if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate) {
    const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
    return [regexpEscape(r), false, endPos - pos, false];
  }
  const sranges = "[" + (negate ? "^" : "") + rangesToString(ranges) + "]";
  const snegs = "[" + (negate ? "" : "^") + rangesToString(negs) + "]";
  const comb = ranges.length && negs.length ? "(" + sranges + "|" + snegs + ")" : ranges.length ? sranges : snegs;
  return [comb, uflag, endPos - pos, true];
};

// node_modules/minimatch/dist/esm/unescape.js
var unescape2 = (s2, { windowsPathsNoEscape = false, magicalBraces = true } = {}) => {
  if (magicalBraces) {
    return windowsPathsNoEscape ? s2.replace(/\[([^\/\\])\]/g, "$1") : s2.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");
  }
  return windowsPathsNoEscape ? s2.replace(/\[([^\/\\{}])\]/g, "$1") : s2.replace(/((?!\\).|^)\[([^\/\\{}])\]/g, "$1$2").replace(/\\([^\/{}])/g, "$1");
};

// node_modules/minimatch/dist/esm/ast.js
var types = /* @__PURE__ */ new Set(["!", "?", "+", "*", "@"]);
var isExtglobType = (c2) => types.has(c2);
var startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))";
var startNoDot = "(?!\\.)";
var addPatternStart = /* @__PURE__ */ new Set(["[", "."]);
var justDots = /* @__PURE__ */ new Set(["..", "."]);
var reSpecials = new Set("().*{}+?[]^$\\!");
var regExpEscape = (s2) => s2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var qmark = "[^/]";
var star = qmark + "*?";
var starNoEmpty = qmark + "+?";
var AST = class _AST {
  type;
  #root;
  #hasMagic;
  #uflag = false;
  #parts = [];
  #parent;
  #parentIndex;
  #negs;
  #filledNegs = false;
  #options;
  #toString;
  // set to true if it's an extglob with no children
  // (which really means one child of '')
  #emptyExt = false;
  constructor(type, parent, options = {}) {
    this.type = type;
    if (type)
      this.#hasMagic = true;
    this.#parent = parent;
    this.#root = this.#parent ? this.#parent.#root : this;
    this.#options = this.#root === this ? options : this.#root.#options;
    this.#negs = this.#root === this ? [] : this.#root.#negs;
    if (type === "!" && !this.#root.#filledNegs)
      this.#negs.push(this);
    this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
  }
  get hasMagic() {
    if (this.#hasMagic !== void 0)
      return this.#hasMagic;
    for (const p2 of this.#parts) {
      if (typeof p2 === "string")
        continue;
      if (p2.type || p2.hasMagic)
        return this.#hasMagic = true;
    }
    return this.#hasMagic;
  }
  // reconstructs the pattern
  toString() {
    if (this.#toString !== void 0)
      return this.#toString;
    if (!this.type) {
      return this.#toString = this.#parts.map((p2) => String(p2)).join("");
    } else {
      return this.#toString = this.type + "(" + this.#parts.map((p2) => String(p2)).join("|") + ")";
    }
  }
  #fillNegs() {
    if (this !== this.#root)
      throw new Error("should only call on root");
    if (this.#filledNegs)
      return this;
    this.toString();
    this.#filledNegs = true;
    let n2;
    while (n2 = this.#negs.pop()) {
      if (n2.type !== "!")
        continue;
      let p2 = n2;
      let pp = p2.#parent;
      while (pp) {
        for (let i2 = p2.#parentIndex + 1; !pp.type && i2 < pp.#parts.length; i2++) {
          for (const part of n2.#parts) {
            if (typeof part === "string") {
              throw new Error("string part in extglob AST??");
            }
            part.copyIn(pp.#parts[i2]);
          }
        }
        p2 = pp;
        pp = p2.#parent;
      }
    }
    return this;
  }
  push(...parts) {
    for (const p2 of parts) {
      if (p2 === "")
        continue;
      if (typeof p2 !== "string" && !(p2 instanceof _AST && p2.#parent === this)) {
        throw new Error("invalid part: " + p2);
      }
      this.#parts.push(p2);
    }
  }
  toJSON() {
    const ret = this.type === null ? this.#parts.slice().map((p2) => typeof p2 === "string" ? p2 : p2.toJSON()) : [this.type, ...this.#parts.map((p2) => p2.toJSON())];
    if (this.isStart() && !this.type)
      ret.unshift([]);
    if (this.isEnd() && (this === this.#root || this.#root.#filledNegs && this.#parent?.type === "!")) {
      ret.push({});
    }
    return ret;
  }
  isStart() {
    if (this.#root === this)
      return true;
    if (!this.#parent?.isStart())
      return false;
    if (this.#parentIndex === 0)
      return true;
    const p2 = this.#parent;
    for (let i2 = 0; i2 < this.#parentIndex; i2++) {
      const pp = p2.#parts[i2];
      if (!(pp instanceof _AST && pp.type === "!")) {
        return false;
      }
    }
    return true;
  }
  isEnd() {
    if (this.#root === this)
      return true;
    if (this.#parent?.type === "!")
      return true;
    if (!this.#parent?.isEnd())
      return false;
    if (!this.type)
      return this.#parent?.isEnd();
    const pl = this.#parent ? this.#parent.#parts.length : 0;
    return this.#parentIndex === pl - 1;
  }
  copyIn(part) {
    if (typeof part === "string")
      this.push(part);
    else
      this.push(part.clone(this));
  }
  clone(parent) {
    const c2 = new _AST(this.type, parent);
    for (const p2 of this.#parts) {
      c2.copyIn(p2);
    }
    return c2;
  }
  static #parseAST(str, ast, pos, opt) {
    let escaping = false;
    let inBrace = false;
    let braceStart = -1;
    let braceNeg = false;
    if (ast.type === null) {
      let i3 = pos;
      let acc2 = "";
      while (i3 < str.length) {
        const c2 = str.charAt(i3++);
        if (escaping || c2 === "\\") {
          escaping = !escaping;
          acc2 += c2;
          continue;
        }
        if (inBrace) {
          if (i3 === braceStart + 1) {
            if (c2 === "^" || c2 === "!") {
              braceNeg = true;
            }
          } else if (c2 === "]" && !(i3 === braceStart + 2 && braceNeg)) {
            inBrace = false;
          }
          acc2 += c2;
          continue;
        } else if (c2 === "[") {
          inBrace = true;
          braceStart = i3;
          braceNeg = false;
          acc2 += c2;
          continue;
        }
        if (!opt.noext && isExtglobType(c2) && str.charAt(i3) === "(") {
          ast.push(acc2);
          acc2 = "";
          const ext2 = new _AST(c2, ast);
          i3 = _AST.#parseAST(str, ext2, i3, opt);
          ast.push(ext2);
          continue;
        }
        acc2 += c2;
      }
      ast.push(acc2);
      return i3;
    }
    let i2 = pos + 1;
    let part = new _AST(null, ast);
    const parts = [];
    let acc = "";
    while (i2 < str.length) {
      const c2 = str.charAt(i2++);
      if (escaping || c2 === "\\") {
        escaping = !escaping;
        acc += c2;
        continue;
      }
      if (inBrace) {
        if (i2 === braceStart + 1) {
          if (c2 === "^" || c2 === "!") {
            braceNeg = true;
          }
        } else if (c2 === "]" && !(i2 === braceStart + 2 && braceNeg)) {
          inBrace = false;
        }
        acc += c2;
        continue;
      } else if (c2 === "[") {
        inBrace = true;
        braceStart = i2;
        braceNeg = false;
        acc += c2;
        continue;
      }
      if (isExtglobType(c2) && str.charAt(i2) === "(") {
        part.push(acc);
        acc = "";
        const ext2 = new _AST(c2, part);
        part.push(ext2);
        i2 = _AST.#parseAST(str, ext2, i2, opt);
        continue;
      }
      if (c2 === "|") {
        part.push(acc);
        acc = "";
        parts.push(part);
        part = new _AST(null, ast);
        continue;
      }
      if (c2 === ")") {
        if (acc === "" && ast.#parts.length === 0) {
          ast.#emptyExt = true;
        }
        part.push(acc);
        acc = "";
        ast.push(...parts, part);
        return i2;
      }
      acc += c2;
    }
    ast.type = null;
    ast.#hasMagic = void 0;
    ast.#parts = [str.substring(pos - 1)];
    return i2;
  }
  static fromGlob(pattern, options = {}) {
    const ast = new _AST(null, void 0, options);
    _AST.#parseAST(pattern, ast, 0, options);
    return ast;
  }
  // returns the regular expression if there's magic, or the unescaped
  // string if not.
  toMMPattern() {
    if (this !== this.#root)
      return this.#root.toMMPattern();
    const glob = this.toString();
    const [re, body, hasMagic, uflag] = this.toRegExpSource();
    const anyMagic = hasMagic || this.#hasMagic || this.#options.nocase && !this.#options.nocaseMagicOnly && glob.toUpperCase() !== glob.toLowerCase();
    if (!anyMagic) {
      return body;
    }
    const flags = (this.#options.nocase ? "i" : "") + (uflag ? "u" : "");
    return Object.assign(new RegExp(`^${re}$`, flags), {
      _src: re,
      _glob: glob
    });
  }
  get options() {
    return this.#options;
  }
  // returns the string match, the regexp source, whether there's magic
  // in the regexp (so a regular expression is required) and whether or
  // not the uflag is needed for the regular expression (for posix classes)
  // TODO: instead of injecting the start/end at this point, just return
  // the BODY of the regexp, along with the start/end portions suitable
  // for binding the start/end in either a joined full-path makeRe context
  // (where we bind to (^|/), or a standalone matchPart context (where
  // we bind to ^, and not /).  Otherwise slashes get duped!
  //
  // In part-matching mode, the start is:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: ^(?!\.\.?$)
  // - if dots allowed or not possible: ^
  // - if dots possible and not allowed: ^(?!\.)
  // end is:
  // - if not isEnd(): nothing
  // - else: $
  //
  // In full-path matching mode, we put the slash at the START of the
  // pattern, so start is:
  // - if first pattern: same as part-matching mode
  // - if not isStart(): nothing
  // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
  // - if dots allowed or not possible: /
  // - if dots possible and not allowed: /(?!\.)
  // end is:
  // - if last pattern, same as part-matching mode
  // - else nothing
  //
  // Always put the (?:$|/) on negated tails, though, because that has to be
  // there to bind the end of the negated pattern portion, and it's easier to
  // just stick it in now rather than try to inject it later in the middle of
  // the pattern.
  //
  // We can just always return the same end, and leave it up to the caller
  // to know whether it's going to be used joined or in parts.
  // And, if the start is adjusted slightly, can do the same there:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
  // - if dots allowed or not possible: (?:/|^)
  // - if dots possible and not allowed: (?:/|^)(?!\.)
  //
  // But it's better to have a simpler binding without a conditional, for
  // performance, so probably better to return both start options.
  //
  // Then the caller just ignores the end if it's not the first pattern,
  // and the start always gets applied.
  //
  // But that's always going to be $ if it's the ending pattern, or nothing,
  // so the caller can just attach $ at the end of the pattern when building.
  //
  // So the todo is:
  // - better detect what kind of start is needed
  // - return both flavors of starting pattern
  // - attach $ at the end of the pattern when creating the actual RegExp
  //
  // Ah, but wait, no, that all only applies to the root when the first pattern
  // is not an extglob. If the first pattern IS an extglob, then we need all
  // that dot prevention biz to live in the extglob portions, because eg
  // +(*|.x*) can match .xy but not .yx.
  //
  // So, return the two flavors if it's #root and the first child is not an
  // AST, otherwise leave it to the child AST to handle it, and there,
  // use the (?:^|/) style of start binding.
  //
  // Even simplified further:
  // - Since the start for a join is eg /(?!\.) and the start for a part
  // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
  // or start or whatever) and prepend ^ or / at the Regexp construction.
  toRegExpSource(allowDot) {
    const dot = allowDot ?? !!this.#options.dot;
    if (this.#root === this)
      this.#fillNegs();
    if (!this.type) {
      const noEmpty = this.isStart() && this.isEnd() && !this.#parts.some((s2) => typeof s2 !== "string");
      const src = this.#parts.map((p2) => {
        const [re, _2, hasMagic, uflag] = typeof p2 === "string" ? _AST.#parseGlob(p2, this.#hasMagic, noEmpty) : p2.toRegExpSource(allowDot);
        this.#hasMagic = this.#hasMagic || hasMagic;
        this.#uflag = this.#uflag || uflag;
        return re;
      }).join("");
      let start2 = "";
      if (this.isStart()) {
        if (typeof this.#parts[0] === "string") {
          const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);
          if (!dotTravAllowed) {
            const aps = addPatternStart;
            const needNoTrav = (
              // dots are allowed, and the pattern starts with [ or .
              dot && aps.has(src.charAt(0)) || // the pattern starts with \., and then [ or .
              src.startsWith("\\.") && aps.has(src.charAt(2)) || // the pattern starts with \.\., and then [ or .
              src.startsWith("\\.\\.") && aps.has(src.charAt(4))
            );
            const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
            start2 = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : "";
          }
        }
      }
      let end = "";
      if (this.isEnd() && this.#root.#filledNegs && this.#parent?.type === "!") {
        end = "(?:$|\\/)";
      }
      const final2 = start2 + src + end;
      return [
        final2,
        unescape2(src),
        this.#hasMagic = !!this.#hasMagic,
        this.#uflag
      ];
    }
    const repeated = this.type === "*" || this.type === "+";
    const start = this.type === "!" ? "(?:(?!(?:" : "(?:";
    let body = this.#partsToRegExp(dot);
    if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
      const s2 = this.toString();
      this.#parts = [s2];
      this.type = null;
      this.#hasMagic = void 0;
      return [s2, unescape2(this.toString()), false, false];
    }
    let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? "" : this.#partsToRegExp(true);
    if (bodyDotAllowed === body) {
      bodyDotAllowed = "";
    }
    if (bodyDotAllowed) {
      body = `(?:${body})(?:${bodyDotAllowed})*?`;
    }
    let final = "";
    if (this.type === "!" && this.#emptyExt) {
      final = (this.isStart() && !dot ? startNoDot : "") + starNoEmpty;
    } else {
      const close = this.type === "!" ? (
        // !() must match something,but !(x) can match ''
        "))" + (this.isStart() && !dot && !allowDot ? startNoDot : "") + star + ")"
      ) : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && bodyDotAllowed ? ")" : this.type === "*" && bodyDotAllowed ? `)?` : `)${this.type}`;
      final = start + body + close;
    }
    return [
      final,
      unescape2(body),
      this.#hasMagic = !!this.#hasMagic,
      this.#uflag
    ];
  }
  #partsToRegExp(dot) {
    return this.#parts.map((p2) => {
      if (typeof p2 === "string") {
        throw new Error("string type in extglob ast??");
      }
      const [re, _2, _hasMagic, uflag] = p2.toRegExpSource(dot);
      this.#uflag = this.#uflag || uflag;
      return re;
    }).filter((p2) => !(this.isStart() && this.isEnd()) || !!p2).join("|");
  }
  static #parseGlob(glob, hasMagic, noEmpty = false) {
    let escaping = false;
    let re = "";
    let uflag = false;
    for (let i2 = 0; i2 < glob.length; i2++) {
      const c2 = glob.charAt(i2);
      if (escaping) {
        escaping = false;
        re += (reSpecials.has(c2) ? "\\" : "") + c2;
        continue;
      }
      if (c2 === "\\") {
        if (i2 === glob.length - 1) {
          re += "\\\\";
        } else {
          escaping = true;
        }
        continue;
      }
      if (c2 === "[") {
        const [src, needUflag, consumed, magic] = parseClass(glob, i2);
        if (consumed) {
          re += src;
          uflag = uflag || needUflag;
          i2 += consumed - 1;
          hasMagic = hasMagic || magic;
          continue;
        }
      }
      if (c2 === "*") {
        re += noEmpty && glob === "*" ? starNoEmpty : star;
        hasMagic = true;
        continue;
      }
      if (c2 === "?") {
        re += qmark;
        hasMagic = true;
        continue;
      }
      re += regExpEscape(c2);
    }
    return [re, unescape2(glob), !!hasMagic, uflag];
  }
};

// node_modules/minimatch/dist/esm/escape.js
var escape2 = (s2, { windowsPathsNoEscape = false, magicalBraces = false } = {}) => {
  if (magicalBraces) {
    return windowsPathsNoEscape ? s2.replace(/[?*()[\]{}]/g, "[$&]") : s2.replace(/[?*()[\]\\{}]/g, "\\$&");
  }
  return windowsPathsNoEscape ? s2.replace(/[?*()[\]]/g, "[$&]") : s2.replace(/[?*()[\]\\]/g, "\\$&");
};

// node_modules/minimatch/dist/esm/index.js
var minimatch = (p2, pattern, options = {}) => {
  assertValidPattern(pattern);
  if (!options.nocomment && pattern.charAt(0) === "#") {
    return false;
  }
  return new Minimatch(pattern, options).match(p2);
};
var starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
var starDotExtTest = (ext2) => (f2) => !f2.startsWith(".") && f2.endsWith(ext2);
var starDotExtTestDot = (ext2) => (f2) => f2.endsWith(ext2);
var starDotExtTestNocase = (ext2) => {
  ext2 = ext2.toLowerCase();
  return (f2) => !f2.startsWith(".") && f2.toLowerCase().endsWith(ext2);
};
var starDotExtTestNocaseDot = (ext2) => {
  ext2 = ext2.toLowerCase();
  return (f2) => f2.toLowerCase().endsWith(ext2);
};
var starDotStarRE = /^\*+\.\*+$/;
var starDotStarTest = (f2) => !f2.startsWith(".") && f2.includes(".");
var starDotStarTestDot = (f2) => f2 !== "." && f2 !== ".." && f2.includes(".");
var dotStarRE = /^\.\*+$/;
var dotStarTest = (f2) => f2 !== "." && f2 !== ".." && f2.startsWith(".");
var starRE = /^\*+$/;
var starTest = (f2) => f2.length !== 0 && !f2.startsWith(".");
var starTestDot = (f2) => f2.length !== 0 && f2 !== "." && f2 !== "..";
var qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
var qmarksTestNocase = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExt([$0]);
  if (!ext2)
    return noext;
  ext2 = ext2.toLowerCase();
  return (f2) => noext(f2) && f2.toLowerCase().endsWith(ext2);
};
var qmarksTestNocaseDot = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExtDot([$0]);
  if (!ext2)
    return noext;
  ext2 = ext2.toLowerCase();
  return (f2) => noext(f2) && f2.toLowerCase().endsWith(ext2);
};
var qmarksTestDot = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExtDot([$0]);
  return !ext2 ? noext : (f2) => noext(f2) && f2.endsWith(ext2);
};
var qmarksTest = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExt([$0]);
  return !ext2 ? noext : (f2) => noext(f2) && f2.endsWith(ext2);
};
var qmarksTestNoExt = ([$0]) => {
  const len3 = $0.length;
  return (f2) => f2.length === len3 && !f2.startsWith(".");
};
var qmarksTestNoExtDot = ([$0]) => {
  const len3 = $0.length;
  return (f2) => f2.length === len3 && f2 !== "." && f2 !== "..";
};
var defaultPlatform = typeof process === "object" && process ? typeof process.env === "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix";
var path = {
  win32: { sep: "\\" },
  posix: { sep: "/" }
};
var sep = defaultPlatform === "win32" ? path.win32.sep : path.posix.sep;
minimatch.sep = sep;
var GLOBSTAR = Symbol("globstar **");
minimatch.GLOBSTAR = GLOBSTAR;
var qmark2 = "[^/]";
var star2 = qmark2 + "*?";
var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
var filter = (pattern, options = {}) => (p2) => minimatch(p2, pattern, options);
minimatch.filter = filter;
var ext = (a2, b2 = {}) => Object.assign({}, a2, b2);
var defaults = (def) => {
  if (!def || typeof def !== "object" || !Object.keys(def).length) {
    return minimatch;
  }
  const orig = minimatch;
  const m = (p2, pattern, options = {}) => orig(p2, pattern, ext(def, options));
  return Object.assign(m, {
    Minimatch: class Minimatch extends orig.Minimatch {
      constructor(pattern, options = {}) {
        super(pattern, ext(def, options));
      }
      static defaults(options) {
        return orig.defaults(ext(def, options)).Minimatch;
      }
    },
    AST: class AST extends orig.AST {
      /* c8 ignore start */
      constructor(type, parent, options = {}) {
        super(type, parent, ext(def, options));
      }
      /* c8 ignore stop */
      static fromGlob(pattern, options = {}) {
        return orig.AST.fromGlob(pattern, ext(def, options));
      }
    },
    unescape: (s2, options = {}) => orig.unescape(s2, ext(def, options)),
    escape: (s2, options = {}) => orig.escape(s2, ext(def, options)),
    filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
    defaults: (options) => orig.defaults(ext(def, options)),
    makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
    braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
    match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),
    sep: orig.sep,
    GLOBSTAR
  });
};
minimatch.defaults = defaults;
var braceExpand = (pattern, options = {}) => {
  assertValidPattern(pattern);
  if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    return [pattern];
  }
  return expand(pattern);
};
minimatch.braceExpand = braceExpand;
var makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
minimatch.makeRe = makeRe;
var match = (list, pattern, options = {}) => {
  const mm = new Minimatch(pattern, options);
  list = list.filter((f2) => mm.match(f2));
  if (mm.options.nonull && !list.length) {
    list.push(pattern);
  }
  return list;
};
minimatch.match = match;
var globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
var regExpEscape2 = (s2) => s2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var Minimatch = class {
  options;
  set;
  pattern;
  windowsPathsNoEscape;
  nonegate;
  negate;
  comment;
  empty;
  preserveMultipleSlashes;
  partial;
  globSet;
  globParts;
  nocase;
  isWindows;
  platform;
  windowsNoMagicRoot;
  regexp;
  constructor(pattern, options = {}) {
    assertValidPattern(pattern);
    options = options || {};
    this.options = options;
    this.pattern = pattern;
    this.platform = options.platform || defaultPlatform;
    this.isWindows = this.platform === "win32";
    this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
    if (this.windowsPathsNoEscape) {
      this.pattern = this.pattern.replace(/\\/g, "/");
    }
    this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
    this.regexp = null;
    this.negate = false;
    this.nonegate = !!options.nonegate;
    this.comment = false;
    this.empty = false;
    this.partial = !!options.partial;
    this.nocase = !!this.options.nocase;
    this.windowsNoMagicRoot = options.windowsNoMagicRoot !== void 0 ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase);
    this.globSet = [];
    this.globParts = [];
    this.set = [];
    this.make();
  }
  hasMagic() {
    if (this.options.magicalBraces && this.set.length > 1) {
      return true;
    }
    for (const pattern of this.set) {
      for (const part of pattern) {
        if (typeof part !== "string")
          return true;
      }
    }
    return false;
  }
  debug(..._2) {
  }
  make() {
    const pattern = this.pattern;
    const options = this.options;
    if (!options.nocomment && pattern.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!pattern) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    this.globSet = [...new Set(this.braceExpand())];
    if (options.debug) {
      this.debug = (...args2) => console.error(...args2);
    }
    this.debug(this.pattern, this.globSet);
    const rawGlobParts = this.globSet.map((s2) => this.slashSplit(s2));
    this.globParts = this.preprocess(rawGlobParts);
    this.debug(this.pattern, this.globParts);
    let set2 = this.globParts.map((s2, _2, __) => {
      if (this.isWindows && this.windowsNoMagicRoot) {
        const isUNC = s2[0] === "" && s2[1] === "" && (s2[2] === "?" || !globMagic.test(s2[2])) && !globMagic.test(s2[3]);
        const isDrive = /^[a-z]:/i.test(s2[0]);
        if (isUNC) {
          return [...s2.slice(0, 4), ...s2.slice(4).map((ss) => this.parse(ss))];
        } else if (isDrive) {
          return [s2[0], ...s2.slice(1).map((ss) => this.parse(ss))];
        }
      }
      return s2.map((ss) => this.parse(ss));
    });
    this.debug(this.pattern, set2);
    this.set = set2.filter((s2) => s2.indexOf(false) === -1);
    if (this.isWindows) {
      for (let i2 = 0; i2 < this.set.length; i2++) {
        const p2 = this.set[i2];
        if (p2[0] === "" && p2[1] === "" && this.globParts[i2][2] === "?" && typeof p2[3] === "string" && /^[a-z]:$/i.test(p2[3])) {
          p2[2] = "?";
        }
      }
    }
    this.debug(this.pattern, this.set);
  }
  // various transforms to equivalent pattern sets that are
  // faster to process in a filesystem walk.  The goal is to
  // eliminate what we can, and push all ** patterns as far
  // to the right as possible, even if it increases the number
  // of patterns that we have to process.
  preprocess(globParts) {
    if (this.options.noglobstar) {
      for (let i2 = 0; i2 < globParts.length; i2++) {
        for (let j = 0; j < globParts[i2].length; j++) {
          if (globParts[i2][j] === "**") {
            globParts[i2][j] = "*";
          }
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      globParts = this.firstPhasePreProcess(globParts);
      globParts = this.secondPhasePreProcess(globParts);
    } else if (optimizationLevel >= 1) {
      globParts = this.levelOneOptimize(globParts);
    } else {
      globParts = this.adjascentGlobstarOptimize(globParts);
    }
    return globParts;
  }
  // just get rid of adjascent ** portions
  adjascentGlobstarOptimize(globParts) {
    return globParts.map((parts) => {
      let gs = -1;
      while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
        let i2 = gs;
        while (parts[i2 + 1] === "**") {
          i2++;
        }
        if (i2 !== gs) {
          parts.splice(gs, i2 - gs);
        }
      }
      return parts;
    });
  }
  // get rid of adjascent ** and resolve .. portions
  levelOneOptimize(globParts) {
    return globParts.map((parts) => {
      parts = parts.reduce((set2, part) => {
        const prev = set2[set2.length - 1];
        if (part === "**" && prev === "**") {
          return set2;
        }
        if (part === "..") {
          if (prev && prev !== ".." && prev !== "." && prev !== "**") {
            set2.pop();
            return set2;
          }
        }
        set2.push(part);
        return set2;
      }, []);
      return parts.length === 0 ? [""] : parts;
    });
  }
  levelTwoFileOptimize(parts) {
    if (!Array.isArray(parts)) {
      parts = this.slashSplit(parts);
    }
    let didSomething = false;
    do {
      didSomething = false;
      if (!this.preserveMultipleSlashes) {
        for (let i2 = 1; i2 < parts.length - 1; i2++) {
          const p2 = parts[i2];
          if (i2 === 1 && p2 === "" && parts[0] === "")
            continue;
          if (p2 === "." || p2 === "") {
            didSomething = true;
            parts.splice(i2, 1);
            i2--;
          }
        }
        if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
          didSomething = true;
          parts.pop();
        }
      }
      let dd = 0;
      while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
        const p2 = parts[dd - 1];
        if (p2 && p2 !== "." && p2 !== ".." && p2 !== "**") {
          didSomething = true;
          parts.splice(dd - 1, 2);
          dd -= 2;
        }
      }
    } while (didSomething);
    return parts.length === 0 ? [""] : parts;
  }
  // First phase: single-pattern processing
  // <pre> is 1 or more portions
  // <rest> is 1 or more portions
  // <p> is any portion other than ., .., '', or **
  // <e> is . or ''
  //
  // **/.. is *brutal* for filesystem walking performance, because
  // it effectively resets the recursive walk each time it occurs,
  // and ** cannot be reduced out by a .. pattern part like a regexp
  // or most strings (other than .., ., and '') can be.
  //
  // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
  // <pre>/<e>/<rest> -> <pre>/<rest>
  // <pre>/<p>/../<rest> -> <pre>/<rest>
  // **/**/<rest> -> **/<rest>
  //
  // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
  // this WOULD be allowed if ** did follow symlinks, or * didn't
  firstPhasePreProcess(globParts) {
    let didSomething = false;
    do {
      didSomething = false;
      for (let parts of globParts) {
        let gs = -1;
        while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
          let gss = gs;
          while (parts[gss + 1] === "**") {
            gss++;
          }
          if (gss > gs) {
            parts.splice(gs + 1, gss - gs);
          }
          let next = parts[gs + 1];
          const p2 = parts[gs + 2];
          const p22 = parts[gs + 3];
          if (next !== "..")
            continue;
          if (!p2 || p2 === "." || p2 === ".." || !p22 || p22 === "." || p22 === "..") {
            continue;
          }
          didSomething = true;
          parts.splice(gs, 1);
          const other = parts.slice(0);
          other[gs] = "**";
          globParts.push(other);
          gs--;
        }
        if (!this.preserveMultipleSlashes) {
          for (let i2 = 1; i2 < parts.length - 1; i2++) {
            const p2 = parts[i2];
            if (i2 === 1 && p2 === "" && parts[0] === "")
              continue;
            if (p2 === "." || p2 === "") {
              didSomething = true;
              parts.splice(i2, 1);
              i2--;
            }
          }
          if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
            didSomething = true;
            parts.pop();
          }
        }
        let dd = 0;
        while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
          const p2 = parts[dd - 1];
          if (p2 && p2 !== "." && p2 !== ".." && p2 !== "**") {
            didSomething = true;
            const needDot = dd === 1 && parts[dd + 1] === "**";
            const splin = needDot ? ["."] : [];
            parts.splice(dd - 1, 2, ...splin);
            if (parts.length === 0)
              parts.push("");
            dd -= 2;
          }
        }
      }
    } while (didSomething);
    return globParts;
  }
  // second phase: multi-pattern dedupes
  // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
  // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
  // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
  //
  // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
  // ^-- not valid because ** doens't follow symlinks
  secondPhasePreProcess(globParts) {
    for (let i2 = 0; i2 < globParts.length - 1; i2++) {
      for (let j = i2 + 1; j < globParts.length; j++) {
        const matched = this.partsMatch(globParts[i2], globParts[j], !this.preserveMultipleSlashes);
        if (matched) {
          globParts[i2] = [];
          globParts[j] = matched;
          break;
        }
      }
    }
    return globParts.filter((gs) => gs.length);
  }
  partsMatch(a2, b2, emptyGSMatch = false) {
    let ai = 0;
    let bi = 0;
    let result = [];
    let which = "";
    while (ai < a2.length && bi < b2.length) {
      if (a2[ai] === b2[bi]) {
        result.push(which === "b" ? b2[bi] : a2[ai]);
        ai++;
        bi++;
      } else if (emptyGSMatch && a2[ai] === "**" && b2[bi] === a2[ai + 1]) {
        result.push(a2[ai]);
        ai++;
      } else if (emptyGSMatch && b2[bi] === "**" && a2[ai] === b2[bi + 1]) {
        result.push(b2[bi]);
        bi++;
      } else if (a2[ai] === "*" && b2[bi] && (this.options.dot || !b2[bi].startsWith(".")) && b2[bi] !== "**") {
        if (which === "b")
          return false;
        which = "a";
        result.push(a2[ai]);
        ai++;
        bi++;
      } else if (b2[bi] === "*" && a2[ai] && (this.options.dot || !a2[ai].startsWith(".")) && a2[ai] !== "**") {
        if (which === "a")
          return false;
        which = "b";
        result.push(b2[bi]);
        ai++;
        bi++;
      } else {
        return false;
      }
    }
    return a2.length === b2.length && result;
  }
  parseNegate() {
    if (this.nonegate)
      return;
    const pattern = this.pattern;
    let negate = false;
    let negateOffset = 0;
    for (let i2 = 0; i2 < pattern.length && pattern.charAt(i2) === "!"; i2++) {
      negate = !negate;
      negateOffset++;
    }
    if (negateOffset)
      this.pattern = pattern.slice(negateOffset);
    this.negate = negate;
  }
  // set partial to true to test if, for example,
  // "/a/b" matches the start of "/*/b/*/d"
  // Partial means, if you run out of file before you run
  // out of pattern, then that's fine, as long as all
  // the parts match.
  matchOne(file, pattern, partial = false) {
    const options = this.options;
    if (this.isWindows) {
      const fileDrive = typeof file[0] === "string" && /^[a-z]:$/i.test(file[0]);
      const fileUNC = !fileDrive && file[0] === "" && file[1] === "" && file[2] === "?" && /^[a-z]:$/i.test(file[3]);
      const patternDrive = typeof pattern[0] === "string" && /^[a-z]:$/i.test(pattern[0]);
      const patternUNC = !patternDrive && pattern[0] === "" && pattern[1] === "" && pattern[2] === "?" && typeof pattern[3] === "string" && /^[a-z]:$/i.test(pattern[3]);
      const fdi = fileUNC ? 3 : fileDrive ? 0 : void 0;
      const pdi = patternUNC ? 3 : patternDrive ? 0 : void 0;
      if (typeof fdi === "number" && typeof pdi === "number") {
        const [fd, pd] = [file[fdi], pattern[pdi]];
        if (fd.toLowerCase() === pd.toLowerCase()) {
          pattern[pdi] = fd;
          if (pdi > fdi) {
            pattern = pattern.slice(pdi);
          } else if (fdi > pdi) {
            file = file.slice(fdi);
          }
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      file = this.levelTwoFileOptimize(file);
    }
    this.debug("matchOne", this, { file, pattern });
    this.debug("matchOne", file.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p2 = pattern[pi];
      var f2 = file[fi];
      this.debug(pattern, p2, f2);
      if (p2 === false) {
        return false;
      }
      if (p2 === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p2, f2]);
        var fr = fi;
        var pr = pi + 1;
        if (pr === pl) {
          this.debug("** at the end");
          for (; fi < fl; fi++) {
            if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
              return false;
          }
          return true;
        }
        while (fr < fl) {
          var swallowee = file[fr];
          this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
            this.debug("globstar found match!", fr, fl, swallowee);
            return true;
          } else {
            if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr, pattern, pr);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            fr++;
          }
        }
        if (partial) {
          this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
          if (fr === fl) {
            return true;
          }
        }
        return false;
      }
      let hit;
      if (typeof p2 === "string") {
        hit = f2 === p2;
        this.debug("string match", p2, f2, hit);
      } else {
        hit = p2.test(f2);
        this.debug("pattern match", p2, f2, hit);
      }
      if (!hit)
        return false;
    }
    if (fi === fl && pi === pl) {
      return true;
    } else if (fi === fl) {
      return partial;
    } else if (pi === pl) {
      return fi === fl - 1 && file[fi] === "";
    } else {
      throw new Error("wtf?");
    }
  }
  braceExpand() {
    return braceExpand(this.pattern, this.options);
  }
  parse(pattern) {
    assertValidPattern(pattern);
    const options = this.options;
    if (pattern === "**")
      return GLOBSTAR;
    if (pattern === "")
      return "";
    let m;
    let fastTest = null;
    if (m = pattern.match(starRE)) {
      fastTest = options.dot ? starTestDot : starTest;
    } else if (m = pattern.match(starDotExtRE)) {
      fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m[1]);
    } else if (m = pattern.match(qmarksRE)) {
      fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m);
    } else if (m = pattern.match(starDotStarRE)) {
      fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
    } else if (m = pattern.match(dotStarRE)) {
      fastTest = dotStarTest;
    }
    const re = AST.fromGlob(pattern, this.options).toMMPattern();
    if (fastTest && typeof re === "object") {
      Reflect.defineProperty(re, "test", { value: fastTest });
    }
    return re;
  }
  makeRe() {
    if (this.regexp || this.regexp === false)
      return this.regexp;
    const set2 = this.set;
    if (!set2.length) {
      this.regexp = false;
      return this.regexp;
    }
    const options = this.options;
    const twoStar = options.noglobstar ? star2 : options.dot ? twoStarDot : twoStarNoDot;
    const flags = new Set(options.nocase ? ["i"] : []);
    let re = set2.map((pattern) => {
      const pp = pattern.map((p2) => {
        if (p2 instanceof RegExp) {
          for (const f2 of p2.flags.split(""))
            flags.add(f2);
        }
        return typeof p2 === "string" ? regExpEscape2(p2) : p2 === GLOBSTAR ? GLOBSTAR : p2._src;
      });
      pp.forEach((p2, i2) => {
        const next = pp[i2 + 1];
        const prev = pp[i2 - 1];
        if (p2 !== GLOBSTAR || prev === GLOBSTAR) {
          return;
        }
        if (prev === void 0) {
          if (next !== void 0 && next !== GLOBSTAR) {
            pp[i2 + 1] = "(?:\\/|" + twoStar + "\\/)?" + next;
          } else {
            pp[i2] = twoStar;
          }
        } else if (next === void 0) {
          pp[i2 - 1] = prev + "(?:\\/|\\/" + twoStar + ")?";
        } else if (next !== GLOBSTAR) {
          pp[i2 - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next;
          pp[i2 + 1] = GLOBSTAR;
        }
      });
      const filtered = pp.filter((p2) => p2 !== GLOBSTAR);
      if (this.partial && filtered.length >= 1) {
        const prefixes = [];
        for (let i2 = 1; i2 <= filtered.length; i2++) {
          prefixes.push(filtered.slice(0, i2).join("/"));
        }
        return "(?:" + prefixes.join("|") + ")";
      }
      return filtered.join("/");
    }).join("|");
    const [open, close] = set2.length > 1 ? ["(?:", ")"] : ["", ""];
    re = "^" + open + re + close + "$";
    if (this.partial) {
      re = "^(?:\\/|" + open + re.slice(1, -1) + close + ")$";
    }
    if (this.negate)
      re = "^(?!" + re + ").+$";
    try {
      this.regexp = new RegExp(re, [...flags].join(""));
    } catch (ex) {
      this.regexp = false;
    }
    return this.regexp;
  }
  slashSplit(p2) {
    if (this.preserveMultipleSlashes) {
      return p2.split("/");
    } else if (this.isWindows && /^\/\/[^\/]+/.test(p2)) {
      return ["", ...p2.split(/\/+/)];
    } else {
      return p2.split(/\/+/);
    }
  }
  match(f2, partial = this.partial) {
    this.debug("match", f2, this.pattern);
    if (this.comment) {
      return false;
    }
    if (this.empty) {
      return f2 === "";
    }
    if (f2 === "/" && partial) {
      return true;
    }
    const options = this.options;
    if (this.isWindows) {
      f2 = f2.split("\\").join("/");
    }
    const ff = this.slashSplit(f2);
    this.debug(this.pattern, "split", ff);
    const set2 = this.set;
    this.debug(this.pattern, "set", set2);
    let filename = ff[ff.length - 1];
    if (!filename) {
      for (let i2 = ff.length - 2; !filename && i2 >= 0; i2--) {
        filename = ff[i2];
      }
    }
    for (let i2 = 0; i2 < set2.length; i2++) {
      const pattern = set2[i2];
      let file = ff;
      if (options.matchBase && pattern.length === 1) {
        file = [filename];
      }
      const hit = this.matchOne(file, pattern, partial);
      if (hit) {
        if (options.flipNegate) {
          return true;
        }
        return !this.negate;
      }
    }
    if (options.flipNegate) {
      return false;
    }
    return this.negate;
  }
  static defaults(def) {
    return minimatch.defaults(def).Minimatch;
  }
};
minimatch.AST = AST;
minimatch.Minimatch = Minimatch;
minimatch.escape = escape2;
minimatch.unescape = unescape2;

// node_modules/@blocksuite/store/dist/schema/error.js
var SchemaValidateError = class extends BlockSuiteError {
  constructor(flavour, message) {
    super(ErrorCode.SchemaValidateError, `Invalid schema for ${flavour}: ${message}`);
  }
};

// node_modules/@blocksuite/store/dist/schema/schema.js
var Schema = class {
  constructor() {
    this.flavourSchemaMap = /* @__PURE__ */ new Map();
    this.validate = (flavour, parentFlavour, childFlavours) => {
      const schema = this.flavourSchemaMap.get(flavour);
      if (!schema) {
        throw new SchemaValidateError(flavour, SCHEMA_NOT_FOUND_MESSAGE);
      }
      const validateChildren = () => {
        childFlavours?.forEach((childFlavour) => {
          const childSchema = this.flavourSchemaMap.get(childFlavour);
          if (!childSchema) {
            throw new SchemaValidateError(childFlavour, SCHEMA_NOT_FOUND_MESSAGE);
          }
          this.validateSchema(childSchema, schema);
        });
      };
      if (schema.model.role === "root") {
        if (parentFlavour) {
          throw new SchemaValidateError(schema.model.flavour, "Root block cannot have parent.");
        }
        validateChildren();
        return;
      }
      if (!parentFlavour) {
        throw new SchemaValidateError(schema.model.flavour, "Hub/Content must have parent.");
      }
      const parentSchema = this.flavourSchemaMap.get(parentFlavour);
      if (!parentSchema) {
        throw new SchemaValidateError(parentFlavour, SCHEMA_NOT_FOUND_MESSAGE);
      }
      this.validateSchema(schema, parentSchema);
      validateChildren();
    };
  }
  get versions() {
    return Object.fromEntries(Array.from(this.flavourSchemaMap.values()).map((schema) => [schema.model.flavour, schema.version]));
  }
  _matchFlavour(childFlavour, parentFlavour) {
    return minimatch(childFlavour, parentFlavour) || minimatch(parentFlavour, childFlavour);
  }
  _validateParent(child, parent) {
    const _childFlavour = child.model.flavour;
    const _parentFlavour = parent.model.flavour;
    const childValidFlavours = child.model.parent || ["*"];
    const parentValidFlavours = parent.model.children || ["*"];
    return parentValidFlavours.some((parentValidFlavour) => {
      return childValidFlavours.some((childValidFlavour) => {
        if (parentValidFlavour === "*" && childValidFlavour === "*") {
          return true;
        }
        if (parentValidFlavour === "*") {
          return this._matchFlavour(childValidFlavour, _parentFlavour);
        }
        if (childValidFlavour === "*") {
          return this._matchFlavour(_childFlavour, parentValidFlavour);
        }
        return this._matchFlavour(_childFlavour, parentValidFlavour) && this._matchFlavour(childValidFlavour, _parentFlavour);
      });
    });
  }
  _validateRole(child, parent) {
    const childRole = child.model.role;
    const parentRole = parent.model.role;
    const childFlavour = child.model.flavour;
    const parentFlavour = parent.model.flavour;
    if (childRole === "root") {
      throw new SchemaValidateError(childFlavour, `Root block cannot have parent: ${parentFlavour}.`);
    }
    if (childRole === "hub" && parentRole === "content") {
      throw new SchemaValidateError(childFlavour, `Hub block cannot be child of content block: ${parentFlavour}.`);
    }
    if (childRole === "content" && parentRole === "root") {
      throw new SchemaValidateError(childFlavour, `Content block can only be child of hub block or itself. But get: ${parentFlavour}.`);
    }
  }
  isValid(child, parent) {
    const childSchema = this.flavourSchemaMap.get(child);
    const parentSchema = this.flavourSchemaMap.get(parent);
    if (!childSchema || !parentSchema) {
      return false;
    }
    try {
      this.validateSchema(childSchema, parentSchema);
      return true;
    } catch {
      return false;
    }
  }
  register(blockSchema) {
    blockSchema.forEach((schema) => {
      BlockSchema.parse(schema);
      this.flavourSchemaMap.set(schema.model.flavour, schema);
    });
    return this;
  }
  toJSON() {
    return Object.fromEntries(Array.from(this.flavourSchemaMap.values()).map((schema) => [
      schema.model.flavour,
      {
        role: schema.model.role,
        parent: schema.model.parent,
        children: schema.model.children
      }
    ]));
  }
  validateSchema(child, parent) {
    this._validateRole(child, parent);
    const relationCheckSuccess = this._validateParent(child, parent);
    if (!relationCheckSuccess) {
      throw new SchemaValidateError(child.model.flavour, `Block cannot have parent: ${parent.model.flavour}.`);
    }
  }
};

// node_modules/@blocksuite/sync/dist/awareness/engine.js
var AwarenessEngine = class {
  constructor(awareness, sources) {
    this.awareness = awareness;
    this.sources = sources;
  }
  connect() {
    this.sources.forEach((source) => source.connect(this.awareness));
  }
  disconnect() {
    this.sources.forEach((source) => source.disconnect());
  }
};

// node_modules/y-protocols/awareness.js
var outdatedTimeout = 3e4;
var Awareness = class extends Observable {
  /**
   * @param {Y.Doc} doc
   */
  constructor(doc2) {
    super();
    this.doc = doc2;
    this.clientID = doc2.clientID;
    this.states = /* @__PURE__ */ new Map();
    this.meta = /* @__PURE__ */ new Map();
    this._checkInterval = /** @type {any} */
    setInterval(() => {
      const now = getUnixTime();
      if (this.getLocalState() !== null && outdatedTimeout / 2 <= now - /** @type {{lastUpdated:number}} */
      this.meta.get(this.clientID).lastUpdated) {
        this.setLocalState(this.getLocalState());
      }
      const remove = [];
      this.meta.forEach((meta, clientid) => {
        if (clientid !== this.clientID && outdatedTimeout <= now - meta.lastUpdated && this.states.has(clientid)) {
          remove.push(clientid);
        }
      });
      if (remove.length > 0) {
        removeAwarenessStates(this, remove, "timeout");
      }
    }, floor(outdatedTimeout / 10));
    doc2.on("destroy", () => {
      this.destroy();
    });
    this.setLocalState({});
  }
  destroy() {
    this.emit("destroy", [this]);
    this.setLocalState(null);
    super.destroy();
    clearInterval(this._checkInterval);
  }
  /**
   * @return {Object<string,any>|null}
   */
  getLocalState() {
    return this.states.get(this.clientID) || null;
  }
  /**
   * @param {Object<string,any>|null} state
   */
  setLocalState(state) {
    const clientID = this.clientID;
    const currLocalMeta = this.meta.get(clientID);
    const clock = currLocalMeta === void 0 ? 0 : currLocalMeta.clock + 1;
    const prevState = this.states.get(clientID);
    if (state === null) {
      this.states.delete(clientID);
    } else {
      this.states.set(clientID, state);
    }
    this.meta.set(clientID, {
      clock,
      lastUpdated: getUnixTime()
    });
    const added = [];
    const updated = [];
    const filteredUpdated = [];
    const removed = [];
    if (state === null) {
      removed.push(clientID);
    } else if (prevState == null) {
      if (state != null) {
        added.push(clientID);
      }
    } else {
      updated.push(clientID);
      if (!equalityDeep(prevState, state)) {
        filteredUpdated.push(clientID);
      }
    }
    if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {
      this.emit("change", [{ added, updated: filteredUpdated, removed }, "local"]);
    }
    this.emit("update", [{ added, updated, removed }, "local"]);
  }
  /**
   * @param {string} field
   * @param {any} value
   */
  setLocalStateField(field, value) {
    const state = this.getLocalState();
    if (state !== null) {
      this.setLocalState({
        ...state,
        [field]: value
      });
    }
  }
  /**
   * @return {Map<number,Object<string,any>>}
   */
  getStates() {
    return this.states;
  }
};
var removeAwarenessStates = (awareness, clients, origin) => {
  const removed = [];
  for (let i2 = 0; i2 < clients.length; i2++) {
    const clientID = clients[i2];
    if (awareness.states.has(clientID)) {
      awareness.states.delete(clientID);
      if (clientID === awareness.clientID) {
        const curMeta = (
          /** @type {MetaClientState} */
          awareness.meta.get(clientID)
        );
        awareness.meta.set(clientID, {
          clock: curMeta.clock + 1,
          lastUpdated: getUnixTime()
        });
      }
      removed.push(clientID);
    }
  }
  if (removed.length > 0) {
    awareness.emit("change", [{ added: [], updated: [], removed }, origin]);
    awareness.emit("update", [{ added: [], updated: [], removed }, origin]);
  }
};

// node_modules/@blocksuite/sync/dist/blob/engine.js
var BlobEngine = class {
  get sources() {
    return [this.main, ...this.shadows];
  }
  constructor(main, shadows, logger) {
    this.main = main;
    this.shadows = shadows;
    this.logger = logger;
    this._abort = null;
  }
  // eslint-disable-next-line @typescript-eslint/require-await
  async delete(_key) {
    this.logger.error("You are trying to delete a blob. We do not support this feature yet. We need to wait until we implement the indexer, which will inform us which doc is using a particular blob so that we can safely delete it.");
  }
  async get(key) {
    this.logger.debug("get blob", key);
    for (const source of this.sources) {
      const data = await source.get(key);
      if (data) {
        return data;
      }
    }
    return null;
  }
  async list() {
    const blobIdSet = /* @__PURE__ */ new Set();
    for (const source of this.sources) {
      const blobs = await source.list();
      for (const blob of blobs) {
        blobIdSet.add(blob);
      }
    }
    return Array.from(blobIdSet);
  }
  async set(valueOrKey, _value) {
    if (this.main.readonly) {
      throw new Error("main peer is readonly");
    }
    const key = typeof valueOrKey === "string" ? valueOrKey : await sha(await valueOrKey.arrayBuffer());
    const value = typeof valueOrKey === "string" ? _value : valueOrKey;
    if (!value) {
      throw new Error("value is empty");
    }
    await this.main.set(key, value);
    Promise.allSettled(this.shadows.filter((r) => !r.readonly).map((peer) => peer.set(key, value).catch((err) => {
      this.logger.error("Error when uploading to peer", err);
    }))).then((result) => {
      if (result.some(({ status }) => status === "rejected")) {
        this.logger.error(`blob ${key} update finish, but some peers failed to update`);
      } else {
        this.logger.debug(`blob ${key} update finish`);
      }
    }).catch(() => {
    });
    return key;
  }
  start() {
    if (this._abort) {
      return;
    }
    this._abort = new AbortController();
    const abortSignal = this._abort.signal;
    const sync = () => {
      if (abortSignal.aborted) {
        return;
      }
      this.sync().catch((error) => {
        this.logger.error("sync blob error", error);
      }).finally(() => {
        setTimeout(sync, 6e4);
      });
    };
    sync();
  }
  stop() {
    this._abort?.abort();
    this._abort = null;
  }
  async sync() {
    if (this.main.readonly) {
      return;
    }
    this.logger.debug("start syncing blob...");
    for (const shadow of this.shadows) {
      let mainList = [];
      let shadowList = [];
      if (!shadow.readonly) {
        try {
          mainList = await this.main.list();
          shadowList = await shadow.list();
        } catch (err) {
          this.logger.error(`error when sync`, err);
          continue;
        }
        const needUpload = mainList.filter((key) => !shadowList.includes(key));
        for (const key of needUpload) {
          try {
            const data = await this.main.get(key);
            if (data) {
              await shadow.set(key, data);
            } else {
              this.logger.error("data not found when trying upload from main to shadow");
            }
          } catch (err) {
            this.logger.error(`error when sync ${key} from [${this.main.name}] to [${shadow.name}]`, err);
          }
        }
      }
      const needDownload = shadowList.filter((key) => !mainList.includes(key));
      for (const key of needDownload) {
        try {
          const data = await shadow.get(key);
          if (data) {
            await this.main.set(key, data);
          } else {
            this.logger.error("data not found when trying download from shadow to main");
          }
        } catch (err) {
          this.logger.error(`error when sync ${key} from [${shadow.name}] to [${this.main.name}]`, err);
        }
      }
    }
    this.logger.debug("finish syncing blob");
  }
};

// node_modules/@blocksuite/sync/dist/blob/impl/memory.js
var MemoryBlobSource = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
    this.name = "memory";
    this.readonly = false;
  }
  delete(key) {
    this.map.delete(key);
    return Promise.resolve();
  }
  get(key) {
    return Promise.resolve(this.map.get(key) ?? null);
  }
  list() {
    return Promise.resolve(Array.from(this.map.keys()));
  }
  set(key, value) {
    this.map.set(key, value);
    return Promise.resolve(key);
  }
};

// node_modules/@blocksuite/sync/dist/doc/consts.js
var DocEngineStep;
(function(DocEngineStep2) {
  DocEngineStep2[DocEngineStep2["Stopped"] = 0] = "Stopped";
  DocEngineStep2[DocEngineStep2["Synced"] = 2] = "Synced";
  DocEngineStep2[DocEngineStep2["Syncing"] = 1] = "Syncing";
})(DocEngineStep || (DocEngineStep = {}));
var DocPeerStep;
(function(DocPeerStep2) {
  DocPeerStep2[DocPeerStep2["Loaded"] = 4.5] = "Loaded";
  DocPeerStep2[DocPeerStep2["LoadingRootDoc"] = 2] = "LoadingRootDoc";
  DocPeerStep2[DocPeerStep2["LoadingSubDoc"] = 3] = "LoadingSubDoc";
  DocPeerStep2[DocPeerStep2["Retrying"] = 1] = "Retrying";
  DocPeerStep2[DocPeerStep2["Stopped"] = 0] = "Stopped";
  DocPeerStep2[DocPeerStep2["Synced"] = 6] = "Synced";
  DocPeerStep2[DocPeerStep2["Syncing"] = 5] = "Syncing";
})(DocPeerStep || (DocPeerStep = {}));

// node_modules/@blocksuite/sync/dist/utils/async-queue.js
var AsyncQueue = class {
  get length() {
    return this._queue.length;
  }
  constructor(init = []) {
    this._resolveUpdate = null;
    this._waitForUpdate = null;
    this._queue = init;
  }
  clear() {
    this._queue = [];
  }
  find(predicate) {
    return this._queue.find(predicate);
  }
  async next(abort, dequeue = (a2) => a2.shift()) {
    const update = dequeue(this._queue);
    if (update) {
      return update;
    } else {
      if (!this._waitForUpdate) {
        this._waitForUpdate = new Promise((resolve) => {
          this._resolveUpdate = resolve;
        });
      }
      await Promise.race([
        this._waitForUpdate,
        new Promise((_2, reject) => {
          if (abort?.aborted) {
            reject(abort?.reason);
          }
          abort?.addEventListener("abort", () => {
            reject(abort.reason);
          });
        })
      ]);
      return this.next(abort, dequeue);
    }
  }
  push(...updates) {
    this._queue.push(...updates);
    if (this._resolveUpdate) {
      const resolve = this._resolveUpdate;
      this._resolveUpdate = null;
      this._waitForUpdate = null;
      resolve();
    }
  }
  remove(predicate) {
    const index = this._queue.findIndex(predicate);
    if (index !== -1) {
      this._queue.splice(index, 1);
    }
  }
};
var PriorityAsyncQueue = class extends AsyncQueue {
  constructor(init = [], priorityTarget = new SharedPriorityTarget()) {
    super(init);
    this.priorityTarget = priorityTarget;
  }
  next(abort) {
    return super.next(abort, (arr) => {
      if (this.priorityTarget.priorityRule !== null) {
        const index = arr.findIndex((update) => this.priorityTarget.priorityRule?.(update.id));
        if (index !== -1) {
          return arr.splice(index, 1)[0];
        }
      }
      return arr.shift();
    });
  }
};
var SharedPriorityTarget = class {
  constructor() {
    this.priorityRule = null;
  }
};

// node_modules/@blocksuite/sync/dist/utils/throw-if-aborted.js
function throwIfAborted(abort) {
  if (abort?.aborted) {
    throw new Error(abort.reason);
  }
  return true;
}
var MANUALLY_STOP = "manually-stop";

// node_modules/@blocksuite/sync/dist/doc/peer.js
var SyncPeer = class {
  get name() {
    return this.source.name;
  }
  set status(s2) {
    if (!isEqual(s2, this._status)) {
      this.logger.debug(`doc-peer:${this.name} status change`, s2);
      this._status = s2;
      this.onStatusChange.emit(s2);
    }
  }
  get status() {
    return this._status;
  }
  constructor(rootDoc, source, priorityTarget = new SharedPriorityTarget(), logger) {
    this.rootDoc = rootDoc;
    this.source = source;
    this.priorityTarget = priorityTarget;
    this.logger = logger;
    this._status = {
      step: DocPeerStep.LoadingRootDoc,
      totalDocs: 1,
      loadedDocs: 0,
      pendingPullUpdates: 0,
      pendingPushUpdates: 0
    };
    this.abort = new AbortController();
    this.handleStorageUpdates = (id2, data) => {
      this.state.pullUpdatesQueue.push({
        id: id2,
        data
      });
      this.updateSyncStatus();
    };
    this.handleSubdocsUpdate = ({ added, removed }) => {
      for (const subdoc of added) {
        this.state.subdocsLoadQueue.push({ id: subdoc.guid, doc: subdoc });
      }
      for (const subdoc of removed) {
        this.disconnectDoc(subdoc);
        this.state.subdocsLoadQueue.remove((doc2) => doc2.doc === subdoc);
      }
      this.updateSyncStatus();
    };
    this.handleYDocUpdates = (update, origin, doc2) => {
      if (origin === this.name) {
        return;
      }
      const exist = this.state.pushUpdatesQueue.find(({ id: id2 }) => id2 === doc2.guid);
      if (exist) {
        exist.data.push(update);
      } else {
        this.state.pushUpdatesQueue.push({
          id: doc2.guid,
          data: [update]
        });
      }
      this.updateSyncStatus();
    };
    this.onStatusChange = new Slot();
    this.state = {
      connectedDocs: /* @__PURE__ */ new Map(),
      pushUpdatesQueue: new PriorityAsyncQueue([], this.priorityTarget),
      pushingUpdate: false,
      pullUpdatesQueue: new PriorityAsyncQueue([], this.priorityTarget),
      subdocLoading: false,
      subdocsLoadQueue: new PriorityAsyncQueue([], this.priorityTarget)
    };
    this.logger.debug(`doc-peer:${this.name} start`);
    this.syncRetryLoop(this.abort.signal).catch((err) => {
      console.error(err);
    });
  }
  async connectDoc(doc2, abort) {
    const { data: docData, state: inStorageState } = await this.source.pull(doc2.guid, encodeStateVector(doc2)) ?? {};
    throwIfAborted(abort);
    if (docData && docData.length > 0) {
      applyUpdate(doc2, docData, "load");
    }
    this.state.pushUpdatesQueue.push({
      id: doc2.guid,
      data: [encodeStateAsUpdate(doc2, inStorageState)]
    });
    this.state.connectedDocs.set(doc2.guid, doc2);
    doc2.on("update", this.handleYDocUpdates);
    doc2.emit("sync", [true, doc2]);
    this.updateSyncStatus();
  }
  disconnectDoc(doc2) {
    doc2.off("update", this.handleYDocUpdates);
    this.state.connectedDocs.delete(doc2.guid);
    this.updateSyncStatus();
  }
  initState() {
    this.state.connectedDocs.clear();
    this.state.pushUpdatesQueue.clear();
    this.state.pullUpdatesQueue.clear();
    this.state.subdocsLoadQueue.clear();
    this.state.pushingUpdate = false;
    this.state.subdocLoading = false;
  }
  /**
   * stop sync
   *
   * DocPeer is one-time use, this peer should be discarded after call stop().
   */
  stop() {
    this.logger.debug(`doc-peer:${this.name} stop`);
    this.abort.abort(MANUALLY_STOP);
  }
  /**
   * main synchronization logic
   */
  async sync(abortOuter) {
    this.initState();
    const abortInner = new AbortController();
    abortOuter.addEventListener("abort", (reason) => {
      abortInner.abort(reason);
    });
    let dispose = null;
    try {
      this.updateSyncStatus();
      dispose = await this.source.subscribe(this.handleStorageUpdates, (reason) => {
        abortInner.abort("subscribe disconnect:" + reason);
      });
      throwIfAborted(abortInner.signal);
      await this.connectDoc(this.rootDoc, abortInner.signal);
      this.state.subdocsLoadQueue.push(...Array.from(this.rootDoc.getSubdocs()).map((doc2) => ({
        id: doc2.guid,
        doc: doc2
      })));
      this.updateSyncStatus();
      this.rootDoc.on("subdocs", this.handleSubdocsUpdate);
      await Promise.all([
        // load subdocs
        (async () => {
          while (throwIfAborted(abortInner.signal)) {
            const subdoc = await this.state.subdocsLoadQueue.next(abortInner.signal);
            this.state.subdocLoading = true;
            this.updateSyncStatus();
            await this.connectDoc(subdoc.doc, abortInner.signal);
            this.state.subdocLoading = false;
            this.updateSyncStatus();
          }
        })(),
        // pull updates
        (async () => {
          while (throwIfAborted(abortInner.signal)) {
            const { id: id2, data } = await this.state.pullUpdatesQueue.next(abortInner.signal);
            if (!(data.byteLength === 0 || data.byteLength === 2 && data[0] === 0 && data[1] === 0)) {
              const subdoc = this.state.connectedDocs.get(id2);
              if (subdoc) {
                applyUpdate(subdoc, data, this.name);
              }
            }
            this.updateSyncStatus();
          }
        })(),
        // push updates
        (async () => {
          while (throwIfAborted(abortInner.signal)) {
            const { id: id2, data } = await this.state.pushUpdatesQueue.next(abortInner.signal);
            this.state.pushingUpdate = true;
            this.updateSyncStatus();
            const merged = mergeUpdates(data);
            if (!(merged.byteLength === 0 || merged.byteLength === 2 && merged[0] === 0 && merged[1] === 0)) {
              await this.source.push(id2, merged);
            }
            this.state.pushingUpdate = false;
            this.updateSyncStatus();
          }
        })()
      ]);
    } finally {
      dispose?.();
      for (const docs of this.state.connectedDocs.values()) {
        this.disconnectDoc(docs);
      }
      this.rootDoc.off("subdocs", this.handleSubdocsUpdate);
    }
  }
  /**
   * auto retry after 5 seconds if sync failed
   */
  async syncRetryLoop(abort) {
    while (abort.aborted === false) {
      try {
        await this.sync(abort);
      } catch (err) {
        if (err === MANUALLY_STOP || abort.aborted) {
          return;
        }
        this.logger.error(`doc-peer:${this.name} sync error`, err);
      }
      try {
        this.logger.error(`doc-peer:${this.name} retry after 5 seconds`);
        this.status = {
          step: DocPeerStep.Retrying,
          totalDocs: 1,
          loadedDocs: 0,
          pendingPullUpdates: 0,
          pendingPushUpdates: 0
        };
        await Promise.race([
          new Promise((resolve) => {
            setTimeout(resolve, 5 * 1e3);
          }),
          new Promise((_2, reject) => {
            if (abort.aborted) {
              reject(abort.reason);
            }
            abort.addEventListener("abort", () => {
              reject(abort.reason);
            });
          })
        ]);
      } catch (err) {
        if (err === MANUALLY_STOP || abort.aborted) {
          return;
        }
        throw err;
      }
    }
  }
  updateSyncStatus() {
    let step;
    if (this.state.connectedDocs.size === 0) {
      step = DocPeerStep.LoadingRootDoc;
    } else if (this.state.subdocsLoadQueue.length || this.state.subdocLoading) {
      step = DocPeerStep.LoadingSubDoc;
    } else if (this.state.pullUpdatesQueue.length || this.state.pushUpdatesQueue.length || this.state.pushingUpdate) {
      step = DocPeerStep.Syncing;
    } else {
      step = DocPeerStep.Synced;
    }
    this.status = {
      step,
      totalDocs: this.state.connectedDocs.size + this.state.subdocsLoadQueue.length,
      loadedDocs: this.state.connectedDocs.size,
      pendingPullUpdates: this.state.pullUpdatesQueue.length + (this.state.subdocLoading ? 1 : 0),
      pendingPushUpdates: this.state.pushUpdatesQueue.length + (this.state.pushingUpdate ? 1 : 0)
    };
  }
  async waitForLoaded(abort) {
    if (this.status.step > DocPeerStep.Loaded) {
      return;
    } else {
      return Promise.race([
        new Promise((resolve) => {
          this.onStatusChange.on((status) => {
            if (status.step > DocPeerStep.Loaded) {
              resolve();
            }
          });
        }),
        new Promise((_2, reject) => {
          if (abort?.aborted) {
            reject(abort?.reason);
          }
          abort?.addEventListener("abort", () => {
            reject(abort.reason);
          });
        })
      ]);
    }
  }
  async waitForSynced(abort) {
    if (this.status.step >= DocPeerStep.Synced) {
      return;
    } else {
      return Promise.race([
        new Promise((resolve) => {
          this.onStatusChange.on((status) => {
            if (status.step >= DocPeerStep.Synced) {
              resolve();
            }
          });
        }),
        new Promise((_2, reject) => {
          if (abort?.aborted) {
            reject(abort?.reason);
          }
          abort?.addEventListener("abort", () => {
            reject(abort.reason);
          });
        })
      ]);
    }
  }
};

// node_modules/@blocksuite/sync/dist/doc/engine.js
var DocEngine = class {
  get rootDocId() {
    return this.rootDoc.guid;
  }
  get status() {
    return this._status;
  }
  constructor(rootDoc, main, shadows, logger) {
    this.rootDoc = rootDoc;
    this.main = main;
    this.shadows = shadows;
    this.logger = logger;
    this._abort = new AbortController();
    this.onStatusChange = new Slot();
    this.priorityTarget = new SharedPriorityTarget();
    this._status = {
      step: DocEngineStep.Stopped,
      main: null,
      shadows: shadows.map(() => null),
      retrying: false
    };
    this.logger.debug(`syne-engine:${this.rootDocId} status init`, this.status);
  }
  setStatus(s2) {
    this.logger.debug(`syne-engine:${this.rootDocId} status change`, s2);
    this._status = s2;
    this.onStatusChange.emit(s2);
  }
  canGracefulStop() {
    return !!this.status.main && this.status.main.pendingPushUpdates === 0;
  }
  forceStop() {
    this._abort.abort(MANUALLY_STOP);
    this.setStatus({
      step: DocEngineStep.Stopped,
      main: null,
      shadows: this.shadows.map(() => null),
      retrying: false
    });
  }
  setPriorityRule(target) {
    this.priorityTarget.priorityRule = target;
  }
  start() {
    if (this.status.step !== DocEngineStep.Stopped) {
      this.forceStop();
    }
    this._abort = new AbortController();
    this.sync(this._abort.signal).catch((err) => {
      this.logger.error(`syne-engine:${this.rootDocId}`, err);
    });
  }
  // main sync process, should never return until abort
  async sync(signal) {
    const state = {
      mainPeer: null,
      shadowPeers: this.shadows.map(() => null)
    };
    const cleanUp = [];
    try {
      state.mainPeer = new SyncPeer(this.rootDoc, this.main, this.priorityTarget, this.logger);
      cleanUp.push(state.mainPeer.onStatusChange.on(() => {
        if (!signal.aborted)
          this.updateSyncingState(state.mainPeer, state.shadowPeers);
      }).dispose);
      this.updateSyncingState(state.mainPeer, state.shadowPeers);
      await state.mainPeer.waitForLoaded(signal);
      state.shadowPeers = this.shadows.map((shadow) => {
        const peer = new SyncPeer(this.rootDoc, shadow, this.priorityTarget, this.logger);
        cleanUp.push(peer.onStatusChange.on(() => {
          if (!signal.aborted)
            this.updateSyncingState(state.mainPeer, state.shadowPeers);
        }).dispose);
        return peer;
      });
      this.updateSyncingState(state.mainPeer, state.shadowPeers);
      await new Promise((_2, reject) => {
        if (signal.aborted) {
          reject(signal.reason);
        }
        signal.addEventListener("abort", () => {
          reject(signal.reason);
        });
      });
    } catch (error) {
      if (error === MANUALLY_STOP || signal.aborted) {
        return;
      }
      throw error;
    } finally {
      state.mainPeer?.stop();
      for (const shadowPeer of state.shadowPeers) {
        shadowPeer?.stop();
      }
      for (const clean of cleanUp) {
        clean();
      }
    }
  }
  updateSyncingState(local, shadows) {
    let step = DocEngineStep.Synced;
    const allPeer = [local, ...shadows];
    for (const peer of allPeer) {
      if (!peer || peer.status.step !== DocPeerStep.Synced) {
        step = DocEngineStep.Syncing;
        break;
      }
    }
    this.setStatus({
      step,
      main: local?.status ?? null,
      shadows: shadows.map((peer) => peer?.status ?? null),
      retrying: allPeer.some((peer) => peer?.status.step === DocPeerStep.Retrying)
    });
  }
  async waitForGracefulStop(abort) {
    await Promise.race([
      new Promise((_2, reject) => {
        if (abort?.aborted) {
          reject(abort?.reason);
        }
        abort?.addEventListener("abort", () => {
          reject(abort.reason);
        });
      }),
      new Promise((resolve) => {
        this.onStatusChange.on(() => {
          if (this.canGracefulStop()) {
            resolve();
          }
        });
      })
    ]);
    throwIfAborted(abort);
    this.forceStop();
  }
  async waitForLoadedRootDoc(abort) {
    function isLoadedRootDoc(status) {
      return ![status.main, ...status.shadows].some((peer) => !peer || peer.step <= DocPeerStep.LoadingRootDoc);
    }
    if (isLoadedRootDoc(this.status)) {
      return;
    } else {
      return Promise.race([
        new Promise((resolve) => {
          this.onStatusChange.on((status) => {
            if (isLoadedRootDoc(status)) {
              resolve();
            }
          });
        }),
        new Promise((_2, reject) => {
          if (abort?.aborted) {
            reject(abort?.reason);
          }
          abort?.addEventListener("abort", () => {
            reject(abort.reason);
          });
        })
      ]);
    }
  }
  async waitForSynced(abort) {
    if (this.status.step === DocEngineStep.Synced) {
      return;
    } else {
      return Promise.race([
        new Promise((resolve) => {
          this.onStatusChange.on((status) => {
            if (status.step === DocEngineStep.Synced) {
              resolve();
            }
          });
        }),
        new Promise((_2, reject) => {
          if (abort?.aborted) {
            reject(abort?.reason);
          }
          abort?.addEventListener("abort", () => {
            reject(abort.reason);
          });
        })
      ]);
    }
  }
};

// node_modules/idb/build/index.js
var instanceOfAny = (object, constructors) => constructors.some((c2) => object instanceof c2);
var idbProxyableTypes;
var cursorAdvanceMethods;
function getIdbProxyableTypes() {
  return idbProxyableTypes || (idbProxyableTypes = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function getCursorAdvanceMethods() {
  return cursorAdvanceMethods || (cursorAdvanceMethods = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
var transactionDoneMap = /* @__PURE__ */ new WeakMap();
var transformCache = /* @__PURE__ */ new WeakMap();
var reverseTransformCache = /* @__PURE__ */ new WeakMap();
function promisifyRequest(request) {
  const promise = new Promise((resolve, reject) => {
    const unlisten = () => {
      request.removeEventListener("success", success);
      request.removeEventListener("error", error);
    };
    const success = () => {
      resolve(wrap(request.result));
      unlisten();
    };
    const error = () => {
      reject(request.error);
      unlisten();
    };
    request.addEventListener("success", success);
    request.addEventListener("error", error);
  });
  reverseTransformCache.set(promise, request);
  return promise;
}
function cacheDonePromiseForTransaction(tx) {
  if (transactionDoneMap.has(tx))
    return;
  const done = new Promise((resolve, reject) => {
    const unlisten = () => {
      tx.removeEventListener("complete", complete);
      tx.removeEventListener("error", error);
      tx.removeEventListener("abort", error);
    };
    const complete = () => {
      resolve();
      unlisten();
    };
    const error = () => {
      reject(tx.error || new DOMException("AbortError", "AbortError"));
      unlisten();
    };
    tx.addEventListener("complete", complete);
    tx.addEventListener("error", error);
    tx.addEventListener("abort", error);
  });
  transactionDoneMap.set(tx, done);
}
var idbProxyTraps = {
  get(target, prop, receiver) {
    if (target instanceof IDBTransaction) {
      if (prop === "done")
        return transactionDoneMap.get(target);
      if (prop === "store") {
        return receiver.objectStoreNames[1] ? void 0 : receiver.objectStore(receiver.objectStoreNames[0]);
      }
    }
    return wrap(target[prop]);
  },
  set(target, prop, value) {
    target[prop] = value;
    return true;
  },
  has(target, prop) {
    if (target instanceof IDBTransaction && (prop === "done" || prop === "store")) {
      return true;
    }
    return prop in target;
  }
};
function replaceTraps(callback) {
  idbProxyTraps = callback(idbProxyTraps);
}
function wrapFunction(func) {
  if (getCursorAdvanceMethods().includes(func)) {
    return function(...args2) {
      func.apply(unwrap(this), args2);
      return wrap(this.request);
    };
  }
  return function(...args2) {
    return wrap(func.apply(unwrap(this), args2));
  };
}
function transformCachableValue(value) {
  if (typeof value === "function")
    return wrapFunction(value);
  if (value instanceof IDBTransaction)
    cacheDonePromiseForTransaction(value);
  if (instanceOfAny(value, getIdbProxyableTypes()))
    return new Proxy(value, idbProxyTraps);
  return value;
}
function wrap(value) {
  if (value instanceof IDBRequest)
    return promisifyRequest(value);
  if (transformCache.has(value))
    return transformCache.get(value);
  const newValue = transformCachableValue(value);
  if (newValue !== value) {
    transformCache.set(value, newValue);
    reverseTransformCache.set(newValue, value);
  }
  return newValue;
}
var unwrap = (value) => reverseTransformCache.get(value);
var readMethods = ["get", "getKey", "getAll", "getAllKeys", "count"];
var writeMethods = ["put", "add", "delete", "clear"];
var cachedMethods = /* @__PURE__ */ new Map();
function getMethod(target, prop) {
  if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === "string")) {
    return;
  }
  if (cachedMethods.get(prop))
    return cachedMethods.get(prop);
  const targetFuncName = prop.replace(/FromIndex$/, "");
  const useIndex = prop !== targetFuncName;
  const isWrite = writeMethods.includes(targetFuncName);
  if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))
  ) {
    return;
  }
  const method = async function(storeName, ...args2) {
    const tx = this.transaction(storeName, isWrite ? "readwrite" : "readonly");
    let target2 = tx.store;
    if (useIndex)
      target2 = target2.index(args2.shift());
    return (await Promise.all([
      target2[targetFuncName](...args2),
      isWrite && tx.done
    ]))[0];
  };
  cachedMethods.set(prop, method);
  return method;
}
replaceTraps((oldTraps) => ({
  ...oldTraps,
  get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
  has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)
}));
var advanceMethodProps = ["continue", "continuePrimaryKey", "advance"];
var methodMap = {};
var advanceResults = /* @__PURE__ */ new WeakMap();
var ittrProxiedCursorToOriginalProxy = /* @__PURE__ */ new WeakMap();
var cursorIteratorTraps = {
  get(target, prop) {
    if (!advanceMethodProps.includes(prop))
      return target[prop];
    let cachedFunc = methodMap[prop];
    if (!cachedFunc) {
      cachedFunc = methodMap[prop] = function(...args2) {
        advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args2));
      };
    }
    return cachedFunc;
  }
};
async function* iterate(...args2) {
  let cursor = this;
  if (!(cursor instanceof IDBCursor)) {
    cursor = await cursor.openCursor(...args2);
  }
  if (!cursor)
    return;
  cursor = cursor;
  const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);
  ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);
  reverseTransformCache.set(proxiedCursor, unwrap(cursor));
  while (cursor) {
    yield proxiedCursor;
    cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());
    advanceResults.delete(proxiedCursor);
  }
}
function isIteratorProp(target, prop) {
  return prop === Symbol.asyncIterator && instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor]) || prop === "iterate" && instanceOfAny(target, [IDBIndex, IDBObjectStore]);
}
replaceTraps((oldTraps) => ({
  ...oldTraps,
  get(target, prop, receiver) {
    if (isIteratorProp(target, prop))
      return iterate;
    return oldTraps.get(target, prop, receiver);
  },
  has(target, prop) {
    return isIteratorProp(target, prop) || oldTraps.has(target, prop);
  }
}));

// node_modules/@blocksuite/sync/dist/doc/impl/noop.js
var NoopDocSource = class {
  constructor() {
    this.name = "noop";
  }
  pull(_docId, _data) {
    return null;
  }
  push(_docId, _data) {
  }
  subscribe(_cb, _disconnect) {
    return () => {
    };
  }
};

// node_modules/@blocksuite/store/dist/store/collection.js
var import_lodash4 = __toESM(require_lodash(), 1);
var import_lodash5 = __toESM(require_lodash2(), 1);

// node_modules/@blocksuite/store/dist/yjs/awareness.js
var import_lodash = __toESM(require_lodash(), 1);
var import_lodash2 = __toESM(require_lodash2(), 1);
var AwarenessStore = class {
  constructor(awareness, defaultFlags) {
    this._onAwarenessChange = (diff) => {
      this._flags.value = this.awareness.getLocalState()?.flags ?? {};
      const { added, removed, updated } = diff;
      const states = this.awareness.getStates();
      added.forEach((id2) => {
        this.slots.update.emit({
          id: id2,
          type: "add",
          state: states.get(id2)
        });
      });
      updated.forEach((id2) => {
        this.slots.update.emit({
          id: id2,
          type: "update",
          state: states.get(id2)
        });
      });
      removed.forEach((id2) => {
        this.slots.update.emit({
          id: id2,
          type: "remove"
        });
      });
    };
    this.slots = {
      update: new Slot()
    };
    this._flags = d(defaultFlags);
    this.awareness = awareness;
    this.awareness.on("change", this._onAwarenessChange);
    this.awareness.setLocalStateField("selectionV2", {});
    this._initFlags(defaultFlags);
  }
  _initFlags(defaultFlags) {
    const upstreamFlags = this.awareness.getLocalState()?.flags;
    const flags = (0, import_lodash.default)(defaultFlags);
    if (upstreamFlags) {
      (0, import_lodash2.default)(flags, upstreamFlags);
    }
    this.awareness.setLocalStateField("flags", flags);
  }
  destroy() {
    this.awareness.off("change", this._onAwarenessChange);
    this.slots.update.dispose();
    this.awareness.destroy();
  }
  getFlag(field) {
    return this._flags.value[field];
  }
  getLocalSelection(selectionManagerId) {
    return (this.awareness.getLocalState()?.selectionV2 ?? {})[selectionManagerId] ?? [];
  }
  getStates() {
    return this.awareness.getStates();
  }
  isReadonly(blockCollection) {
    const rd = this.getFlag("readonly");
    if (rd && typeof rd === "object") {
      return Boolean(rd[blockCollection.id]);
    } else {
      return false;
    }
  }
  setFlag(field, value) {
    const oldFlags = this.awareness.getLocalState()?.flags ?? {};
    this.awareness.setLocalStateField("flags", { ...oldFlags, [field]: value });
  }
  setLocalSelection(selectionManagerId, selection) {
    const oldSelection = this.awareness.getLocalState()?.selectionV2 ?? {};
    this.awareness.setLocalStateField("selectionV2", {
      ...oldSelection,
      [selectionManagerId]: selection
    });
  }
  setReadonly(blockCollection, value) {
    const flags = this.getFlag("readonly") ?? {};
    this.setFlag("readonly", {
      ...flags,
      [blockCollection.id]: value
    });
  }
};

// node_modules/@blocksuite/store/dist/yjs/doc.js
var BlockSuiteDoc = class extends Doc {
  constructor() {
    super(...arguments);
    this._spaces = this.getMap("spaces");
  }
  get spaces() {
    return this._spaces;
  }
  getArrayProxy(key) {
    const array = super.getArray(key);
    return createYProxy(array);
  }
  getMapProxy(key) {
    const map3 = super.getMap(key);
    return createYProxy(map3);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  toJSON() {
    const json = super.toJSON();
    delete json.spaces;
    const spaces = {};
    this.spaces.forEach((doc2, key) => {
      spaces[key] = doc2.toJSON();
    });
    return {
      ...json,
      spaces
    };
  }
  transact(f2, origin) {
    return super.transact(f2, origin);
  }
};

// node_modules/@blocksuite/store/dist/utils/jsx.js
var testSymbol = Symbol.for("react.test.json");
function isValidRecord(data) {
  if (typeof data !== "object" || data === null) {
    return false;
  }
  return true;
}
var IGNORED_PROPS = [
  "sys:id",
  "sys:version",
  "sys:flavour",
  "sys:children",
  "prop:xywh",
  "prop:cells",
  "prop:elements"
];
function yDocToJSXNode(serializedDoc, nodeId) {
  if (!isValidRecord(serializedDoc)) {
    throw new Error("Failed to parse doc record! Invalid data.");
  }
  const node = serializedDoc[nodeId];
  if (!node) {
    throw new Error(`Failed to parse doc record! Node not found! id: ${nodeId}.`);
  }
  const flavour = node["sys:flavour"];
  const children = node["sys:children"];
  const props = Object.fromEntries(Object.entries(node).filter(([key]) => !IGNORED_PROPS.includes(key)));
  if ("prop:text" in props && props["prop:text"] instanceof Array) {
    props["prop:text"] = parseDelta(props["prop:text"]);
  }
  if ("prop:title" in props && props["prop:title"] instanceof Array) {
    props["prop:title"] = parseDelta(props["prop:title"]);
  }
  if ("prop:columns" in props && props["prop:columns"] instanceof Array) {
    props["prop:columns"] = `Array [${props["prop:columns"].length}]`;
  }
  if ("prop:views" in props && props["prop:views"] instanceof Array) {
    props["prop:views"] = `Array [${props["prop:views"].length}]`;
  }
  return {
    $$typeof: testSymbol,
    type: flavour,
    props,
    children: children?.map((id2) => yDocToJSXNode(serializedDoc, id2)) ?? []
  };
}
function serializeYDoc(doc2) {
  const json = {};
  doc2.share.forEach((value, key) => {
    if (value instanceof YMap) {
      json[key] = serializeYMap(value);
    } else {
      json[key] = value.toJSON();
    }
  });
  return json;
}
function serializeY(value) {
  if (value instanceof Doc) {
    return serializeYDoc(value);
  }
  if (value instanceof YMap) {
    return serializeYMap(value);
  }
  if (value instanceof YText) {
    return serializeYText(value);
  }
  if (value instanceof YArray) {
    return value.toArray().map((x) => serializeY(x));
  }
  if (value instanceof AbstractType) {
    return value.toJSON();
  }
  return value;
}
function serializeYMap(map3) {
  const json = {};
  map3.forEach((value, key) => {
    json[key] = serializeY(value);
  });
  return json;
}
function serializeYText(text2) {
  const delta = text2.toDelta();
  return delta;
}
function parseDelta(text2) {
  if (!text2.length) {
    return void 0;
  }
  if (text2.length === 1 && !text2[0].attributes) {
    return text2[0].insert;
  }
  return {
    // The `Symbol.for('react.fragment')` will render as `<React.Fragment>`
    // so we use a empty string to render it as `<>`.
    // But it will empty children ad `< />`
    // so we return `undefined` directly if not delta text.
    $$typeof: testSymbol,
    // Symbol.for('react.element'),
    type: "",
    // Symbol.for('react.fragment'),
    props: {},
    children: text2?.map(({ insert, attributes }) => ({
      $$typeof: testSymbol,
      type: "text",
      props: {
        // Not place at `children` to avoid the trailing whitespace be trim by formatter.
        insert,
        ...attributes
      }
    }))
  };
}

// node_modules/@blocksuite/store/dist/store/addon/shared.js
function addOnFactory(fn) {
  return fn;
}

// node_modules/@blocksuite/store/dist/store/addon/test.js
var test = addOnFactory((originalClass) => class extends originalClass {
  /** @internal Only for testing */
  exportJSX(blockId, docId = this.meta.docMetas.at(0)?.id) {
    assertExists(docId);
    const doc2 = this.doc.spaces.get(docId);
    assertExists(doc2);
    const docJson = serializeYDoc(doc2);
    if (!docJson) {
      throw new Error(`Doc ${docId} doesn't exist`);
    }
    const blockJson = docJson.blocks;
    if (!blockId) {
      const rootId = Object.keys(blockJson).at(0);
      if (!rootId) {
        return null;
      }
      blockId = rootId;
    }
    if (!blockJson[blockId]) {
      return null;
    }
    return yDocToJSXNode(blockJson, blockId);
  }
});

// node_modules/@blocksuite/store/dist/store/addon/type.js
var DocCollectionAddonType = class {
};

// node_modules/@blocksuite/store/dist/store/doc/crud.js
var DocCRUD = class {
  get root() {
    let rootId = null;
    this._yBlocks.forEach((yBlock) => {
      const flavour = yBlock.get("sys:flavour");
      const schema = this._schema.flavourSchemaMap.get(flavour);
      if (!schema)
        return;
      if (schema.model.role === "root") {
        rootId = yBlock.get("sys:id");
      }
    });
    return rootId;
  }
  constructor(_yBlocks, _schema) {
    this._yBlocks = _yBlocks;
    this._schema = _schema;
  }
  _getSiblings(id2, fn) {
    const parentId = this.getParent(id2);
    if (!parentId)
      return null;
    const parent = this._yBlocks.get(parentId);
    if (!parent)
      return null;
    const children = parent.get("sys:children");
    const index = children.toArray().indexOf(id2);
    if (index === -1)
      return null;
    return fn(index, parent);
  }
  addBlock(id2, flavour, initialProps = {}, parent, parentIndex) {
    const schema = this._schema.flavourSchemaMap.get(flavour);
    if (!schema) {
      throw new BlockSuiteError(ErrorCode.ModelCRUDError, `schema for flavour: ${flavour} not found`);
    }
    const parentFlavour = parent ? this._yBlocks.get(parent)?.get("sys:flavour") : void 0;
    this._schema.validate(flavour, parentFlavour);
    const hasBlock = this._yBlocks.has(id2);
    if (hasBlock) {
      const yBlock = this._yBlocks.get(id2);
      const existedParent = this.getParent(id2);
      if (yBlock && existedParent) {
        const yParent2 = this._yBlocks.get(existedParent);
        const yParentChildren2 = yParent2.get("sys:children");
        const index2 = yParentChildren2.toArray().indexOf(id2);
        yParentChildren2.delete(index2, 1);
        if (parentIndex != null && index2 != null && existedParent === parent && index2 < parentIndex) {
          parentIndex--;
        }
        const props = {
          ...initialProps
        };
        delete props.id;
        delete props.flavour;
        delete props.children;
        Object.entries(props).forEach(([key, value]) => {
          if (value === void 0)
            return;
          yBlock.set(`prop:${key}`, native2Y(value));
        });
      }
    } else {
      const yBlock = new YMap();
      this._yBlocks.set(id2, yBlock);
      const version = schema.version;
      const children = initialProps.children?.map((child) => typeof child === "string" ? child : child.id);
      yBlock.set("sys:id", id2);
      yBlock.set("sys:flavour", flavour);
      yBlock.set("sys:version", version);
      yBlock.set("sys:children", YArray.from(children ?? []));
      const defaultProps = schema.model.props?.(internalPrimitives) ?? {};
      const props = {
        ...defaultProps,
        ...initialProps
      };
      delete props.id;
      delete props.flavour;
      delete props.children;
      Object.entries(props).forEach(([key, value]) => {
        if (value === void 0)
          return;
        yBlock.set(`prop:${key}`, native2Y(value));
      });
    }
    const parentId = parent ?? (schema.model.role === "root" ? null : this.root);
    if (!parentId)
      return;
    const yParent = this._yBlocks.get(parentId);
    if (!yParent)
      return;
    const yParentChildren = yParent.get("sys:children");
    const index = parentIndex != null ? parentIndex > yParentChildren.length ? yParentChildren.length : parentIndex : yParentChildren.length;
    yParentChildren.insert(index, [id2]);
  }
  deleteBlock(id2, options = {
    deleteChildren: true
  }) {
    const { bringChildrenTo, deleteChildren } = options;
    if (bringChildrenTo && deleteChildren) {
      console.error("Cannot bring children to another block and delete them at the same time");
      return;
    }
    const yModel = this._yBlocks.get(id2);
    if (!yModel)
      return;
    const yModelChildren = yModel.get("sys:children");
    const parent = this.getParent(id2);
    if (!parent)
      return;
    const yParent = this._yBlocks.get(parent);
    const yParentChildren = yParent.get("sys:children");
    const modelIndex = yParentChildren.toArray().indexOf(id2);
    if (modelIndex > -1) {
      yParentChildren.delete(modelIndex, 1);
    }
    const apply = () => {
      if (bringChildrenTo) {
        const bringChildrenToModel = () => {
          if (!bringChildrenTo) {
            throw new BlockSuiteError(ErrorCode.ModelCRUDError, "bringChildrenTo is not provided when deleting block");
          }
          const model = this._yBlocks.get(bringChildrenTo);
          if (!model)
            return;
          const bringFlavour = model.get("sys:flavour");
          yModelChildren.forEach((child) => {
            const childModel = this._yBlocks.get(child);
            if (!childModel)
              return;
            this._schema.validate(childModel.get("sys:flavour"), bringFlavour);
          });
          if (bringChildrenTo === parent) {
            yParentChildren.insert(modelIndex, yModelChildren.toArray());
            return;
          }
          const yBringChildrenTo = this._yBlocks.get(bringChildrenTo);
          if (!yBringChildrenTo)
            return;
          const yBringChildrenToChildren = yBringChildrenTo.get("sys:children");
          yBringChildrenToChildren.push(yModelChildren.toArray());
        };
        bringChildrenToModel();
        return;
      }
      if (deleteChildren) {
        const deleteById = (id3) => {
          const yBlock = this._yBlocks.get(id3);
          const yChildren = yBlock.get("sys:children");
          yChildren.forEach((id4) => deleteById(id4));
          this._yBlocks.delete(id3);
        };
        yModelChildren.forEach((id3) => deleteById(id3));
      }
    };
    apply();
    this._yBlocks.delete(id2);
  }
  getNext(id2) {
    return this._getSiblings(id2, (index, parent) => parent.get("sys:children").toArray().at(index + 1) ?? null);
  }
  getParent(targetId) {
    const root = this.root;
    if (!root || root === targetId)
      return null;
    const findParent = (parentId) => {
      const parentYBlock = this._yBlocks.get(parentId);
      if (!parentYBlock)
        return null;
      const children = parentYBlock.get("sys:children");
      for (const childId of children.toArray()) {
        if (childId === targetId)
          return parentId;
        const parent = findParent(childId);
        if (parent != null)
          return parent;
      }
      return null;
    };
    return findParent(root);
  }
  getPrev(id2) {
    return this._getSiblings(id2, (index, parent) => parent.get("sys:children").toArray().at(index - 1) ?? null);
  }
  moveBlocks(blocksToMove, newParent, targetSibling = null, shouldInsertBeforeSibling = true) {
    const childBlocksPerParent = /* @__PURE__ */ new Map();
    const parentBlock = this._yBlocks.get(newParent);
    if (!parentBlock)
      return;
    const parentFlavour = parentBlock.get("sys:flavour");
    blocksToMove.forEach((blockId) => {
      const parent = this.getParent(blockId);
      if (!parent)
        return;
      const block = this._yBlocks.get(blockId);
      if (!block)
        return;
      this._schema.validate(block.get("sys:flavour"), parentFlavour);
      const children = childBlocksPerParent.get(parent);
      if (!children) {
        childBlocksPerParent.set(parent, [blockId]);
        return;
      }
      const last3 = children[children.length - 1];
      if (this.getNext(last3) !== blockId) {
        throw new BlockSuiteError(ErrorCode.ModelCRUDError, "The blocks to move are not contiguous under their parent");
      }
      children.push(blockId);
    });
    let insertIndex = 0;
    Array.from(childBlocksPerParent.entries()).forEach(([parentBlock2, blocksToMove2], index) => {
      const targetParentBlock = this._yBlocks.get(newParent);
      if (!targetParentBlock)
        return;
      const targetParentChildren = targetParentBlock.get("sys:children");
      const sourceParentBlock = this._yBlocks.get(parentBlock2);
      if (!sourceParentBlock)
        return;
      const sourceParentChildren = sourceParentBlock.get("sys:children");
      const startIndex = sourceParentChildren.toArray().findIndex((id2) => id2 === blocksToMove2[0]);
      sourceParentChildren.delete(startIndex, blocksToMove2.length);
      const updateInsertIndex = () => {
        const first = index === 0;
        if (!first) {
          insertIndex++;
          return;
        }
        if (!targetSibling) {
          insertIndex = targetParentChildren.length;
          return;
        }
        const targetIndex = targetParentChildren.toArray().findIndex((id2) => id2 === targetSibling);
        if (targetIndex === -1) {
          throw new BlockSuiteError(ErrorCode.ModelCRUDError, "Target sibling not found");
        }
        insertIndex = shouldInsertBeforeSibling ? targetIndex : targetIndex + 1;
      };
      updateInsertIndex();
      targetParentChildren.insert(insertIndex, blocksToMove2);
    });
  }
  updateBlockChildren(id2, children) {
    const yBlock = this._yBlocks.get(id2);
    if (!yBlock)
      return;
    const yChildrenArray = yBlock.get("sys:children");
    yChildrenArray.delete(0, yChildrenArray.length);
    yChildrenArray.push(children);
  }
};

// node_modules/@blocksuite/store/dist/utils/utils.js
var utils_exports = {};
__export(utils_exports, {
  hash: () => hash,
  syncBlockProps: () => syncBlockProps
});
function syncBlockProps(schema, model, yBlock, props) {
  const defaultProps = schema.model.props?.(internalPrimitives) ?? {};
  Object.entries(props).forEach(([key, value]) => {
    if (SYS_KEYS.has(key))
      return;
    if (value === void 0)
      return;
    model[key] = value;
  });
  Object.entries(defaultProps).forEach(([key, value]) => {
    const notExists = !yBlock.has(`prop:${key}`) || yBlock.get(`prop:${key}`) === void 0;
    if (!notExists) {
      return;
    }
    model[key] = native2Y(value);
  });
}
var hash = (str) => {
  return str.split("").reduce((prevHash, currVal) => (prevHash << 5) - prevHash + currVal.charCodeAt(0) | 0, 0);
};

// node_modules/@blocksuite/store/dist/store/doc/consts.js
var BlockViewType;
(function(BlockViewType2) {
  BlockViewType2["Bypass"] = "bypass";
  BlockViewType2["Display"] = "display";
  BlockViewType2["Hidden"] = "hidden";
})(BlockViewType || (BlockViewType = {}));

// node_modules/lib0/mutex.js
var mutex_exports = {};
__export(mutex_exports, {
  createMutex: () => createMutex
});
var createMutex = () => {
  let token = true;
  return (f2, g2) => {
    if (token) {
      token = false;
      try {
        f2();
      } finally {
        token = true;
      }
    } else if (g2 !== void 0) {
      g2();
    }
  };
};

// node_modules/@blocksuite/store/dist/store/doc/block/sync-controller.js
var SyncController = class {
  constructor(schema, yBlock, doc2, onChange) {
    this.schema = schema;
    this.yBlock = yBlock;
    this.doc = doc2;
    this.onChange = onChange;
    this._byPassProxy = false;
    this._byPassUpdate = (fn) => {
      this._byPassProxy = true;
      fn();
      this._byPassProxy = false;
    };
    this._mutex = createMutex();
    this._observeYBlockChanges = () => {
      this.yBlock.observe((event) => {
        event.keysChanged.forEach((key) => {
          const type = event.changes.keys.get(key);
          if (!type) {
            return;
          }
          if (type.action === "update" || type.action === "add") {
            const value = this.yBlock.get(key);
            const keyName = key.replace("prop:", "");
            const proxy = this._getPropsProxy(keyName, value);
            this._byPassUpdate(() => {
              this.model[keyName] = proxy;
              const signalKey = `${keyName}$`;
              this._mutex(() => {
                if (signalKey in this.model) {
                  this.model[signalKey].value = y2Native(value);
                }
              });
            });
            this.onChange?.(keyName, value);
            return;
          }
          if (type.action === "delete") {
            const keyName = key.replace("prop:", "");
            this._byPassUpdate(() => {
              delete this.model[keyName];
              if (`${keyName}$` in this.model) {
                this.model[`${keyName}$`].value = void 0;
              }
            });
            this.onChange?.(keyName, void 0);
            return;
          }
        });
      });
    };
    this._stashed = /* @__PURE__ */ new Set();
    this.pop = (prop) => {
      if (!this._stashed.has(prop))
        return;
      this._popProp(prop);
    };
    this.stash = (prop) => {
      if (this._stashed.has(prop))
        return;
      this._stashed.add(prop);
      this._stashProp(prop);
    };
    const { id: id2, flavour, version, yChildren, props } = this._parseYBlock();
    this.id = id2;
    this.flavour = flavour;
    this.yChildren = yChildren;
    this.version = version;
    this.model = this._createModel(props);
    this._observeYBlockChanges();
  }
  _createModel(props) {
    const _mutex = this._mutex;
    const schema = this.schema.flavourSchemaMap.get(this.flavour);
    if (!schema) {
      throw new BlockSuiteError(ErrorCode.ModelCRUDError, `schema for flavour: ${this.flavour} not found`);
    }
    const model = schema.model.toModel?.() ?? new BlockModel();
    const signalWithProps = Object.entries(props).reduce((acc, [key, value]) => {
      const data = d(value);
      const dispose = E(() => {
        const value2 = data.value;
        if (!this.model)
          return;
        _mutex(() => {
          this.model[key] = value2;
        });
      });
      model.deleted.once(dispose);
      return {
        ...acc,
        [`${key}$`]: data,
        [key]: value
      };
    }, {});
    Object.assign(model, signalWithProps);
    model.id = this.id;
    model.version = this.version;
    model.keys = Object.keys(props);
    model.flavour = schema.model.flavour;
    model.role = schema.model.role;
    model.yBlock = this.yBlock;
    model.stash = this.stash;
    model.pop = this.pop;
    if (this.doc) {
      model.doc = this.doc;
    }
    const proxy = new Proxy(model, {
      has: (target, p2) => {
        return Reflect.has(target, p2);
      },
      set: (target, p2, value, receiver) => {
        if (!this._byPassProxy && typeof p2 === "string" && model.keys.includes(p2)) {
          if (this._stashed.has(p2)) {
            setValue(target, p2, value);
            const result = Reflect.set(target, p2, value, receiver);
            this.onChange?.(p2, value);
            return result;
          }
          const yValue = native2Y(value);
          this.yBlock.set(`prop:${p2}`, yValue);
          const proxy2 = this._getPropsProxy(p2, yValue);
          setValue(target, p2, value);
          return Reflect.set(target, p2, proxy2, receiver);
        }
        return Reflect.set(target, p2, value, receiver);
      },
      get: (target, p2, receiver) => {
        return Reflect.get(target, p2, receiver);
      },
      deleteProperty: (target, p2) => {
        if (!this._byPassProxy && typeof p2 === "string" && model.keys.includes(p2)) {
          this.yBlock.delete(`prop:${p2}`);
          setValue(target, p2, void 0);
        }
        return Reflect.deleteProperty(target, p2);
      }
    });
    function setValue(target, p2, value) {
      _mutex(() => {
        target[`${p2}$`].value = value;
      });
    }
    return proxy;
  }
  _getPropsProxy(name, value) {
    return createYProxy(value, {
      onChange: () => {
        this.onChange?.(name, value);
        const signalKey = `${name}$`;
        if (signalKey in this.model) {
          this._mutex(() => {
            this.model[signalKey].value = this.model[name];
          });
        }
      }
    });
  }
  _parseYBlock() {
    let id2;
    let flavour;
    let version;
    let yChildren;
    const props = {};
    this.yBlock.forEach((value, key) => {
      if (key.startsWith("prop:")) {
        const keyName = key.replace("prop:", "");
        props[keyName] = this._getPropsProxy(keyName, value);
        return;
      }
      if (key === "sys:id" && typeof value === "string") {
        id2 = value;
        return;
      }
      if (key === "sys:flavour" && typeof value === "string") {
        flavour = value;
        return;
      }
      if (key === "sys:children" && value instanceof YArray) {
        yChildren = value;
        return;
      }
      if (key === "sys:version" && typeof value === "number") {
        version = value;
        return;
      }
    });
    if (!id2) {
      throw new BlockSuiteError(ErrorCode.ModelCRUDError, "block id is not found when creating model");
    }
    if (!flavour) {
      throw new BlockSuiteError(ErrorCode.ModelCRUDError, "block flavour is not found when creating model");
    }
    if (!yChildren) {
      throw new BlockSuiteError(ErrorCode.ModelCRUDError, "block children is not found when creating model");
    }
    const schema = this.schema.flavourSchemaMap.get(flavour);
    if (!schema) {
      throw new BlockSuiteError(ErrorCode.ModelCRUDError, `schema for flavour: ${flavour} not found`);
    }
    const defaultProps = schema.model.props?.(internalPrimitives);
    if (typeof version !== "number") {
      version = schema.version;
    }
    if (defaultProps) {
      Object.entries(defaultProps).forEach(([key, value]) => {
        if (key in props)
          return;
        const yValue = native2Y(value);
        this.yBlock.set(`prop:${key}`, yValue);
        props[key] = this._getPropsProxy(key, yValue);
      });
    }
    return {
      id: id2,
      flavour,
      version,
      props,
      yChildren
    };
  }
  _popProp(prop) {
    const model = this.model;
    const value = model[prop];
    this._stashed.delete(prop);
    model[prop] = value;
  }
  _stashProp(prop) {
    this.model[prop] = y2Native(this.yBlock.get(`prop:${prop}`), {
      transform: (value, origin) => {
        if (Boxed.is(origin)) {
          return value;
        }
        if (origin instanceof YMap) {
          return new Proxy(value, {
            get: (target, p2, receiver) => {
              return Reflect.get(target, p2, receiver);
            },
            set: (target, p2, value2, receiver) => {
              const result = Reflect.set(target, p2, value2, receiver);
              this.onChange?.(prop, value2);
              return result;
            },
            deleteProperty: (target, p2) => {
              const result = Reflect.deleteProperty(target, p2);
              this.onChange?.(prop, void 0);
              return result;
            }
          });
        }
        if (origin instanceof YArray) {
          return new Proxy(value, {
            get: (target, p2, receiver) => {
              return Reflect.get(target, p2, receiver);
            },
            set: (target, p2, value2, receiver) => {
              const index = Number(p2);
              if (Number.isNaN(index)) {
                return Reflect.set(target, p2, value2, receiver);
              }
              const result = Reflect.set(target, p2, value2, receiver);
              this.onChange?.(prop, value2);
              return result;
            },
            deleteProperty: (target, p2) => {
              const result = Reflect.deleteProperty(target, p2);
              this.onChange?.(p2, void 0);
              return result;
            }
          });
        }
        return value;
      }
    });
  }
};

// node_modules/@blocksuite/store/dist/store/doc/block/index.js
var Block = class {
  get flavour() {
    return this._syncController.flavour;
  }
  get id() {
    return this._syncController.id;
  }
  get model() {
    return this._syncController.model;
  }
  get pop() {
    return this._syncController.pop;
  }
  get stash() {
    return this._syncController.stash;
  }
  get version() {
    return this._syncController.version;
  }
  constructor(schema, yBlock, doc2, options = {}) {
    this.schema = schema;
    this.yBlock = yBlock;
    this.doc = doc2;
    this.options = options;
    this.blockViewType = BlockViewType.Display;
    const onChange = !options.onChange ? void 0 : (key, value) => {
      options.onChange?.(this, key, value);
    };
    this._syncController = new SyncController(schema, yBlock, doc2, onChange);
  }
};

// node_modules/@blocksuite/store/dist/store/doc/query.js
var import_lodash3 = __toESM(require_lodash3(), 1);
function runQuery(query, block) {
  const blockViewType = getBlockViewType(query, block);
  block.blockViewType = blockViewType;
  if (blockViewType !== BlockViewType.Hidden) {
    const queryMode = query.mode;
    setAncestorsToDisplayIfHidden(queryMode, block);
  }
}
function getBlockViewType(query, block) {
  const flavour = block.model.flavour;
  const id2 = block.model.id;
  const queryMode = query.mode;
  const props = block.model.keys.reduce((acc, key) => {
    return {
      ...acc,
      [key]: block.model[key]
    };
  }, {});
  let blockViewType = queryMode === "loose" ? BlockViewType.Display : BlockViewType.Hidden;
  query.match.some((queryObject) => {
    const { id: queryId, flavour: queryFlavour, props: queryProps, viewType } = queryObject;
    const matchQueryId = queryId == null ? true : queryId === id2;
    const matchQueryFlavour = queryFlavour == null ? true : queryFlavour === flavour;
    const matchQueryProps = queryProps == null ? true : (0, import_lodash3.default)(props, queryProps);
    if (matchQueryId && matchQueryFlavour && matchQueryProps) {
      blockViewType = viewType;
      return true;
    }
    return false;
  });
  return blockViewType;
}
function setAncestorsToDisplayIfHidden(mode, block) {
  const doc2 = block.model.doc;
  let parent = doc2.getParent(block.model);
  while (parent) {
    const parentBlock = doc2.getBlock(parent.id);
    if (parentBlock && parentBlock.blockViewType === BlockViewType.Hidden) {
      parentBlock.blockViewType = mode === "include" ? BlockViewType.Display : BlockViewType.Bypass;
    }
    parent = doc2.getParent(parent);
  }
}

// node_modules/@blocksuite/store/dist/store/doc/doc.js
var Doc2 = class {
  get _yBlocks() {
    return this._blockCollection.yBlocks;
  }
  get awarenessStore() {
    return this._blockCollection.awarenessStore;
  }
  get awarenessSync() {
    return this.collection.awarenessSync;
  }
  get blobSync() {
    return this.collection.blobSync;
  }
  get blockCollection() {
    return this._blockCollection;
  }
  get blocks() {
    return this._blocks;
  }
  get blockSize() {
    return Object.values(this._blocks.peek()).length;
  }
  get canRedo() {
    return this._blockCollection.canRedo;
  }
  get canUndo() {
    return this._blockCollection.canUndo;
  }
  get captureSync() {
    return this._blockCollection.captureSync.bind(this._blockCollection);
  }
  get clear() {
    return this._blockCollection.clear.bind(this._blockCollection);
  }
  get collection() {
    return this._blockCollection.collection;
  }
  get docSync() {
    return this.collection.docSync;
  }
  get generateBlockId() {
    return this._blockCollection.generateBlockId.bind(this._blockCollection);
  }
  get history() {
    return this._blockCollection.history;
  }
  get id() {
    return this._blockCollection.id;
  }
  get isEmpty() {
    return Object.values(this._blocks.peek()).length === 0;
  }
  get loaded() {
    return this._blockCollection.loaded;
  }
  get meta() {
    return this._blockCollection.meta;
  }
  get readonly() {
    if (this._blockCollection.readonly) {
      return true;
    }
    return this._readonly === true;
  }
  get ready() {
    return this._blockCollection.ready;
  }
  get redo() {
    return this._blockCollection.redo.bind(this._blockCollection);
  }
  get resetHistory() {
    return this._blockCollection.resetHistory.bind(this._blockCollection);
  }
  get root() {
    const rootId = this._crud.root;
    if (!rootId)
      return null;
    return this.getBlock(rootId)?.model ?? null;
  }
  get rootDoc() {
    return this._blockCollection.rootDoc;
  }
  get schema() {
    return this._schema;
  }
  get spaceDoc() {
    return this._blockCollection.spaceDoc;
  }
  get Text() {
    return this._blockCollection.Text;
  }
  get transact() {
    return this._blockCollection.transact.bind(this._blockCollection);
  }
  get undo() {
    return this._blockCollection.undo.bind(this._blockCollection);
  }
  get withoutTransact() {
    return this._blockCollection.withoutTransact.bind(this._blockCollection);
  }
  constructor({ schema, blockCollection, crud, readonly, query }) {
    this._runQuery = (block) => {
      runQuery(this._query, block);
    };
    this._blocks = d({});
    this._query = {
      match: [],
      mode: "loose"
    };
    this.updateBlock = (model, callBackOrProps) => {
      if (this.readonly) {
        console.error("cannot modify data in readonly mode");
        return;
      }
      const isCallback = typeof callBackOrProps === "function";
      if (!isCallback) {
        const parent = this.getParent(model);
        this.schema.validate(model.flavour, parent?.flavour, callBackOrProps.children?.map((child) => child.flavour));
      }
      const yBlock = this._yBlocks.get(model.id);
      if (!yBlock) {
        throw new BlockSuiteError(ErrorCode.ModelCRUDError, `updating block: ${model.id} not found`);
      }
      const block = this.getBlock(model.id);
      if (!block)
        return;
      this.transact(() => {
        if (isCallback) {
          callBackOrProps();
          this._runQuery(block);
          return;
        }
        if (callBackOrProps.children) {
          this._crud.updateBlockChildren(model.id, callBackOrProps.children.map((child) => child.id));
        }
        const schema2 = this.schema.flavourSchemaMap.get(model.flavour);
        if (!schema2) {
          throw new BlockSuiteError(ErrorCode.ModelCRUDError, `schema for flavour: ${model.flavour} not found`);
        }
        syncBlockProps(schema2, model, yBlock, callBackOrProps);
        this._runQuery(block);
        return;
      });
    };
    this._blockCollection = blockCollection;
    this.slots = {
      ready: new Slot(),
      rootAdded: new Slot(),
      rootDeleted: new Slot(),
      blockUpdated: new Slot(),
      historyUpdated: this._blockCollection.slots.historyUpdated,
      yBlockUpdated: this._blockCollection.slots.yBlockUpdated
    };
    this._crud = crud;
    this._schema = schema;
    this._readonly = readonly;
    if (query) {
      this._query = query;
    }
    this._yBlocks.forEach((_2, id2) => {
      if (id2 in this._blocks.peek()) {
        return;
      }
      this._onBlockAdded(id2, true);
    });
    this._disposeBlockUpdated = this._blockCollection.slots.yBlockUpdated.on(({ type, id: id2 }) => {
      switch (type) {
        case "add": {
          this._onBlockAdded(id2);
          return;
        }
        case "delete": {
          this._onBlockRemoved(id2);
          return;
        }
      }
    });
  }
  _getSiblings(block, fn) {
    const parent = this.getParent(block);
    if (!parent)
      return null;
    const blockModel = typeof block === "string" ? this.getBlock(block)?.model : block;
    if (!blockModel)
      return null;
    const index = parent.children.indexOf(blockModel);
    if (index === -1)
      return null;
    return fn(parent, index);
  }
  _onBlockAdded(id2, init = false) {
    try {
      if (id2 in this._blocks.peek()) {
        return;
      }
      const yBlock = this._yBlocks.get(id2);
      if (!yBlock) {
        console.warn(`Could not find block with id ${id2}`);
        return;
      }
      const options = {
        onChange: (block2, key) => {
          if (key) {
            block2.model.propsUpdated.emit({ key });
          }
          this.slots.blockUpdated.emit({
            type: "update",
            id: id2,
            flavour: block2.flavour,
            props: { key }
          });
        }
      };
      const block = new Block(this._schema, yBlock, this, options);
      this._runQuery(block);
      this._blocks.value = {
        ...this._blocks.value,
        [id2]: block
      };
      block.model.created.emit();
      if (block.model.role === "root") {
        this.slots.rootAdded.emit(id2);
      }
      this.slots.blockUpdated.emit({
        type: "add",
        id: id2,
        init,
        flavour: block.model.flavour,
        model: block.model
      });
    } catch (e2) {
      console.error("An error occurred while adding block:");
      console.error(e2);
    }
  }
  _onBlockRemoved(id2) {
    try {
      const block = this.getBlock(id2);
      if (!block)
        return;
      if (block.model.role === "root") {
        this.slots.rootDeleted.emit(id2);
      }
      this.slots.blockUpdated.emit({
        type: "delete",
        id: id2,
        flavour: block.model.flavour,
        parent: this.getParent(block.model)?.id ?? "",
        model: block.model
      });
      const { [id2]: _2, ...blocks } = this._blocks.peek();
      this._blocks.value = blocks;
      block.model.deleted.emit();
      block.model.dispose();
    } catch (e2) {
      console.error("An error occurred while removing block:");
      console.error(e2);
    }
  }
  addBlock(flavour, blockProps = {}, parent, parentIndex) {
    if (this.readonly) {
      throw new BlockSuiteError(ErrorCode.ModelCRUDError, "cannot modify data in readonly mode");
    }
    const id2 = blockProps.id ?? this._blockCollection.generateBlockId();
    this.transact(() => {
      this._crud.addBlock(id2, flavour, { ...blockProps }, typeof parent === "string" ? parent : parent?.id, parentIndex);
    });
    return id2;
  }
  addBlocks(blocks, parent, parentIndex) {
    const ids = [];
    blocks.forEach((block) => {
      const id2 = this.addBlock(block.flavour, block.blockProps ?? {}, parent, parentIndex);
      ids.push(id2);
      typeof parentIndex === "number" && parentIndex++;
    });
    return ids;
  }
  addSiblingBlocks(targetModel, props, place = "after") {
    if (!props.length)
      return [];
    const parent = this.getParent(targetModel);
    if (!parent)
      return [];
    const targetIndex = parent.children.findIndex(({ id: id2 }) => id2 === targetModel.id) ?? 0;
    const insertIndex = place === "before" ? targetIndex : targetIndex + 1;
    if (props.length <= 1) {
      if (!props[0]?.flavour)
        return [];
      const { flavour, ...blockProps } = props[0];
      const id2 = this.addBlock(flavour, blockProps, parent.id, insertIndex);
      return [id2];
    }
    const blocks = [];
    props.forEach((prop) => {
      const { flavour, ...blockProps } = prop;
      if (!flavour)
        return;
      blocks.push({ flavour, blockProps });
    });
    return this.addBlocks(blocks, parent.id, insertIndex);
  }
  deleteBlock(model, options = {
    deleteChildren: true
  }) {
    if (this.readonly) {
      console.error("cannot modify data in readonly mode");
      return;
    }
    const opts = options && options.bringChildrenTo ? {
      ...options,
      bringChildrenTo: options.bringChildrenTo.id
    } : options;
    this.transact(() => {
      this._crud.deleteBlock(model.id, opts);
    });
  }
  dispose() {
    this._disposeBlockUpdated.dispose();
    this.slots.ready.dispose();
    this.slots.blockUpdated.dispose();
    this.slots.rootAdded.dispose();
    this.slots.rootDeleted.dispose();
  }
  getBlock(id2) {
    return this._blocks.peek()[id2];
  }
  getBlock$(id2) {
    return this._blocks.value[id2];
  }
  /**
   * @deprecated
   * Use `getBlocksByFlavour` instead.
   */
  getBlockByFlavour(blockFlavour) {
    return this.getBlocksByFlavour(blockFlavour).map((x) => x.model);
  }
  /**
   * @deprecated
   * Use `getBlock` instead.
   */
  getBlockById(id2) {
    return this.getBlock(id2)?.model ?? null;
  }
  getBlocks() {
    return Object.values(this._blocks.peek()).map((block) => block.model);
  }
  getBlocksByFlavour(blockFlavour) {
    const flavours = typeof blockFlavour === "string" ? [blockFlavour] : blockFlavour;
    return Object.values(this._blocks.peek()).filter(({ flavour }) => flavours.includes(flavour));
  }
  getNext(block) {
    return this._getSiblings(block, (parent, index) => parent.children[index + 1] ?? null);
  }
  getNexts(block) {
    return this._getSiblings(block, (parent, index) => parent.children.slice(index + 1)) ?? [];
  }
  getParent(target) {
    const targetId = typeof target === "string" ? target : target.id;
    const parentId = this._crud.getParent(targetId);
    if (!parentId)
      return null;
    const parent = this._blocks.peek()[parentId];
    if (!parent)
      return null;
    return parent.model;
  }
  getPrev(block) {
    return this._getSiblings(block, (parent, index) => parent.children[index - 1] ?? null);
  }
  getPrevs(block) {
    return this._getSiblings(block, (parent, index) => parent.children.slice(0, index)) ?? [];
  }
  getSchemaByFlavour(flavour) {
    return this._schema.flavourSchemaMap.get(flavour);
  }
  hasBlock(id2) {
    return id2 in this._blocks.peek();
  }
  /**
   * @deprecated
   * Use `hasBlock` instead.
   */
  hasBlockById(id2) {
    return this.hasBlock(id2);
  }
  load(initFn) {
    this._blockCollection.load(initFn);
    this.slots.ready.emit();
    return this;
  }
  moveBlocks(blocksToMove, newParent, targetSibling = null, shouldInsertBeforeSibling = true) {
    if (this.readonly) {
      console.error("Cannot modify data in read-only mode");
      return;
    }
    this.transact(() => {
      this._crud.moveBlocks(blocksToMove.map((model) => model.id), newParent.id, targetSibling?.id ?? null, shouldInsertBeforeSibling);
    });
  }
};

// node_modules/@blocksuite/store/dist/store/doc/block-collection.js
var BlockCollection = class {
  // So, we apply a listener at the top level for the flat structure of the current
  get awarenessSync() {
    return this.collection.awarenessSync;
  }
  get blobSync() {
    return this.collection.blobSync;
  }
  get canRedo() {
    return this._canRedo$.peek();
  }
  get canRedo$() {
    return this._canRedo$;
  }
  get canUndo() {
    return this._canUndo$.peek();
  }
  get canUndo$() {
    return this._canUndo$;
  }
  get collection() {
    return this._collection;
  }
  get crud() {
    return this._docCRUD;
  }
  get docSync() {
    return this.collection.docSync;
  }
  get history() {
    return this._history;
  }
  get isEmpty() {
    return this._yBlocks.size === 0;
  }
  get loaded() {
    return this._loaded;
  }
  get meta() {
    return this.collection.meta.getDocMeta(this.id);
  }
  get readonly() {
    return this.awarenessStore.isReadonly(this);
  }
  get ready() {
    return this._ready;
  }
  get schema() {
    return this.collection.schema;
  }
  get spaceDoc() {
    return this._ySpaceDoc;
  }
  get Text() {
    return Text;
  }
  get yBlocks() {
    return this._yBlocks;
  }
  constructor({ id: id2, collection, doc: doc2, awarenessStore, idGenerator = uuidv4 }) {
    this._awarenessUpdateDisposable = null;
    this._canRedo$ = d(false);
    this._canUndo$ = d(false);
    this._docMap = {
      undefined: /* @__PURE__ */ new Map(),
      true: /* @__PURE__ */ new Map(),
      false: /* @__PURE__ */ new Map()
    };
    this._handleYEvents = (events) => {
      events.forEach((event) => this._handleYEvent(event));
    };
    this._historyObserver = () => {
      this._updateCanUndoRedoSignals();
      this.slots.historyUpdated.emit();
    };
    this._initSubDoc = () => {
      let subDoc = this.rootDoc.spaces.get(this.id);
      if (!subDoc) {
        subDoc = new Doc({
          guid: this.id
        });
        this.rootDoc.spaces.set(this.id, subDoc);
        this._loaded = true;
        this._onLoadSlot.emit();
      } else {
        this._loaded = false;
        this.rootDoc.on("subdocs", this._onSubdocEvent);
      }
      return subDoc;
    };
    this._onLoadSlot = new Slot();
    this._onSubdocEvent = ({ loaded }) => {
      const result = Array.from(loaded).find((doc3) => doc3.guid === this._ySpaceDoc.guid);
      if (!result) {
        return;
      }
      this.rootDoc.off("subdocs", this._onSubdocEvent);
      this._loaded = true;
      this._onLoadSlot.emit();
    };
    this._ready = false;
    this._shouldTransact = true;
    this._updateCanUndoRedoSignals = () => {
      const canRedo = this.readonly ? false : this._history.canRedo();
      const canUndo = this.readonly ? false : this._history.canUndo();
      if (this._canRedo$.peek() !== canRedo) {
        this._canRedo$.value = canRedo;
      }
      if (this._canUndo$.peek() !== canUndo) {
        this._canUndo$.value = canUndo;
      }
    };
    this.slots = {
      historyUpdated: new Slot(),
      yBlockUpdated: new Slot()
    };
    this.id = id2;
    this.rootDoc = doc2;
    this.awarenessStore = awarenessStore;
    this._ySpaceDoc = this._initSubDoc();
    this._yBlocks = this._ySpaceDoc.getMap("blocks");
    this._collection = collection;
    this._idGenerator = idGenerator;
    this._docCRUD = new DocCRUD(this._yBlocks, collection.schema);
  }
  _getReadonlyKey(readonly) {
    return readonly?.toString() ?? "undefined";
  }
  _handleVersion() {
    if (!this.collection.meta.hasVersion) {
      this.collection.meta.writeVersion(this.collection);
    } else {
      if (this.awarenessStore.getFlag("enable_legacy_validation")) {
        this.collection.meta.validateVersion(this.collection);
      }
    }
  }
  _handleYBlockAdd(id2) {
    this.slots.yBlockUpdated.emit({ type: "add", id: id2 });
  }
  _handleYBlockDelete(id2) {
    this.slots.yBlockUpdated.emit({ type: "delete", id: id2 });
  }
  _handleYEvent(event) {
    if (event.target !== this._yBlocks) {
      return;
    }
    event.keys.forEach((value, id2) => {
      try {
        if (value.action === "add") {
          this._handleYBlockAdd(id2);
          return;
        }
        if (value.action === "delete") {
          this._handleYBlockDelete(id2);
          return;
        }
      } catch (e2) {
        console.error("An error occurred while handling Yjs event:");
        console.error(e2);
      }
    });
  }
  _initYBlocks() {
    const { _yBlocks } = this;
    _yBlocks.observeDeep(this._handleYEvents);
    this._history = new UndoManager([_yBlocks], {
      trackedOrigins: /* @__PURE__ */ new Set([this._ySpaceDoc.clientID])
    });
    this._history.on("stack-cleared", this._historyObserver);
    this._history.on("stack-item-added", this._historyObserver);
    this._history.on("stack-item-popped", this._historyObserver);
    this._history.on("stack-item-updated", this._historyObserver);
  }
  /** Capture current operations to undo stack synchronously. */
  captureSync() {
    this._history.stopCapturing();
  }
  clear() {
    this._yBlocks.clear();
  }
  clearQuery(query, readonly) {
    const readonlyKey = this._getReadonlyKey(readonly);
    this._docMap[readonlyKey].delete(JSON.stringify(query));
  }
  destroy() {
    this._ySpaceDoc.destroy();
    this._onLoadSlot.dispose();
    this._loaded = false;
  }
  dispose() {
    this.slots.historyUpdated.dispose();
    this._awarenessUpdateDisposable?.dispose();
    if (this.ready) {
      this._yBlocks.unobserveDeep(this._handleYEvents);
      this._yBlocks.clear();
    }
  }
  generateBlockId() {
    return this._idGenerator();
  }
  getDoc({ readonly, query } = {}) {
    const readonlyKey = this._getReadonlyKey(readonly);
    const key = JSON.stringify(query);
    if (this._docMap[readonlyKey].has(key)) {
      return this._docMap[readonlyKey].get(key);
    }
    const doc2 = new Doc2({
      blockCollection: this,
      crud: this._docCRUD,
      schema: this.collection.schema,
      readonly,
      query
    });
    this._docMap[readonlyKey].set(key, doc2);
    return doc2;
  }
  load(initFn) {
    if (this.ready) {
      return this;
    }
    this._ySpaceDoc.load();
    if ((this.collection.meta.docs?.length ?? 0) <= 1) {
      this._handleVersion();
    }
    this._initYBlocks();
    this._yBlocks.forEach((_2, id2) => {
      this._handleYBlockAdd(id2);
    });
    this._awarenessUpdateDisposable = this.awarenessStore.slots.update.on(() => {
      this._updateCanUndoRedoSignals();
    });
    initFn?.();
    this._ready = true;
    return this;
  }
  redo() {
    if (this.readonly) {
      console.error("cannot modify data in readonly mode");
      return;
    }
    this._history.redo();
  }
  remove() {
    this.destroy();
    this.rootDoc.spaces.delete(this.id);
  }
  resetHistory() {
    this._history.clear();
  }
  /**
   * If `shouldTransact` is `false`, the transaction will not be push to the history stack.
   */
  transact(fn, shouldTransact = this._shouldTransact) {
    this._ySpaceDoc.transact(() => {
      try {
        fn();
      } catch (e2) {
        console.error(`An error occurred while Y.doc ${this._ySpaceDoc.guid} transacting:`);
        console.error(e2);
      }
    }, shouldTransact ? this.rootDoc.clientID : null);
  }
  // Handle all the events that happen at _any_ level (potentially deep inside the structure).
  undo() {
    if (this.readonly) {
      console.error("cannot modify data in readonly mode");
      return;
    }
    this._history.undo();
  }
  withoutTransact(callback) {
    this._shouldTransact = false;
    callback();
    this._shouldTransact = true;
  }
};

// node_modules/nanoid/url-alphabet/index.js
var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";

// node_modules/nanoid/index.browser.js
var nanoid = (size2 = 21) => {
  let id2 = "";
  let bytes = crypto.getRandomValues(new Uint8Array(size2 |= 0));
  while (size2--) {
    id2 += urlAlphabet[bytes[size2] & 63];
  }
  return id2;
};

// node_modules/@blocksuite/store/dist/utils/id-generator.js
function createAutoIncrementIdGenerator() {
  let i2 = 0;
  return () => (i2++).toString();
}
function createAutoIncrementIdGeneratorByClientId(clientId) {
  let i2 = 0;
  return () => `${clientId}:${i2++}`;
}
var uuidv42 = () => {
  return uuidv4();
};
var nanoid2 = () => {
  return nanoid(10);
};

// node_modules/@blocksuite/store/dist/store/id.js
var IdGeneratorType;
(function(IdGeneratorType2) {
  IdGeneratorType2["AutoIncrement"] = "autoIncrement";
  IdGeneratorType2["AutoIncrementByClientId"] = "autoIncrementByClientId";
  IdGeneratorType2["NanoID"] = "nanoID";
  IdGeneratorType2["UUIDv4"] = "uuidV4";
})(IdGeneratorType || (IdGeneratorType = {}));
function pickIdGenerator(idGenerator, clientId) {
  if (typeof idGenerator === "function") {
    return idGenerator;
  }
  switch (idGenerator) {
    case IdGeneratorType.AutoIncrement: {
      return createAutoIncrementIdGenerator();
    }
    case IdGeneratorType.AutoIncrementByClientId: {
      return createAutoIncrementIdGeneratorByClientId(clientId);
    }
    case IdGeneratorType.UUIDv4: {
      return uuidv42;
    }
    case IdGeneratorType.NanoID:
    default: {
      return nanoid2;
    }
  }
}

// node_modules/@blocksuite/store/dist/store/meta.js
var DocCollectionMeta = class {
  get avatar() {
    return this._proxy.avatar;
  }
  get blockVersions() {
    return this._proxy.blockVersions;
  }
  get docMetas() {
    if (!this._proxy.pages) {
      return [];
    }
    return this._proxy.pages;
  }
  get docs() {
    return this._proxy.pages;
  }
  get hasVersion() {
    if (!this.blockVersions || !this.pageVersion || !this.workspaceVersion) {
      return false;
    }
    return Object.keys(this.blockVersions).length > 0;
  }
  get name() {
    return this._proxy.name;
  }
  get pageVersion() {
    return this._proxy.pageVersion;
  }
  get properties() {
    const meta = this._proxy.properties;
    if (!meta) {
      return {
        tags: {
          options: []
        }
      };
    }
    return meta;
  }
  get workspaceVersion() {
    return this._proxy.workspaceVersion;
  }
  get yDocs() {
    return this._yMap.get("pages");
  }
  constructor(doc2) {
    this._handleDocCollectionMetaEvents = (events) => {
      events.forEach((e2) => {
        const hasKey = (k) => e2.target === this._yMap && e2.changes.keys.has(k);
        if (e2.target === this.yDocs || e2.target.parent === this.yDocs || hasKey("pages")) {
          this._handleDocMetaEvent();
        }
        if (hasKey("name") || hasKey("avatar")) {
          this._handleCommonFieldsEvent();
        }
      });
    };
    this._prevDocs = /* @__PURE__ */ new Set();
    this.commonFieldsUpdated = new Slot();
    this.docMetaAdded = new Slot();
    this.docMetaRemoved = new Slot();
    this.docMetaUpdated = new Slot();
    this.id = "meta";
    this.doc = doc2;
    this._yMap = doc2.getMap(this.id);
    this._proxy = doc2.getMapProxy(this.id);
    this._yMap.observeDeep(this._handleDocCollectionMetaEvents);
  }
  _handleCommonFieldsEvent() {
    this.commonFieldsUpdated.emit();
  }
  _handleDocMetaEvent() {
    const { docMetas, _prevDocs } = this;
    const newDocs = /* @__PURE__ */ new Set();
    docMetas.forEach((docMeta) => {
      if (!_prevDocs.has(docMeta.id)) {
        this.docMetaAdded.emit(docMeta.id);
      }
      newDocs.add(docMeta.id);
    });
    _prevDocs.forEach((prevDocId) => {
      const isRemoved = newDocs.has(prevDocId) === false;
      if (isRemoved) {
        this.docMetaRemoved.emit(prevDocId);
      }
    });
    this._prevDocs = newDocs;
    this.docMetaUpdated.emit();
  }
  addDocMeta(doc2, index) {
    this.doc.transact(() => {
      if (!this.docs) {
        return;
      }
      const docs = this.docs;
      if (index === void 0) {
        docs.push(doc2);
      } else {
        docs.splice(index, 0, doc2);
      }
    }, this.doc.clientID);
  }
  getDocMeta(id2) {
    return this.docMetas.find((doc2) => doc2.id === id2);
  }
  initialize() {
    if (!this._proxy.pages) {
      this._proxy.pages = [];
    }
  }
  removeDocMeta(id2) {
    if (!this.docs) {
      return;
    }
    const docMeta = this.docMetas;
    const index = docMeta.findIndex((doc2) => id2 === doc2.id);
    if (index === -1) {
      return;
    }
    this.doc.transact(() => {
      if (!this.docs) {
        return;
      }
      this.docs.splice(index, 1);
    }, this.doc.clientID);
  }
  setAvatar(avatar) {
    this.doc.transact(() => {
      this._proxy.avatar = avatar;
    }, this.doc.clientID);
  }
  setDocMeta(id2, props) {
    const docs = this.docs ?? [];
    const index = docs.findIndex((doc2) => id2 === doc2.id);
    this.doc.transact(() => {
      if (!this.docs) {
        return;
      }
      if (index === -1)
        return;
      const doc2 = this.docs[index];
      Object.entries(props).forEach(([key, value]) => {
        doc2[key] = value;
      });
    }, this.doc.clientID);
  }
  setName(name) {
    this.doc.transact(() => {
      this._proxy.name = name;
    }, this.doc.clientID);
  }
  setProperties(meta) {
    this._proxy.properties = meta;
    this.docMetaUpdated.emit();
  }
  /**
   * @deprecated Only used for legacy doc version validation
   */
  validateVersion(collection) {
    const workspaceVersion = this._proxy.workspaceVersion;
    if (!workspaceVersion) {
      throw new BlockSuiteError(ErrorCode.DocCollectionError, "Invalid workspace data, workspace version is missing. Please make sure the data is valid.");
    }
    if (workspaceVersion < COLLECTION_VERSION) {
      throw new BlockSuiteError(ErrorCode.DocCollectionError, `Workspace version ${workspaceVersion} is outdated. Please upgrade the editor.`);
    }
    const pageVersion = this._proxy.pageVersion;
    if (!pageVersion) {
      throw new BlockSuiteError(ErrorCode.DocCollectionError, "Invalid workspace data, page version is missing. Please make sure the data is valid.");
    }
    if (pageVersion < PAGE_VERSION) {
      throw new BlockSuiteError(ErrorCode.DocCollectionError, `Doc version ${pageVersion} is outdated. Please upgrade the editor.`);
    }
    const blockVersions = { ...this._proxy.blockVersions };
    if (!blockVersions) {
      throw new BlockSuiteError(ErrorCode.DocCollectionError, "Invalid workspace data, versions data is missing. Please make sure the data is valid");
    }
    const dataFlavours = Object.keys(blockVersions);
    if (dataFlavours.length === 0) {
      throw new BlockSuiteError(ErrorCode.DocCollectionError, "Invalid workspace data, missing versions field. Please make sure the data is valid.");
    }
    dataFlavours.forEach((dataFlavour) => {
      const dataVersion = blockVersions[dataFlavour];
      const editorVersion = collection.schema.flavourSchemaMap.get(dataFlavour)?.version;
      if (!editorVersion) {
        throw new BlockSuiteError(ErrorCode.DocCollectionError, `Editor missing ${dataFlavour} flavour. Please make sure this block flavour is registered.`);
      } else if (dataVersion > editorVersion) {
        throw new BlockSuiteError(ErrorCode.DocCollectionError, `Editor doesn't support ${dataFlavour}@${dataVersion}. Please upgrade the editor.`);
      } else if (dataVersion < editorVersion) {
        throw new BlockSuiteError(ErrorCode.DocCollectionError, `In workspace data, the block flavour ${dataFlavour}@${dataVersion} is outdated. Please downgrade the editor or try data migration.`);
      }
    });
  }
  /**
   * @internal Only for doc initialization
   */
  writeVersion(collection) {
    const { blockVersions, pageVersion, workspaceVersion } = this._proxy;
    if (!workspaceVersion) {
      this._proxy.workspaceVersion = COLLECTION_VERSION;
    } else {
      console.error("Workspace version is already set");
    }
    if (!pageVersion) {
      this._proxy.pageVersion = PAGE_VERSION;
    } else {
      console.error("Doc version is already set");
    }
    if (!blockVersions) {
      const _versions = {};
      collection.schema.flavourSchemaMap.forEach((schema, flavour) => {
        _versions[flavour] = schema.version;
      });
      this._proxy.blockVersions = _versions;
    } else {
      console.error("Block versions is already set");
    }
  }
};

// node_modules/@blocksuite/store/dist/store/collection.js
var __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f2) {
    if (f2 !== void 0 && typeof f2 !== "function") throw new TypeError("Function expected");
    return f2;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _2, done = false;
  for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
    var context = {};
    for (var p2 in contextIn) context[p2] = p2 === "access" ? {} : contextIn[p2];
    for (var p2 in contextIn.access) context.access[p2] = contextIn.access[p2];
    context.addInitializer = function(f2) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f2 || null));
    };
    var result = (0, decorators[i2])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_2 = accept(result.get)) descriptor.get = _2;
      if (_2 = accept(result.set)) descriptor.set = _2;
      if (_2 = accept(result.init)) initializers.unshift(_2);
    } else if (_2 = accept(result)) {
      if (kind === "field") initializers.unshift(_2);
      else descriptor[key] = _2;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var __runInitializers = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i2 = 0; i2 < initializers.length; i2++) {
    value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
  }
  return useValue ? value : void 0;
};
var FLAGS_PRESET = {
  enable_synced_doc_block: false,
  enable_pie_menu: false,
  enable_database_number_formatting: false,
  enable_database_attachment_note: false,
  enable_database_full_width: false,
  enable_legacy_validation: true,
  enable_block_query: false,
  enable_lasso_tool: false,
  enable_edgeless_text: true,
  enable_ai_onboarding: false,
  enable_ai_chat_block: false,
  enable_color_picker: false,
  enable_mind_map_import: false,
  enable_advanced_block_visibility: false,
  enable_shape_shadow_blur: false,
  enable_new_dnd: true,
  enable_mobile_keyboard_toolbar: false,
  enable_mobile_linked_doc_menu: false,
  readonly: {}
};
var DocCollection = (() => {
  var _a2;
  let _classDecorators = [test];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _classSuper = DocCollectionAddonType;
  var DocCollection2 = (_a2 = class extends _classSuper {
    get docs() {
      return this.blockCollections;
    }
    get isEmpty() {
      if (this.doc.store.clients.size === 0)
        return true;
      let flag = false;
      if (this.doc.store.clients.size === 1) {
        const items = Array.from(this.doc.store.clients.values())[0];
        if (items.length <= 2) {
          flag = true;
        }
      }
      return flag;
    }
    get schema() {
      return this._schema;
    }
    constructor({ id: id2, schema, idGenerator, defaultFlags, awarenessSources = [], docSources = {
      main: new NoopDocSource()
    }, blobSources = {
      main: new MemoryBlobSource()
    }, logger = new NoopLogger() }) {
      super();
      this.blockCollections = /* @__PURE__ */ new Map();
      this.slots = {
        docAdded: new Slot(),
        docUpdated: new Slot(),
        docRemoved: new Slot(),
        docCreated: new Slot()
      };
      this._schema = schema;
      this.id = id2 || "";
      this.doc = new BlockSuiteDoc({ guid: id2 });
      this.awarenessStore = new AwarenessStore(new Awareness(this.doc), (0, import_lodash5.default)((0, import_lodash4.default)(FLAGS_PRESET), defaultFlags));
      this.awarenessSync = new AwarenessEngine(this.awarenessStore.awareness, awarenessSources);
      this.docSync = new DocEngine(this.doc, docSources.main, docSources.shadows ?? [], logger);
      this.blobSync = new BlobEngine(blobSources.main, blobSources.shadows ?? [], logger);
      this.idGenerator = pickIdGenerator(idGenerator, this.doc.clientID);
      this.meta = new DocCollectionMeta(this.doc);
      this._bindDocMetaEvents();
    }
    _bindDocMetaEvents() {
      this.meta.docMetaAdded.on((docId) => {
        const doc2 = new BlockCollection({
          id: docId,
          collection: this,
          doc: this.doc,
          awarenessStore: this.awarenessStore,
          idGenerator: this.idGenerator
        });
        this.blockCollections.set(doc2.id, doc2);
        this.slots.docAdded.emit(doc2.id);
      });
      this.meta.docMetaUpdated.on(() => this.slots.docUpdated.emit());
      this.meta.docMetaRemoved.on((id2) => {
        const space = this.getBlockCollection(id2);
        if (!space)
          return;
        this.blockCollections.delete(id2);
        space.remove();
        this.slots.docRemoved.emit(id2);
      });
    }
    _hasDoc(docId) {
      return this.docs.has(docId);
    }
    /**
     * Verify that all data has been successfully saved to the primary storage.
     * Return true if the data transfer is complete and it is secure to terminate the synchronization operation.
     */
    canGracefulStop() {
      this.docSync.canGracefulStop();
    }
    /**
     * By default, only an empty doc will be created.
     * If the `init` parameter is passed, a `surface`, `note`, and `paragraph` block
     * will be created in the doc simultaneously.
     */
    createDoc(options = {}) {
      const { id: docId = this.idGenerator(), query } = options;
      if (this._hasDoc(docId)) {
        throw new BlockSuiteError(ErrorCode.DocCollectionError, "doc already exists");
      }
      this.meta.addDocMeta({
        id: docId,
        title: "",
        createDate: Date.now(),
        tags: []
      });
      this.slots.docCreated.emit(docId);
      return this.getDoc(docId, { query });
    }
    dispose() {
      this.awarenessStore.destroy();
    }
    /**
     * Terminate the data sync process forcefully, which may cause data loss.
     * It is advised to invoke `canGracefulStop` before calling this method.
     */
    forceStop() {
      this.docSync.forceStop();
      this.blobSync.stop();
      this.awarenessSync.disconnect();
    }
    getBlockCollection(docId) {
      const space = this.docs.get(docId);
      return space ?? null;
    }
    getDoc(docId, options) {
      const collection = this.getBlockCollection(docId);
      return collection?.getDoc(options) ?? null;
    }
    removeDoc(docId) {
      const docMeta = this.meta.getDocMeta(docId);
      if (!docMeta) {
        throw new BlockSuiteError(ErrorCode.DocCollectionError, `doc meta not found: ${docId}`);
      }
      const blockCollection = this.getBlockCollection(docId);
      if (!blockCollection)
        return;
      blockCollection.dispose();
      this.meta.removeDocMeta(docId);
      this.blockCollections.delete(docId);
    }
    /** Update doc meta state. Note that this intentionally does not mutate doc state. */
    setDocMeta(docId, props) {
      this.meta.setDocMeta(docId, props);
    }
    /**
     * Start the data sync process
     */
    start() {
      this.docSync.start();
      this.blobSync.start();
      this.awarenessSync.connect();
    }
    /**
     * Wait for all data has been successfully saved to the primary storage.
     */
    waitForGracefulStop(abort) {
      return this.docSync.waitForGracefulStop(abort);
    }
    waitForSynced() {
      return this.docSync.waitForSynced();
    }
  }, _classThis = _a2, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
    __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
    DocCollection2 = _classThis = _classDescriptor.value;
    if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
  })(), _a2.Y = yjs_exports, __runInitializers(_classThis, _classExtraInitializers), _a2);
  return DocCollection2 = _classThis;
})();

// node_modules/@blocksuite/store/dist/transformer/assets.js
function makeNewNameWhenConflict(names, name) {
  let i2 = 1;
  const ext2 = name.split(".").at(-1) ?? "";
  let newName = name.replace(new RegExp(`.${ext2}$`), ` (${i2}).${ext2}`);
  while (names.has(newName)) {
    newName = name.replace(new RegExp(`.${ext2}$`), ` (${i2}).${ext2}`);
    i2++;
  }
  return newName;
}
var AssetsManager = class {
  constructor(options) {
    this._assetsMap = /* @__PURE__ */ new Map();
    this._names = /* @__PURE__ */ new Set();
    this._pathBlobIdMap = /* @__PURE__ */ new Map();
    this._blob = options.blob;
  }
  cleanup() {
    this._assetsMap.clear();
    this._names.clear();
  }
  getAssets() {
    return this._assetsMap;
  }
  getPathBlobIdMap() {
    return this._pathBlobIdMap;
  }
  isEmpty() {
    return this._assetsMap.size === 0;
  }
  async readFromBlob(blobId) {
    if (this._assetsMap.has(blobId))
      return;
    const blob = await this._blob.get(blobId);
    if (!blob) {
      console.error(`Blob ${blobId} not found in blob manager`);
      return;
    }
    if (blob instanceof File) {
      let file = blob;
      if (this._names.has(blob.name)) {
        const newName = makeNewNameWhenConflict(this._names, blob.name);
        file = new File([blob], newName, { type: blob.type });
      }
      this._assetsMap.set(blobId, file);
      this._names.add(file.name);
      return;
    }
    if (blob.type && blob.type !== "application/octet-stream") {
      this._assetsMap.set(blobId, blob);
      return;
    }
    const buffer = await blob.arrayBuffer();
    const FileType = await import("./core-DC5LQ7D4.js");
    const fileType = await FileType.fileTypeFromBuffer(buffer);
    if (fileType) {
      const file = new File([blob], "", { type: fileType.mime });
      this._assetsMap.set(blobId, file);
      return;
    }
    this._assetsMap.set(blobId, blob);
  }
  async writeToBlob(blobId) {
    const blob = this._assetsMap.get(blobId);
    if (!blob) {
      throw new BlockSuiteError(ErrorCode.TransformerError, `Blob ${blobId} not found in assets manager`);
    }
    const exists = await this._blob.get(blobId) !== null;
    if (exists) {
      return;
    }
    await this._blob.set(blobId, blob);
  }
};

// node_modules/@blocksuite/store/dist/transformer/json.js
function toJSON(value) {
  if (value instanceof Boxed) {
    return {
      [NATIVE_UNIQ_IDENTIFIER]: true,
      value: value.getValue()
    };
  }
  if (value instanceof Text) {
    return {
      [TEXT_UNIQ_IDENTIFIER]: true,
      delta: value.yText.toDelta()
    };
  }
  if (Array.isArray(value)) {
    return value.map(toJSON);
  }
  if (isPureObject(value)) {
    return Object.fromEntries(Object.entries(value).map(([key, value2]) => {
      return [key, toJSON(value2)];
    }));
  }
  return value;
}
function fromJSON(value) {
  if (Array.isArray(value)) {
    return value.map(fromJSON);
  }
  if (typeof value === "object" && value != null) {
    if (Reflect.has(value, NATIVE_UNIQ_IDENTIFIER)) {
      return new Boxed(Reflect.get(value, "value"));
    }
    if (Reflect.has(value, TEXT_UNIQ_IDENTIFIER)) {
      return new Text(Reflect.get(value, "delta"));
    }
    return Object.fromEntries(Object.entries(value).map(([key, value2]) => {
      return [key, fromJSON(value2)];
    }));
  }
  return value;
}

// node_modules/@blocksuite/store/dist/transformer/base.js
var BaseBlockTransformer = class {
  constructor() {
    this._internal = internalPrimitives;
  }
  _propsFromSnapshot(propsJson) {
    return Object.fromEntries(Object.entries(propsJson).map(([key, value]) => {
      return [key, fromJSON(value)];
    }));
  }
  _propsToSnapshot(model) {
    return Object.fromEntries(model.keys.map((key) => {
      const value = model[key];
      return [key, toJSON(value)];
    }));
  }
  fromSnapshot({ json }) {
    const { flavour, id: id2, version, props: _props } = json;
    const props = this._propsFromSnapshot(_props);
    return {
      id: id2,
      flavour,
      version: version ?? -1,
      props
    };
  }
  toSnapshot({ model }) {
    const { id: id2, flavour, version } = model;
    const props = this._propsToSnapshot(model);
    return {
      id: id2,
      flavour,
      version,
      props
    };
  }
};

// node_modules/@blocksuite/store/dist/transformer/draft.js
function toDraftModel(origin) {
  const { id: id2, version, flavour, role: role2, keys: keys4, text: text2, children } = origin;
  const props = origin.keys.reduce((acc, key) => {
    return {
      ...acc,
      [key]: origin[key]
    };
  }, {});
  return {
    id: id2,
    version,
    flavour,
    role: role2,
    keys: keys4,
    text: text2,
    children: children.map(toDraftModel),
    ...props
  };
}

// node_modules/@blocksuite/store/dist/transformer/slice.js
var Slice = class _Slice {
  get content() {
    return this.data.content;
  }
  get docId() {
    return this.data.pageId;
  }
  get workspaceId() {
    return this.data.workspaceId;
  }
  constructor(data) {
    this.data = data;
  }
  static fromModels(doc2, models) {
    return new _Slice({
      content: models,
      workspaceId: doc2.collection.id,
      pageId: doc2.id
    });
  }
};

// node_modules/@blocksuite/store/dist/transformer/type.js
var BlockSnapshotSchema = external_exports.object({
  type: external_exports.literal("block"),
  id: external_exports.string(),
  flavour: external_exports.string(),
  version: external_exports.number().optional(),
  props: external_exports.record(external_exports.unknown()),
  children: external_exports.lazy(() => BlockSnapshotSchema.array())
});
var SliceSnapshotSchema = external_exports.object({
  type: external_exports.literal("slice"),
  content: BlockSnapshotSchema.array(),
  workspaceId: external_exports.string(),
  pageId: external_exports.string()
});
var CollectionInfoSnapshotSchema = external_exports.object({
  id: external_exports.string(),
  type: external_exports.literal("info"),
  properties: external_exports.record(external_exports.any())
});
var DocMetaSchema = external_exports.object({
  id: external_exports.string(),
  title: external_exports.string(),
  createDate: external_exports.number(),
  tags: external_exports.array(external_exports.string())
});
var DocSnapshotSchema = external_exports.object({
  type: external_exports.literal("page"),
  meta: DocMetaSchema,
  blocks: BlockSnapshotSchema
});

// node_modules/@blocksuite/store/dist/transformer/job.js
var BATCH_SIZE = 100;
var Job = class {
  get adapterConfigs() {
    return this._adapterConfigs;
  }
  get assets() {
    return this._assetsManager.getAssets();
  }
  get assetsManager() {
    return this._assetsManager;
  }
  get collection() {
    return this._collection;
  }
  constructor({ collection, middlewares = [] }) {
    this._adapterConfigs = /* @__PURE__ */ new Map();
    this._slots = {
      beforeImport: new Slot(),
      afterImport: new Slot(),
      beforeExport: new Slot(),
      afterExport: new Slot()
    };
    this.blockToSnapshot = (model) => {
      try {
        const snapshot2 = this._blockToSnapshot(model);
        BlockSnapshotSchema.parse(snapshot2);
        return snapshot2;
      } catch (error) {
        console.error(`Error when transforming block to snapshot:`);
        console.error(error);
        return;
      }
    };
    this.collectionInfoToSnapshot = () => {
      try {
        this._slots.beforeExport.emit({
          type: "info"
        });
        const collectionMeta = this._getCollectionMeta();
        const snapshot2 = {
          type: "info",
          id: this._collection.id,
          ...collectionMeta
        };
        this._slots.afterExport.emit({
          type: "info",
          snapshot: snapshot2
        });
        CollectionInfoSnapshotSchema.parse(snapshot2);
        return snapshot2;
      } catch (error) {
        console.error(`Error when transforming collection info to snapshot:`);
        console.error(error);
        return;
      }
    };
    this.docToSnapshot = (doc2) => {
      try {
        this._slots.beforeExport.emit({
          type: "page",
          page: doc2
        });
        const rootModel = doc2.root;
        const meta = this._exportDocMeta(doc2);
        if (!rootModel) {
          throw new BlockSuiteError(ErrorCode.TransformerError, "Root block not found in doc");
        }
        const blocks = this.blockToSnapshot(rootModel);
        if (!blocks) {
          return;
        }
        const docSnapshot = {
          type: "page",
          meta,
          blocks
        };
        this._slots.afterExport.emit({
          type: "page",
          page: doc2,
          snapshot: docSnapshot
        });
        DocSnapshotSchema.parse(docSnapshot);
        return docSnapshot;
      } catch (error) {
        console.error(`Error when transforming doc to snapshot:`);
        console.error(error);
        return;
      }
    };
    this.sliceToSnapshot = (slice) => {
      try {
        this._slots.beforeExport.emit({
          type: "slice",
          slice
        });
        const { content, pageId, workspaceId } = slice.data;
        const contentSnapshot = [];
        for (const block of content) {
          const blockSnapshot = this.blockToSnapshot(block);
          if (!blockSnapshot) {
            return;
          }
          contentSnapshot.push(blockSnapshot);
        }
        const snapshot2 = {
          type: "slice",
          workspaceId,
          pageId,
          content: contentSnapshot
        };
        this._slots.afterExport.emit({
          type: "slice",
          slice,
          snapshot: snapshot2
        });
        SliceSnapshotSchema.parse(snapshot2);
        return snapshot2;
      } catch (error) {
        console.error(`Error when transforming slice to snapshot:`);
        console.error(error);
        return;
      }
    };
    this.snapshotToBlock = async (snapshot2, doc2, parent, index) => {
      try {
        BlockSnapshotSchema.parse(snapshot2);
        const model = await this._snapshotToBlock(snapshot2, doc2, parent, index);
        if (!model)
          return;
        return model;
      } catch (error) {
        console.error(`Error when transforming snapshot to block:`);
        console.error(error);
        return;
      }
    };
    this.snapshotToDoc = async (snapshot2) => {
      try {
        this._slots.beforeImport.emit({
          type: "page",
          snapshot: snapshot2
        });
        DocSnapshotSchema.parse(snapshot2);
        const { meta, blocks } = snapshot2;
        const doc2 = this._collection.createDoc({ id: meta.id });
        doc2.load();
        await this.snapshotToBlock(blocks, doc2);
        this._slots.afterImport.emit({
          type: "page",
          snapshot: snapshot2,
          page: doc2
        });
        return doc2;
      } catch (error) {
        console.error(`Error when transforming snapshot to doc:`);
        console.error(error);
        return;
      }
    };
    this.snapshotToModelData = async (snapshot2) => {
      try {
        const { children, flavour, props, id: id2 } = snapshot2;
        const schema = this._getSchema(flavour);
        const snapshotLeaf = {
          id: id2,
          flavour,
          props
        };
        const transformer = this._getTransformer(schema);
        const modelData = await transformer.fromSnapshot({
          json: snapshotLeaf,
          assets: this._assetsManager,
          children
        });
        return modelData;
      } catch (error) {
        console.error(`Error when transforming snapshot to model data:`);
        console.error(error);
        return;
      }
    };
    this.snapshotToSlice = async (snapshot2, doc2, parent, index) => {
      SliceSnapshotSchema.parse(snapshot2);
      try {
        this._slots.beforeImport.emit({
          type: "slice",
          snapshot: snapshot2
        });
        const { content, workspaceId, pageId } = snapshot2;
        const tmpRootSnapshot = {
          id: "temporary-root",
          flavour: "affine:page",
          props: {},
          type: "block",
          children: content
        };
        for (const block of content) {
          this._triggerBeforeImportEvent(block, parent, index);
        }
        const flatSnapshots = [];
        this._flattenSnapshot(tmpRootSnapshot, flatSnapshots, parent, index);
        const blockTree = await this._convertFlatSnapshots(flatSnapshots);
        await this._insertBlockTree(blockTree.children, doc2, parent, index);
        const contentBlocks = blockTree.children.map((tree) => doc2.getBlockById(tree.draft.id)).filter(Boolean);
        const slice = new Slice({
          content: contentBlocks,
          workspaceId,
          pageId
        });
        this._slots.afterImport.emit({
          type: "slice",
          snapshot: snapshot2,
          slice
        });
        return slice;
      } catch (error) {
        console.error(`Error when transforming snapshot to slice:`);
        console.error(error);
        return;
      }
    };
    this.walk = (snapshot2, callback) => {
      const walk = (block) => {
        try {
          callback(block);
        } catch (error) {
          console.error(`Error when walking snapshot:`);
          console.error(error);
        }
        if (block.children) {
          block.children.forEach(walk);
        }
      };
      walk(snapshot2.blocks);
    };
    this._collection = collection;
    this._assetsManager = new AssetsManager({ blob: collection.blobSync });
    middlewares.forEach((middleware) => {
      middleware({
        slots: this._slots,
        assetsManager: this._assetsManager,
        collection: this._collection,
        adapterConfigs: this._adapterConfigs
      });
    });
  }
  _blockToSnapshot(model) {
    this._slots.beforeExport.emit({
      type: "block",
      model
    });
    const schema = this._getSchema(model.flavour);
    const transformer = this._getTransformer(schema);
    const snapshotLeaf = transformer.toSnapshot({
      model,
      assets: this._assetsManager
    });
    const children = model.children.map((child) => {
      return this._blockToSnapshot(child);
    });
    const snapshot2 = {
      type: "block",
      ...snapshotLeaf,
      children
    };
    this._slots.afterExport.emit({
      type: "block",
      model,
      snapshot: snapshot2
    });
    return snapshot2;
  }
  async _convertFlatSnapshots(flatSnapshots) {
    const draftModels = [];
    for (const flat of flatSnapshots) {
      const draft = await this._convertSnapshotToDraftModel(flat);
      if (draft) {
        draft.id = flat.snapshot.id;
      }
      draftModels.push({
        draft,
        snapshot: flat.snapshot,
        parentId: flat.parentId,
        index: flat.index
      });
    }
    const validDraftModels = draftModels.filter((item) => !!item.draft);
    const blockTree = this._rebuildBlockTree(validDraftModels);
    return blockTree;
  }
  async _convertSnapshotToDraftModel(flat) {
    try {
      const { children, flavour } = flat.snapshot;
      const schema = this._getSchema(flavour);
      const transformer = this._getTransformer(schema);
      const { props } = await transformer.fromSnapshot({
        json: {
          id: flat.snapshot.id,
          flavour: flat.snapshot.flavour,
          props: flat.snapshot.props
        },
        assets: this._assetsManager,
        children
      });
      return {
        id: flat.snapshot.id,
        flavour: flat.snapshot.flavour,
        children: [],
        ...props
      };
    } catch (error) {
      console.error(`Error when transforming snapshot to model data:`);
      console.error(error);
      return;
    }
  }
  _exportDocMeta(doc2) {
    const docMeta = doc2.meta;
    if (!docMeta) {
      throw new BlockSuiteError(ErrorCode.TransformerError, "Doc meta not found");
    }
    return {
      id: docMeta.id,
      title: docMeta.title,
      createDate: docMeta.createDate,
      tags: []
      // for backward compatibility
    };
  }
  _flattenSnapshot(snapshot2, flatSnapshots, parentId, index) {
    flatSnapshots.push({ snapshot: snapshot2, parentId, index });
    if (snapshot2.children) {
      snapshot2.children.forEach((child, idx) => {
        this._flattenSnapshot(child, flatSnapshots, snapshot2.id, idx);
      });
    }
  }
  _getCollectionMeta() {
    const { meta } = this._collection;
    const { docs } = meta;
    if (!docs) {
      throw new BlockSuiteError(ErrorCode.TransformerError, "Docs not found");
    }
    return {
      properties: {},
      // for backward compatibility
      pages: JSON.parse(JSON.stringify(docs))
    };
  }
  _getSchema(flavour) {
    const schema = this._collection.schema.flavourSchemaMap.get(flavour);
    if (!schema) {
      throw new BlockSuiteError(ErrorCode.TransformerError, `Flavour schema not found for ${flavour}`);
    }
    return schema;
  }
  _getTransformer(schema) {
    return schema.transformer?.() ?? new BaseBlockTransformer();
  }
  async _insertBlockTree(nodes, doc2, parentId, startIndex, counter = 0) {
    for (let index = 0; index < nodes.length; index++) {
      const node = nodes[index];
      const { draft } = node;
      const { id: id2, flavour } = draft;
      const actualIndex = startIndex !== void 0 ? startIndex + index : void 0;
      doc2.addBlock(flavour, draft, parentId, actualIndex);
      const model = doc2.getBlock(id2)?.model;
      if (!model) {
        throw new BlockSuiteError(ErrorCode.TransformerError, `Block not found by id ${id2}`);
      }
      this._slots.afterImport.emit({
        type: "block",
        model,
        snapshot: node.snapshot
      });
      counter++;
      if (counter % BATCH_SIZE === 0) {
        await nextTick();
      }
      if (node.children.length > 0) {
        counter = await this._insertBlockTree(node.children, doc2, id2, void 0, counter);
      }
    }
    return counter;
  }
  _rebuildBlockTree(draftModels) {
    const nodeMap = /* @__PURE__ */ new Map();
    draftModels.forEach(({ draft, snapshot: snapshot2 }) => {
      nodeMap.set(draft.id, { draft, snapshot: snapshot2, children: [] });
    });
    const root = nodeMap.get(draftModels[0].draft.id);
    draftModels.forEach(({ draft, parentId, index }) => {
      const node = nodeMap.get(draft.id);
      if (!node)
        return;
      if (parentId) {
        const parentNode = nodeMap.get(parentId);
        if (parentNode && index !== void 0) {
          parentNode.children[index] = node;
        }
      }
    });
    if (!root) {
      throw new Error("No root node found in the tree");
    }
    return root;
  }
  async _snapshotToBlock(snapshot2, doc2, parent, index) {
    this._triggerBeforeImportEvent(snapshot2, parent, index);
    const flatSnapshots = [];
    this._flattenSnapshot(snapshot2, flatSnapshots, parent, index);
    const blockTree = await this._convertFlatSnapshots(flatSnapshots);
    await this._insertBlockTree([blockTree], doc2, parent, index);
    return doc2.getBlock(snapshot2.id)?.model ?? null;
  }
  _triggerBeforeImportEvent(snapshot2, parent, index) {
    const traverseAndTrigger = (node, parent2, index2) => {
      this._slots.beforeImport.emit({
        type: "block",
        snapshot: node,
        parent: parent2,
        index: index2
      });
      if (node.children) {
        node.children.forEach((child, idx) => {
          traverseAndTrigger(child, node.id, idx);
        });
      }
    };
    traverseAndTrigger(snapshot2, parent, index);
  }
  reset() {
    this._assetsManager.cleanup();
  }
};

// node_modules/@blocksuite/store/dist/index.js
var env = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : (
  // @ts-ignore
  typeof global !== "undefined" ? (
    // @ts-ignore
    global
  ) : {}
);
var importIdentifier2 = "__ $BLOCKSUITE_STORE$ __";
if (env[importIdentifier2] === true) {
  console.error("@blocksuite/store was already imported. This breaks constructor checks and will lead to issues!");
}
env[importIdentifier2] = true;

export {
  ErrorCode,
  BlockSuiteError,
  handleError,
  assertType,
  assertExists,
  isEqual,
  assertEquals,
  assertInstanceOf,
  Vec,
  PointLocation,
  PI2,
  randomSeed,
  lineIntersects,
  polygonNearestPoint,
  polygonPointDistance,
  rotatePoints,
  toRadian,
  polygonGetPointTangent,
  linePolygonIntersects,
  linePolylineIntersects,
  polyLineNearestPoint,
  isPointOnlines,
  isPointIn,
  intersects,
  almostEqual,
  isVecZero,
  clamp,
  pointInEllipse,
  pointInPolygon,
  pointOnPolygonStoke,
  getPolygonPathFromPoints,
  getSvgPathFromStroke,
  lineEllipseIntersects,
  sign,
  getPointFromBoundsWithRotation,
  normalizeDegAngle,
  toDegree,
  isOverlap,
  getCenterAreaBounds,
  serializeXYWH,
  deserializeXYWH,
  Bound,
  Point,
  Rect,
  getPointsFromBoundWithRotation,
  getQuadBoundWithRotation,
  getBoundWithRotation,
  getCommonBound,
  getCommonBoundWithRotation,
  getBoundFromPoints,
  inflateBound,
  transformPointsToNewBound,
  sha,
  getBezierPoint,
  getBezierTangent,
  getBezierNearestTime,
  getBezierNearestPoint,
  getBezierParameters,
  getBezierCurveBoundingBox,
  curveIntersects,
  DisposableGroup,
  sleep,
  noop,
  throttle,
  debounce,
  nextTick,
  countBy,
  maxBy,
  atLeastNMatches,
  groupBy,
  pick,
  pickValues,
  keys2 as keys,
  last2 as last,
  nToLast,
  getStroke,
  getSolidStrokePoints,
  Polyline,
  u,
  d,
  w,
  E,
  SignalWatcher,
  Slot,
  WithDisposable,
  MemoryBlobCRUD,
  mimeExtMap,
  extMimeMap,
  getAssetName,
  ASTWalkerContext,
  wrapFakeNote,
  BaseAdapter,
  ASTWalker,
  createRelativePositionFromTypeIndex,
  createAbsolutePositionFromRelativePosition,
  Boxed,
  Text,
  isPureObject,
  native2Y,
  y2Native,
  BaseReactiveYData,
  ReactiveYArray,
  ReactiveYMap,
  createYProxy,
  stashProp,
  popProp,
  internalPrimitives,
  BlockSchema,
  defineBlockSchema,
  BlockModel,
  minimatch,
  Schema,
  require_lodash,
  AwarenessStore,
  BlockSuiteDoc,
  utils_exports,
  BlockViewType,
  createMutex,
  mutex_exports,
  Block,
  runQuery,
  Doc2 as Doc,
  BlockCollection,
  nanoid,
  createAutoIncrementIdGenerator,
  createAutoIncrementIdGeneratorByClientId,
  uuidv42 as uuidv4,
  nanoid2,
  IdGeneratorType,
  pickIdGenerator,
  DocCollection,
  AssetsManager,
  toJSON,
  fromJSON,
  BaseBlockTransformer,
  toDraftModel,
  Slice,
  BlockSnapshotSchema,
  SliceSnapshotSchema,
  CollectionInfoSnapshotSchema,
  DocSnapshotSchema,
  Job
};
/*! Bundled license information:

@blocksuite/global/dist/utils/signal-watcher.js:
  (**
   * @license
   * Copyright 2023 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
//# sourceMappingURL=chunk-EHP7OGXL.js.map
